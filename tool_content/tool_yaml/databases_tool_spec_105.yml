field_name: databases
subfield: Query Optimization and Performance Tuning
task: Index recommendation and impact assessment
tool_description: |-
  **STEP 1 — Rate task difficulty**
  This task is of medium difficulty. It requires analyzing database schemas, query patterns, and performance metrics to recommend optimal indexing strategies, which involves moderate complexity in terms of data analysis, performance modeling, and impact prediction with some coordination between schema analysis and query optimization components.

  **STEP 2 — Set a tool budget**
  Based on medium complexity, I'll target 12 tools to cover the breadth of index recommendation and impact assessment workflows.

  **STEP 3 — List all tool names and dependencies**

  1. **Schema Analyzer** - Consumes: database connection details → Produces: table schemas, column statistics
  2. **Query Pattern Extractor** - Consumes: query logs, time ranges → Produces: query patterns, frequency data
  3. **Query Performance Profiler** - Consumes: queries, database connection → Produces: execution plans, performance metrics
  4. **Index Candidate Generator** - Consumes: schema info, query patterns → Produces: potential index recommendations
  5. **Index Impact Simulator** - Consumes: index candidates, query workload → Produces: performance impact predictions
  6. **Storage Cost Calculator** - Consumes: index specifications, table sizes → Produces: storage overhead estimates
  7. **Index Conflict Detector** - Consumes: existing indexes, new candidates → Produces: redundancy analysis
  8. **Maintenance Cost Estimator** - Consumes: table update patterns, index specs → Produces: maintenance overhead metrics
  9. **Query Rewriter** - Consumes: queries, available indexes → Produces: optimized query variants
  10. **Performance Benchmark Runner** - Consumes: queries, database state → Produces: execution time measurements
  11. **Index Implementation Planner** - Consumes: approved indexes, database constraints → Produces: implementation strategy
  12. **Impact Report Generator** - Consumes: all analysis results → Produces: comprehensive recommendation report

  **STEP 4 — Multi-tool plans**

  **Simple Plans:**
  1. **Basic Schema Analysis**: Schema Analyzer → Index Candidate Generator → Storage Cost Calculator (analyzes current schema and generates basic index suggestions with storage costs)
  2. **Quick Performance Check**: Query Performance Profiler → Performance Benchmark Runner (profiles current query performance for baseline measurement)

  **Medium Plans:**
  1. **Standard Index Recommendation**: Query Pattern Extractor → Schema Analyzer → Index Candidate Generator → Index Impact Simulator → Index Conflict Detector → Impact Report Generator (complete workflow for generating and evaluating index recommendations)
  2. **Cost-Benefit Analysis**: Index Candidate Generator → Storage Cost Calculator → Maintenance Cost Estimator → Index Impact Simulator (evaluates both benefits and costs of proposed indexes)

  **Complex Plans:**
  1. **Comprehensive Index Optimization**: Query Pattern Extractor → Schema Analyzer → Query Performance Profiler → Index Candidate Generator → Index Impact Simulator → Index Conflict Detector → Storage Cost Calculator → Maintenance Cost Estimator → Query Rewriter → Performance Benchmark Runner → Index Implementation Planner → Impact Report Generator (full end-to-end index optimization workflow)
  2. **Production Migration Planning**: Index Candidate Generator → Index Impact Simulator → Index Conflict Detector → Maintenance Cost Estimator → Index Implementation Planner → Performance Benchmark Runner (focuses on safe production deployment of index changes)

  **STEP 5 — Produce tools**

  ```json
  {
    "tool_name": "Schema Analyzer",
    "tool_description": "Analyzes database schema to extract table structures, column statistics, data types, constraints, and existing indexes for index recommendation analysis.",
    "parameters": {
      "database_host": {
        "type": "string",
        "required": true,
        "description": "Database server hostname or IP address"
      },
      "database_port": {
        "type": "integer",
        "required": true,
        "description": "Database server port number"
      },
      "database_name": {
        "type": "string",
        "required": true,
        "description": "Name of the database to analyze"
      },
      "username": {
        "type": "string",
        "required": true,
        "description": "Database username with read permissions"
      },
      "password": {
        "type": "string",
        "required": true,
        "description": "Database user password"
      },
      "schema_names": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Specific schema names to analyze",
        "default": null
      },
      "include_statistics": {
        "type": "boolean",
        "required": false,
        "description": "Whether to collect table and column statistics",
        "default": true
      }
    },
    "error_messages": [
      "Connection failed: Unable to connect to database. Verify host, port, credentials, and network connectivity.",
      "Authentication error: Invalid username or password provided.",
      "Database not found: The specified database name does not exist.",
      "Schema access denied: User lacks permissions to access specified schemas.",
      "Invalid schema names: One or more specified schema names do not exist."
    ],
    "usage": "Provide database connection details and optionally specify schema_names to focus analysis. Enable include_statistics for detailed column statistics needed for advanced index recommendations.",
    "output_details": {
      "total_tables": {
        "type": "integer",
        "description": "Total number of tables analyzed"
      },
      "table_names": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of analyzed table names"
      },
      "existing_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of existing index definitions"
      },
      "column_statistics": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Statistical information about table columns"
      },
      "table_sizes": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Table sizes in MB corresponding to table_names"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Query Pattern Extractor",
    "tool_description": "Extracts and analyzes query patterns from database logs to identify frequently executed queries, access patterns, and performance bottlenecks.",
    "parameters": {
      "log_file_path": {
        "type": "string",
        "required": true,
        "description": "Path to database query log file"
      },
      "start_time": {
        "type": "string",
        "format": "date-time",
        "required": true,
        "description": "Start timestamp for log analysis period"
      },
      "end_time": {
        "type": "string",
        "format": "date-time",
        "required": true,
        "description": "End timestamp for log analysis period"
      },
      "min_execution_count": {
        "type": "integer",
        "required": false,
        "description": "Minimum execution count to include query pattern",
        "default": 5
      }
    },
    "error_messages": [
      "Log file not found: The specified log file path does not exist or is not accessible.",
      "Invalid time range: start_time must be earlier than end_time and both must be valid ISO 8601 timestamps.",
      "Log format error: Unable to parse log file format. Ensure standard database log format.",
      "No data in range: No query logs found within the specified time range.",
      "Invalid execution count: min_execution_count must be a positive integer."
    ],
    "usage": "Specify the log file path and time range for analysis. Adjust min_execution_count to filter out infrequent queries and focus on patterns that would benefit most from indexing.",
    "output_details": {
      "total_queries": {
        "type": "integer",
        "description": "Total number of queries found in the time range"
      },
      "unique_patterns": {
        "type": "integer",
        "description": "Number of unique query patterns identified"
      },
      "query_templates": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Normalized query templates representing patterns"
      },
      "execution_frequencies": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Execution counts for each query template"
      },
      "average_durations": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Average execution times in milliseconds for each pattern"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Query Performance Profiler",
    "tool_description": "Profiles query execution performance by analyzing execution plans, identifying bottlenecks, and measuring resource consumption for optimization planning.",
    "parameters": {
      "database_host": {
        "type": "string",
        "required": true,
        "description": "Database server hostname or IP address"
      },
      "database_port": {
        "type": "integer",
        "required": true,
        "description": "Database server port number"
      },
      "database_name": {
        "type": "string",
        "required": true,
        "description": "Name of the database to profile"
      },
      "username": {
        "type": "string",
        "required": true,
        "description": "Database username with query execution permissions"
      },
      "password": {
        "type": "string",
        "required": true,
        "description": "Database user password"
      },
      "queries": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "SQL queries to profile",
        "minItems": 1,
        "maxItems": 50
      },
      "include_execution_plan": {
        "type": "boolean",
        "required": false,
        "description": "Whether to include detailed execution plans",
        "default": true
      },
      "timeout_seconds": {
        "type": "integer",
        "required": false,
        "description": "Maximum execution time per query in seconds",
        "default": 60
      }
    },
    "error_messages": [
      "Connection failed: Unable to connect to database. Verify connection parameters.",
      "Query syntax error: One or more queries contain syntax errors.",
      "Query timeout: Query execution exceeded the specified timeout limit.",
      "Insufficient permissions: User lacks permissions to execute queries or view execution plans.",
      "Too many queries: Maximum of 50 queries can be profiled in a single request."
    ],
    "usage": "Provide database connection details and an array of SQL queries to profile. Enable include_execution_plan for detailed analysis. Set appropriate timeout_seconds for long-running queries.",
    "output_details": {
      "query_count": {
        "type": "integer",
        "description": "Number of queries successfully profiled"
      },
      "execution_times": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Execution times in milliseconds for each query"
      },
      "execution_plans": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Detailed execution plans for each query"
      },
      "scan_operations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Table scan operations identified in each query"
      },
      "bottlenecks": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Performance bottlenecks identified for each query"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Candidate Generator",
    "tool_description": "Generates optimal index candidates based on schema analysis and query patterns, considering column selectivity, query frequency, and access patterns.",
    "parameters": {
      "schema_info": {
        "type": "string",
        "required": true,
        "description": "JSON string containing schema analysis results"
      },
      "query_patterns": {
        "type": "string",
        "required": true,
        "description": "JSON string containing query pattern analysis results"
      },
      "max_candidates": {
        "type": "integer",
        "required": false,
        "description": "Maximum number of index candidates to generate",
        "default": 20
      },
      "min_selectivity": {
        "type": "number",
        "required": false,
        "description": "Minimum column selectivity threshold (0.0 to 1.0)",
        "default": 0.1
      },
      "consider_composite": {
        "type": "boolean",
        "required": false,
        "description": "Whether to generate composite index candidates",
        "default": true
      }
    },
    "error_messages": [
      "Invalid schema info: Schema information is malformed or incomplete JSON.",
      "Invalid query patterns: Query pattern data is malformed or incomplete JSON.",
      "Parameter out of range: max_candidates must be between 1 and 50, min_selectivity must be between 0.0 and 1.0.",
      "No viable candidates: No suitable index candidates found based on provided criteria.",
      "Data inconsistency: Schema and query pattern data appear to be from different databases."
    ],
    "usage": "Provide schema_info and query_patterns as JSON strings from previous analysis tools. Adjust max_candidates and min_selectivity to control recommendation scope. Enable consider_composite for advanced multi-column indexes.",
    "output_details": {
      "candidate_count": {
        "type": "integer",
        "description": "Number of index candidates generated"
      },
      "index_definitions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "SQL CREATE INDEX statements for each candidate"
      },
      "target_tables": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Table names for each index candidate"
      },
      "priority_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Priority scores for each candidate (0.0 to 1.0)"
      },
      "expected_queries_improved": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Number of queries each index is expected to improve"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Impact Simulator",
    "tool_description": "Simulates the performance impact of proposed indexes on query workload by estimating execution time improvements and resource utilization changes.",
    "parameters": {
      "index_candidates": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Array of CREATE INDEX statements to simulate",
        "minItems": 1,
        "maxItems": 20
      },
      "workload_queries": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Representative query workload for simulation",
        "minItems": 1,
        "maxItems": 100
      },
      "query_frequencies": {
        "type": "array",
        "items": {"type": "integer"},
        "required": true,
        "description": "Execution frequency for each workload query",
        "minItems": 1,
        "maxItems": 100
      },
      "simulation_method": {
        "type": "string",
        "required": false,
        "description": "Simulation approach: cost_model or sampling",
        "default": "cost_model"
      }
    },
    "error_messages": [
      "Invalid index syntax: One or more CREATE INDEX statements contain syntax errors.",
      "Query workload mismatch: workload_queries and query_frequencies arrays must have the same length.",
      "Invalid simulation method: Use either 'cost_model' or 'sampling'.",
      "Workload too large: Maximum 100 queries and 20 indexes can be simulated simultaneously.",
      "Frequency values invalid: All query frequencies must be positive integers."
    ],
    "usage": "Provide index_candidates as CREATE INDEX statements, workload_queries with corresponding query_frequencies. Choose simulation_method based on accuracy needs vs. execution time trade-offs.",
    "output_details": {
      "overall_improvement": {
        "type": "number",
        "description": "Overall workload performance improvement percentage"
      },
      "per_index_impact": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Individual performance impact of each index candidate"
      },
      "query_improvements": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Performance improvement percentage for each query"
      },
      "affected_query_count": {
        "type": "integer",
        "description": "Number of queries that would benefit from the indexes"
      },
      "simulation_confidence": {
        "type": "number",
        "description": "Confidence score of simulation accuracy (0.0 to 1.0)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Storage Cost Calculator",
    "tool_description": "Calculates storage overhead and space requirements for proposed indexes based on table sizes, column data types, and index specifications.",
    "parameters": {
      "index_specifications": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "CREATE INDEX statements to analyze for storage costs"
      },
      "table_sizes": {
        "type": "array",
        "items": {"type": "integer"},
        "required": true,
        "description": "Current table sizes in MB for each indexed table"
      }
    },
    "error_messages": [
      "Invalid index syntax: One or more CREATE INDEX statements are malformed.",
      "Table size mismatch: Unable to match all indexes to corresponding table sizes.",
      "Invalid table sizes: All table sizes must be positive integers representing MB.",
      "Unsupported index type: One or more index types are not supported for cost calculation."
    ],
    "usage": "Provide index_specifications as CREATE INDEX statements and corresponding table_sizes in MB. Ensure each index can be matched to a table size for accurate calculation.",
    "output_details": {
      "total_storage_mb": {
        "type": "integer",
        "description": "Total additional storage required in MB"
      },
      "per_index_storage": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Storage cost in MB for each individual index"
      },
      "storage_overhead_percentage": {
        "type": "number",
        "description": "Percentage increase in total database storage"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Conflict Detector",
    "tool_description": "Detects conflicts, redundancies, and overlaps between existing indexes and proposed index candidates to avoid unnecessary duplication.",
    "parameters": {
      "existing_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Current database index definitions"
      },
      "proposed_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "New index candidates to check for conflicts"
      },
      "conflict_threshold": {
        "type": "number",
        "required": false,
        "description": "Similarity threshold for detecting conflicts (0.0 to 1.0)",
        "default": 0.8
      }
    },
    "error_messages": [
      "Invalid index definitions: One or more index definitions contain syntax errors.",
      "Conflict threshold out of range: threshold must be between 0.0 and 1.0.",
      "Empty index arrays: Both existing_indexes and proposed_indexes must contain at least one index.",
      "Index parsing failed: Unable to parse index structure for conflict detection."
    ],
    "usage": "Provide arrays of existing_indexes and proposed_indexes as CREATE INDEX statements. Adjust conflict_threshold to control sensitivity of conflict detection (higher values detect only obvious conflicts).",
    "output_details": {
      "conflicts_found": {
        "type": "boolean",
        "description": "Whether any conflicts were detected"
      },
      "conflict_details": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Descriptions of detected conflicts and overlaps"
      },
      "redundant_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Proposed indexes that are redundant with existing ones"
      },
      "recommended_removals": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Existing indexes that could be removed if new ones are created"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Maintenance Cost Estimator",
    "tool_description": "Estimates ongoing maintenance overhead for proposed indexes based on table update patterns, insert/update/delete frequencies, and index characteristics.",
    "parameters": {
      "index_definitions": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "CREATE INDEX statements to analyze for maintenance costs"
      },
      "table_update_frequencies": {
        "type": "array",
        "items": {"type": "integer"},
        "required": true,
        "description": "Daily update operations per table (inserts + updates + deletes)"
      },
      "insert_ratio": {
        "type": "number",
        "required": false,
        "description": "Percentage of operations that are inserts (0.0 to 1.0)",
        "default": 0.4
      },
      "update_ratio": {
        "type": "number",
        "required": false,
        "description": "Percentage of operations that are updates (0.0 to 1.0)",
        "default": 0.4
      },
      "delete_ratio": {
        "type": "number",
        "required": false,
        "description": "Percentage of operations that are deletes (0.0 to 1.0)",
        "default": 0.2
      },
      "peak_load_multiplier": {
        "type": "number",
        "required": false,
        "description": "Peak load multiplier for maintenance overhead calculation",
        "default": 2.0
      },
      "database_engine": {
        "type": "string",
        "required": false,
        "description": "Database engine type: mysql, postgresql, oracle, sqlserver",
        "default": "postgresql"
      }
    },
    "error_messages": [
      "Invalid index definitions: One or more CREATE INDEX statements are malformed.",
      "Operation ratios invalid: insert_ratio + update_ratio + delete_ratio must equal 1.0.",
      "Invalid frequencies: All update frequencies must be non-negative integers.",
      "Unsupported database engine: Use one of mysql, postgresql, oracle, sqlserver.",
      "Peak load multiplier invalid: Must be a positive number between 1.0 and 10.0.",
      "Array length mismatch: index_definitions and table_update_frequencies must have compatible lengths."
    ],
    "usage": "Provide index_definitions and corresponding table_update_frequencies. Adjust operation ratios to match your workload characteristics. Set peak_load_multiplier based on expected traffic patterns.",
    "output_details": {
      "total_daily_overhead_ms": {
        "type": "integer",
        "description": "Total daily maintenance overhead in milliseconds"
      },
      "per_index_overhead": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Daily maintenance cost in milliseconds for each index"
      },
      "peak_overhead_impact": {
        "type": "number",
        "description": "Percentage increase in write operation time during peak load"
      },
      "maintenance_complexity": {
        "type": "string",
        "description": "Overall maintenance complexity rating: low, medium, high"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Query Rewriter",
    "tool_description": "Rewrites queries to optimize them for available indexes, suggesting alternative formulations that can leverage existing or proposed indexes more effectively.",
    "parameters": {
      "original_queries": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "SQL queries to optimize for available indexes"
      },
      "available_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Available index definitions for optimization"
      },
      "optimization_level": {
        "type": "string",
        "required": false,
        "description": "Optimization aggressiveness: conservative, moderate, aggressive",
        "default": "moderate"
      }
    },
    "error_messages": [
      "Query syntax error: One or more queries contain SQL syntax errors.",
      "Invalid index definitions: One or more index definitions are malformed.",
      "Invalid optimization level: Use conservative, moderate, or aggressive.",
      "No optimization possible: Queries cannot be optimized with available indexes.",
      "Query too complex: One or more queries are too complex for automatic rewriting."
    ],
    "usage": "Provide original_queries and available_indexes. Choose optimization_level based on how much you want to modify query structure - conservative maintains query logic closely, aggressive allows more restructuring.",
    "output_details": {
      "optimized_queries": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Rewritten SQL queries optimized for available indexes"
      },
      "optimization_applied": {
        "type": "array",
        "items": {"type": "boolean"},
        "description": "Whether optimization was applied to each query"
      },
      "optimization_notes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Explanation of optimizations applied to each query"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Performance Benchmark Runner",
    "tool_description": "Executes performance benchmarks by running queries against the database and measuring execution times, resource usage, and throughput metrics.",
    "parameters": {
      "database_host": {
        "type": "string",
        "required": true,
        "description": "Database server hostname or IP address"
      },
      "database_port": {
        "type": "integer",
        "required": true,
        "description": "Database server port number"
      },
      "database_name": {
        "type": "string",
        "required": true,
        "description": "Name of the database to benchmark"
      },
      "username": {
        "type": "string",
        "required": true,
        "description": "Database username with query execution permissions"
      },
      "password": {
        "type": "string",
        "required": true,
        "description": "Database user password"
      },
      "benchmark_queries": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "SQL queries to benchmark",
        "minItems": 1,
        "maxItems": 50
      },
      "iterations": {
        "type": "integer",
        "required": false,
        "description": "Number of times to run each query for average timing",
        "default": 3
      },
      "warmup_runs": {
        "type": "integer",
        "required": false,
        "description": "Number of warmup executions before timing",
        "default": 1
      },
      "timeout_seconds": {
        "type": "integer",
        "required": false,
        "description": "Maximum execution time per query in seconds",
        "default": 300
      }
    },
    "error_messages": [
      "Database connection failed: Unable to connect to database with provided credentials.",
      "Query execution error: One or more queries failed to execute successfully.",
      "Benchmark timeout: Query execution exceeded the specified timeout limit.",
      "Invalid parameters: iterations and warmup_runs must be positive integers.",
      "Too many queries: Maximum 50 queries can be benchmarked in a single run.",
      "Insufficient permissions: User lacks permissions to execute benchmark queries."
    ],
    "usage": "Provide database connection details and benchmark_queries array. Set iterations higher for more accurate timing, warmup_runs to handle cold cache effects. Adjust timeout_seconds for long-running queries.",
    "output_details": {
      "benchmark_summary": {
        "type": "string",
        "description": "Summary of benchmark execution results"
      },
      "average_execution_times": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Average execution time in milliseconds for each query"
      },
      "min_execution_times": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Minimum execution time in milliseconds for each query"
      },
      "max_execution_times": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Maximum execution time in milliseconds for each query"
      },
      "total_benchmark_time": {
        "type": "number",
        "description": "Total time spent running all benchmarks in seconds"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Implementation Planner",
    "tool_description": "Creates a detailed implementation plan for deploying recommended indexes, considering database constraints, downtime requirements, and rollback strategies.",
    "parameters": {
      "approved_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "CREATE INDEX statements approved for implementation"
      },
      "database_engine": {
        "type": "string",
        "required": true,
        "description": "Target database engine: mysql, postgresql, oracle, sqlserver"
      },
      "maintenance_window_hours": {
        "type": "number",
        "required": false,
        "description": "Available maintenance window duration in hours",
        "default": 4.0
      },
      "allow_online_creation": {
        "type": "boolean",
        "required": false,
        "description": "Whether online index creation is allowed",
        "default": true
      },
      "priority_order": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Priority order for index implementation (table names)",
        "default": null
      }
    },
    "error_messages": [
      "Invalid index statements: One or more CREATE INDEX statements contain syntax errors.",
      "Unsupported database engine: Use one of mysql, postgresql, oracle, sqlserver.",
      "Maintenance window too short: Available time insufficient for all index creations.",
      "Priority order mismatch: priority_order contains tables not referenced in approved indexes.",
      "Online creation not supported: Database engine does not support online index creation for specified indexes."
    ],
    "usage": "Provide approved_indexes and database_engine. Set maintenance_window_hours based on available downtime. Use priority_order to control implementation sequence. Enable allow_online_creation when possible to minimize downtime.",
    "output_details": {
      "implementation_phases": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Ordered phases of index implementation"
      },
      "estimated_duration_hours": {
        "type": "number",
        "description": "Total estimated implementation time in hours"
      },
      "online_creation_possible": {
        "type": "array",
        "items": {"type": "boolean"},
        "description": "Whether each index can be created online"
      },
      "rollback_plan": {
        "type": "string",
        "description": "Detailed rollback strategy and commands"
      },
      "risk_assessment": {
        "type": "string
