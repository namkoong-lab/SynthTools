field_name: web_scraping
subfield: e-commerce price monitoring
task: Competitor price comparison and benchmarking
tool_description: |-
  ## STEP 1 — Rate task difficulty

  This task is **medium** difficulty. It involves multiple subproblems including web scraping across different e-commerce platforms, data extraction and parsing, price normalization, competitor identification, and trend analysis. The task has moderate ambiguity in handling diverse website structures and anti-bot measures, requires coordination between scraping, parsing, and analysis components, and has medium impact of errors on business decisions.

  ## STEP 2 — Set a tool budget

  Given the medium difficulty, I'll target **12 tools** to cover the various aspects of competitor price monitoring and benchmarking while maintaining composability and avoiding overlap.

  ## STEP 3 — List all tool names and dependencies

  **Tools and Dependencies:**
  1. **Product Search Scraper** - Consumes: search terms, site configs → Produces: raw product listings
  2. **Price Data Extractor** - Consumes: raw HTML/JSON → Produces: structured price data
  3. **Product Matcher** - Consumes: product listings from multiple sources → Produces: matched product groups
  4. **Price Validator** - Consumes: extracted prices → Produces: validated/cleaned price data
  5. **Competitor Site Mapper** - Consumes: domain/URL → Produces: site structure metadata
  6. **Price History Tracker** - Consumes: current prices, historical data → Produces: price trends
  7. **Benchmark Calculator** - Consumes: competitor prices → Produces: market position metrics
  8. **Alert Generator** - Consumes: price changes, thresholds → Produces: notifications
  9. **Report Synthesizer** - Consumes: analysis results → Produces: formatted reports
  10. **Proxy Rotator** - Consumes: request configs → Produces: proxy-enabled requests
  11. **Rate Limiter** - Consumes: request frequency rules → Produces: throttled execution
  12. **Data Aggregator** - Consumes: multiple data sources → Produces: consolidated datasets

  ## STEP 4 — Multi-tool plans

  **Simple Plans:**
  1. **Basic Price Check**: Product Search Scraper → Price Data Extractor → Price Validator (Quick competitor price lookup)
  2. **Site Mapping**: Competitor Site Mapper → Rate Limiter (Understand competitor site structure)

  **Medium Plans:**
  1. **Price Monitoring Setup**: Product Search Scraper → Price Data Extractor → Product Matcher → Price History Tracker (Establish monitoring for specific products)
  2. **Competitive Analysis**: Data Aggregator → Benchmark Calculator → Report Synthesizer (Analyze market position)

  **Complex Plans:**
  1. **Full Monitoring Pipeline**: Proxy Rotator → Rate Limiter → Product Search Scraper → Price Data Extractor → Product Matcher → Price Validator → Price History Tracker → Benchmark Calculator → Alert Generator (Complete monitoring workflow)
  2. **Multi-Source Intelligence**: Competitor Site Mapper → Proxy Rotator → Product Search Scraper → Price Data Extractor → Data Aggregator → Product Matcher → Benchmark Calculator → Report Synthesizer (Comprehensive competitor intelligence)

  ## STEP 5 — Produce tools

  ```json
  {
    "tool_name": "Product Search Scraper",
    "tool_description": "Scrapes e-commerce websites to find product listings based on search terms, handling pagination and different site structures.",
    "parameters": {
      "search_query": {
        "type": "string",
        "required": true,
        "description": "Product search term or keywords"
      },
      "target_sites": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "List of e-commerce site URLs to scrape",
        "minItems": 1,
        "maxItems": 20
      },
      "max_results_per_site": {
        "type": "integer",
        "required": false,
        "description": "Maximum number of products to retrieve per site",
        "default": 50
      },
      "include_out_of_stock": {
        "type": "boolean",
        "required": false,
        "description": "Whether to include out-of-stock products",
        "default": false
      }
    },
    "error_messages": [
      "Invalid search query: Search query cannot be empty or contain only whitespace.",
      "Unreachable target site: One or more target sites are not accessible or return errors.",
      "Rate limit exceeded: Too many requests to target site, implement delays between requests.",
      "Invalid max_results_per_site: Value must be between 1 and 1000."
    ],
    "usage": "Provide search_query and target_sites array. Optionally set max_results_per_site and include_out_of_stock. Returns raw product data from each site for further processing.",
    "output_details": {
      "total_products_found": {
        "type": "integer",
        "description": "Total number of products scraped across all sites"
      },
      "site_results": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Raw HTML or JSON data from each site"
      },
      "scrape_timestamp": {
        "type": "string",
        "description": "When the scraping was performed"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Price Data Extractor",
    "tool_description": "Extracts structured price information from raw HTML or JSON data using configurable selectors and parsing rules.",
    "parameters": {
      "raw_data": {
        "type": "string",
        "required": true,
        "description": "Raw HTML or JSON content to parse"
      },
      "site_domain": {
        "type": "string",
        "required": true,
        "description": "Domain of the source site for selector mapping"
      },
      "price_selectors": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "CSS selectors for price elements",
        "default": null
      },
      "product_selectors": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "CSS selectors for product name/title elements",
        "default": null
      },
      "currency_format": {
        "type": "string",
        "required": false,
        "description": "Expected currency format (USD, EUR, GBP, etc.)",
        "default": "USD"
      }
    },
    "error_messages": [
      "Invalid raw data: Raw data is empty or not in expected HTML/JSON format.",
      "Unknown site domain: No parsing rules available for the specified domain.",
      "Price extraction failed: Unable to find price elements using provided or default selectors.",
      "Invalid currency format: Currency format must be a valid 3-letter currency code.",
      "Malformed price data: Extracted price values cannot be parsed as valid numbers."
    ],
    "usage": "Provide raw_data from scraped content and site_domain. Optionally customize price_selectors, product_selectors, and currency_format. Returns structured price data ready for validation.",
    "output_details": {
      "extracted_products": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of extracted product names"
      },
      "extracted_prices": {
        "type": "array",
        "items": {"type": "number"},
        "description": "List of extracted price values"
      },
      "extraction_success_rate": {
        "type": "number",
        "description": "Percentage of successful extractions"
      },
      "currency": {
        "type": "string",
        "description": "Currency of extracted prices"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Product Matcher",
    "tool_description": "Matches similar products across different sources using name similarity, brand matching, and product attributes.",
    "parameters": {
      "product_datasets": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "JSON strings containing product data from different sources",
        "minItems": 2,
        "maxItems": 10
      },
      "similarity_threshold": {
        "type": "number",
        "required": false,
        "description": "Minimum similarity score for matching (0.0-1.0)",
        "default": 0.8
      },
      "match_algorithm": {
        "type": "string",
        "required": false,
        "description": "Matching algorithm: fuzzy, exact, or semantic",
        "default": "fuzzy"
      }
    },
    "error_messages": [
      "Insufficient datasets: At least 2 product datasets are required for matching.",
      "Invalid dataset format: Product datasets must be valid JSON strings with required fields.",
      "Invalid similarity threshold: Threshold must be between 0.0 and 1.0.",
      "Unknown match algorithm: Algorithm must be one of: fuzzy, exact, or semantic.",
      "No matches found: No product matches found with current threshold and algorithm settings."
    ],
    "usage": "Provide product_datasets array with JSON data from different sources. Adjust similarity_threshold and match_algorithm as needed. Returns groups of matched products for price comparison.",
    "output_details": {
      "matched_groups": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Groups of matched products across sources"
      },
      "total_matches": {
        "type": "integer",
        "description": "Total number of product matches found"
      },
      "unmatched_products": {
        "type": "integer",
        "description": "Number of products that couldn't be matched"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Price Validator",
    "tool_description": "Validates and cleans extracted price data by removing outliers, handling missing values, and normalizing formats.",
    "parameters": {
      "price_data": {
        "type": "array",
        "items": {"type": "number"},
        "required": true,
        "description": "Array of price values to validate",
        "minItems": 1
      },
      "outlier_method": {
        "type": "string",
        "required": false,
        "description": "Outlier detection method: iqr, zscore, or none",
        "default": "iqr"
      },
      "outlier_threshold": {
        "type": "number",
        "required": false,
        "description": "Threshold for outlier detection (method-specific)",
        "default": 2.5
      }
    },
    "error_messages": [
      "Empty price data: Price data array cannot be empty.",
      "Invalid price values: All price values must be positive numbers.",
      "Unknown outlier method: Method must be one of: iqr, zscore, or none.",
      "Invalid outlier threshold: Threshold must be a positive number.",
      "Insufficient valid data: Too few valid price points remaining after validation."
    ],
    "usage": "Provide price_data array with extracted prices. Configure outlier_method and outlier_threshold for data cleaning. Returns cleaned and validated price data.",
    "output_details": {
      "valid_prices": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Array of validated price values"
      },
      "outliers_removed": {
        "type": "integer",
        "description": "Number of outlier prices removed"
      },
      "validation_summary": {
        "type": "string",
        "description": "Summary of validation results and actions taken"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Competitor Site Mapper",
    "tool_description": "Analyzes competitor websites to understand their structure, identify key elements, and generate scraping configurations.",
    "parameters": {
      "site_url": {
        "type": "string",
        "required": true,
        "description": "URL of the competitor site to analyze"
      },
      "analysis_depth": {
        "type": "string",
        "required": false,
        "description": "Analysis depth: shallow, medium, or deep",
        "default": "medium"
      },
      "sample_product_urls": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Sample product page URLs for detailed analysis",
        "default": null,
        "maxItems": 10
      },
      "discover_pagination": {
        "type": "boolean",
        "required": false,
        "description": "Whether to analyze pagination structure",
        "default": true
      },
      "identify_anti_bot": {
        "type": "boolean",
        "required": false,
        "description": "Whether to identify anti-bot measures",
        "default": true
      }
    },
    "error_messages": [
      "Invalid site URL: URL is not accessible or returns error status.",
      "Unknown analysis depth: Depth must be one of: shallow, medium, or deep.",
      "Invalid sample URLs: One or more sample product URLs are not valid or accessible.",
      "Site analysis failed: Unable to analyze site structure due to blocking or errors.",
      "Robots.txt violation: Site prohibits automated access according to robots.txt."
    ],
    "usage": "Provide site_url to analyze. Optionally set analysis_depth, sample_product_urls, and boolean flags for pagination and anti-bot detection. Returns site structure metadata for scraping configuration.",
    "output_details": {
      "site_structure": {
        "type": "string",
        "description": "JSON string describing site navigation and structure"
      },
      "suggested_selectors": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Recommended CSS selectors for price and product data"
      },
      "anti_bot_measures": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Identified anti-bot protection mechanisms"
      },
      "pagination_info": {
        "type": "string",
        "description": "Information about site pagination structure"
      },
      "recommended_delays": {
        "type": "integer",
        "description": "Suggested delay between requests in milliseconds"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Price History Tracker",
    "tool_description": "Tracks price changes over time, calculates trends, and identifies significant price movements for products.",
    "parameters": {
      "product_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the product being tracked"
      },
      "current_prices": {
        "type": "array",
        "items": {"type": "number"},
        "required": true,
        "description": "Current price data from different sources",
        "minItems": 1
      },
      "price_sources": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Source identifiers corresponding to current prices",
        "minItems": 1
      },
      "historical_data": {
        "type": "string",
        "required": false,
        "description": "JSON string containing historical price data",
        "default": null
      },
      "trend_window_days": {
        "type": "integer",
        "required": false,
        "description": "Number of days to consider for trend calculation",
        "default": 30
      }
    },
    "error_messages": [
      "Invalid product ID: Product ID cannot be empty or contain special characters.",
      "Price-source mismatch: Number of current prices must match number of price sources.",
      "Invalid historical data: Historical data must be valid JSON format if provided.",
      "Insufficient price data: At least one current price value is required.",
      "Invalid trend window: Trend window must be between 1 and 365 days."
    ],
    "usage": "Provide product_id, current_prices, and corresponding price_sources. Optionally include historical_data and set trend_window_days. Returns trend analysis and price change detection.",
    "output_details": {
      "price_trends": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Trend analysis for each price source (increasing, decreasing, stable)"
      },
      "significant_changes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Notable price changes detected"
      },
      "average_price": {
        "type": "number",
        "description": "Current average price across all sources"
      },
      "price_volatility": {
        "type": "number",
        "description": "Price volatility score over the trend window"
      },
      "updated_timestamp": {
        "type": "string",
        "description": "When the price history was last updated"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Benchmark Calculator",
    "tool_description": "Calculates competitive benchmarks and market position metrics based on competitor pricing data.",
    "parameters": {
      "own_prices": {
        "type": "array",
        "items": {"type": "number"},
        "required": true,
        "description": "Your company's product prices",
        "minItems": 1
      },
      "competitor_prices": {
        "type": "array",
        "items": {"type": "number"},
        "required": true,
        "description": "Competitor product prices for comparison",
        "minItems": 1
      },
      "competitor_names": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Names of competitors corresponding to prices",
        "minItems": 1
      },
      "product_categories": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Product category labels for segmented analysis",
        "default": null
      },
      "benchmark_metrics": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Specific metrics to calculate: mean, median, percentile, gap_analysis",
        "default": ["mean", "median"]
      },
      "percentile_targets": {
        "type": "array",
        "items": {"type": "integer"},
        "required": false,
        "description": "Percentile values to calculate (0-100)",
        "default": [25, 50, 75, 90]
      }
    },
    "error_messages": [
      "Price array mismatch: Own prices, competitor prices, and competitor names must have compatible lengths.",
      "Invalid price values: All price values must be positive numbers.",
      "Unknown benchmark metric: Metrics must be from: mean, median, percentile, gap_analysis.",
      "Invalid percentile targets: Percentile values must be integers between 0 and 100.",
      "Insufficient competitor data: At least one competitor price is required for benchmarking."
    ],
    "usage": "Provide own_prices, competitor_prices, and competitor_names. Optionally specify product_categories, benchmark_metrics, and percentile_targets. Returns competitive position analysis and benchmarks.",
    "output_details": {
      "market_position": {
        "type": "string",
        "description": "Overall market position assessment (above/below/at market)"
      },
      "price_gaps": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Price differences compared to competitors"
      },
      "benchmark_values": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Calculated benchmark values for requested metrics"
      },
      "competitive_advantage": {
        "type": "string",
        "description": "Analysis of pricing competitive advantage"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Alert Generator",
    "tool_description": "Generates alerts and notifications when price changes exceed defined thresholds or trigger specific conditions.",
    "parameters": {
      "price_changes": {
        "type": "array",
        "items": {"type": "number"},
        "required": true,
        "description": "Array of price change percentages",
        "minItems": 1
      },
      "change_thresholds": {
        "type": "array",
        "items": {"type": "number"},
        "required": true,
        "description": "Threshold percentages for triggering alerts",
        "minItems": 1
      },
      "alert_types": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Types of alerts to generate: price_drop, price_increase, volatility, new_competitor",
        "default": ["price_drop", "price_increase"]
      },
      "priority_levels": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Priority levels corresponding to thresholds: low, medium, high, critical",
        "default": ["medium"]
      }
    },
    "error_messages": [
      "Threshold mismatch: Number of change thresholds must match number of priority levels if specified.",
      "Invalid alert type: Alert types must be from: price_drop, price_increase, volatility, new_competitor.",
      "Invalid priority level: Priority levels must be from: low, medium, high, critical.",
      "Invalid threshold values: Threshold values must be positive numbers.",
      "No price changes provided: At least one price change value is required."
    ],
    "usage": "Provide price_changes and change_thresholds arrays. Optionally specify alert_types and priority_levels. Returns generated alerts based on threshold conditions.",
    "output_details": {
      "triggered_alerts": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of triggered alert messages"
      },
      "alert_count": {
        "type": "integer",
        "description": "Total number of alerts generated"
      },
      "highest_priority": {
        "type": "string",
        "description": "Highest priority level among triggered alerts"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Report Synthesizer",
    "tool_description": "Synthesizes analysis results into comprehensive reports with visualizations and actionable insights.",
    "parameters": {
      "analysis_results": {
        "type": "string",
        "required": true,
        "description": "JSON string containing analysis data from other tools"
      },
      "report_format": {
        "type": "string",
        "required": false,
        "description": "Output format: summary, detailed, or executive",
        "default": "detailed"
      },
      "include_recommendations": {
        "type": "boolean",
        "required": false,
        "description": "Whether to include pricing recommendations",
        "default": true
      }
    },
    "error_messages": [
      "Invalid analysis data: Analysis results must be valid JSON format.",
      "Unknown report format: Format must be one of: summary, detailed, or executive.",
      "Insufficient data for report: Analysis results do not contain enough data for report generation.",
      "Report generation failed: Unable to process analysis data into requested format."
    ],
    "usage": "Provide analysis_results as JSON string from previous analysis steps. Set report_format and include_recommendations as needed. Returns formatted report with insights and recommendations.",
    "output_details": {
      "report_content": {
        "type": "string",
        "description": "Generated report content in requested format"
      },
      "key_insights": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Key insights extracted from analysis"
      },
      "recommendations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Actionable pricing recommendations"
      },
      "report_timestamp": {
        "type": "string",
        "description": "When the report was generated"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Proxy Rotator",
    "tool_description": "Manages proxy rotation and request routing to avoid IP blocking and distribute load across multiple proxy servers.",
    "parameters": {
      "proxy_list": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "List of proxy server addresses in host:port format",
        "minItems": 1,
        "maxItems": 100
      },
      "rotation_strategy": {
        "type": "string",
        "required": false,
        "description": "Rotation strategy: round_robin, random, or weighted",
        "default": "round_robin"
      },
      "health_check": {
        "type": "boolean",
        "required": false,
        "description": "Whether to perform proxy health checks",
        "default": true
      }
    },
    "error_messages": [
      "Invalid proxy format: Proxy addresses must be in host:port format.",
      "No working proxies: All proxies failed health check or are unreachable.",
      "Unknown rotation strategy: Strategy must be one of: round_robin, random, or weighted.",
      "Proxy connection failed: Unable to establish connection through selected proxy.",
      "Empty proxy list: At least one proxy address is required."
    ],
    "usage": "Provide proxy_list with valid proxy addresses. Configure rotation_strategy and enable health_check as needed. Returns proxy configuration for use in scraping requests.",
    "output_details": {
      "active_proxies": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of active, working proxy addresses"
      },
      "current_proxy": {
        "type": "string",
        "description": "Currently selected proxy for next request"
      },
      "proxy_status": {
        "type": "string",
        "description": "Overall proxy pool health status"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Rate Limiter",
    "tool_description": "Controls request frequency and timing to comply with rate limits and avoid overwhelming target servers.",
    "parameters": {
      "requests_per_minute": {
        "type": "integer",
        "required": true,
        "description": "Maximum number of requests allowed per minute"
      },
      "burst_limit": {
        "type": "integer",
        "required": false,
        "description": "Maximum requests allowed in a single burst",
        "default": 5
      }
    },
    "error_messages": [
      "Invalid rate limit: Requests per minute must be a positive integer.",
      "Invalid burst limit: Burst limit must be a positive integer and <= requests per minute.",
      "Rate limit exceeded: Current request rate exceeds configured limits."
    ],
    "usage": "Set requests_per_minute based on target site limitations. Optionally configure burst_limit for handling request spikes. Returns timing information for request scheduling.",
    "output_details": {
      "next_request_time": {
        "type": "string",
        "description": "Timestamp when next request can be made"
      },
      "current_rate": {
        "type": "number",
        "description": "Current requests per minute rate"
      },
      "delay_seconds": {
        "type": "integer",
        "description": "Recommended delay before next request in seconds"
      }
    }
  }
  ```
