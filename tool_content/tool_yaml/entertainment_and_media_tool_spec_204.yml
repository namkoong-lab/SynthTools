field_name: entertainment_and_media
subfield: video_streaming_platforms
task: Content discovery and recommendation based on user preferences and viewing history
tool_description: |-
  **STEP 1 — Rate task difficulty**

  This task has medium difficulty. It involves multiple interconnected subproblems including user preference analysis, content metadata processing, recommendation algorithm implementation, and personalization. While the core concepts are well-established, the task requires coordination between user data analysis, content filtering, similarity computation, and real-time recommendation generation with moderate data infrastructure requirements.

  **STEP 2 — Set a tool budget**

  Given the medium difficulty, I'll target 12 tools to cover the various aspects of content discovery and recommendation systems, from user data processing to recommendation generation and evaluation.

  **STEP 3 — List all tool names with dependencies and affordances**

  1. **User Profile Analyzer** - Consumes: user viewing history → Produces: preference profiles
  2. **Content Metadata Extractor** - Consumes: content identifiers → Produces: structured content attributes
  3. **Viewing Pattern Detector** - Consumes: user activity logs → Produces: behavioral patterns
  4. **Content Similarity Calculator** - Consumes: content metadata → Produces: similarity scores
  5. **Genre Preference Scorer** - Consumes: user history, content genres → Produces: genre affinity scores
  6. **Collaborative Filter Engine** - Consumes: user-item interactions → Produces: user similarity recommendations
  7. **Content Based Recommender** - Consumes: user preferences, content features → Produces: content-based recommendations
  8. **Trending Content Detector** - Consumes: platform activity data → Produces: trending content lists
  9. **Recommendation Ranker** - Consumes: multiple recommendation sources → Produces: ranked recommendation list
  10. **User Feedback Processor** - Consumes: user ratings/interactions → Produces: feedback-adjusted preferences
  11. **Recommendation Evaluator** - Consumes: recommendations, user actions → Produces: performance metrics
  12. **Content Filter Manager** - Consumes: user constraints, content metadata → Produces: filtered content pools

  **STEP 4 — Multi-tool plans**

  **Simple Plans:**
  - Basic content discovery: Content Metadata Extractor → Content Based Recommender → Recommendation Ranker
  - Trending recommendations: Trending Content Detector → Content Filter Manager → Recommendation Ranker

  **Medium Plans:**
  - Preference-based discovery: User Profile Analyzer → Genre Preference Scorer → Content Based Recommender → Recommendation Ranker → Recommendation Evaluator
  - Hybrid recommendations: Collaborative Filter Engine + Content Based Recommender → Recommendation Ranker → User Feedback Processor

  **Complex Plans:**
  - Full recommendation pipeline: User Profile Analyzer → Viewing Pattern Detector → Content Similarity Calculator + Collaborative Filter Engine → Content Based Recommender → Trending Content Detector → Recommendation Ranker → Content Filter Manager → Recommendation Evaluator → User Feedback Processor
  - Advanced personalization: User Profile Analyzer → Genre Preference Scorer → Viewing Pattern Detector → Content Similarity Calculator → Collaborative Filter Engine + Content Based Recommender + Trending Content Detector → Recommendation Ranker → Content Filter Manager → User Feedback Processor → Recommendation Evaluator

  **STEP 5 — Produce tools**

  ```json
  {
    "tool_name": "User Profile Analyzer",
    "tool_description": "Analyzes user viewing history and interactions to extract preference profiles including genre preferences, content type affinity, and viewing behavior patterns.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the user"
      },
      "viewing_history": {
        "type": "array",
        "required": true,
        "description": "List of content IDs the user has watched",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 1000
      },
      "interaction_scores": {
        "type": "array",
        "required": true,
        "description": "User interaction scores (0-10) corresponding to viewing_history",
        "items": {"type": "number"},
        "minItems": 1,
        "maxItems": 1000
      },
      "time_window_days": {
        "type": "integer",
        "required": false,
        "description": "Number of days to consider for analysis (1-365)",
        "default": 30
      }
    },
    "error_messages": [
      "Mismatched array lengths: viewing_history and interaction_scores must have the same length.",
      "Invalid user_id: User ID cannot be empty or contain special characters.",
      "Invalid time_window_days: Must be between 1 and 365 days.",
      "Invalid interaction_scores: All scores must be between 0 and 10."
    ],
    "usage": "Provide user_id, viewing_history array, and corresponding interaction_scores array. Optionally specify time_window_days for analysis period. Returns comprehensive user preference profile.",
    "output_details": {
      "user_id": {
        "type": "string",
        "description": "The analyzed user identifier"
      },
      "top_genres": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Top 5 preferred genres based on viewing history"
      },
      "content_type_preferences": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Preferred content types (movie, series, documentary, etc.)"
      },
      "average_rating": {
        "type": "number",
        "description": "User's average interaction score"
      },
      "profile_confidence": {
        "type": "number",
        "description": "Confidence score (0-1) in the generated profile"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Content Metadata Extractor",
    "tool_description": "Extracts and structures metadata from content items including genre, cast, director, release year, duration, and other relevant attributes for recommendation processing.",
    "parameters": {
      "content_ids": {
        "type": "array",
        "required": true,
        "description": "List of content identifiers to extract metadata for",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 100
      },
      "metadata_fields": {
        "type": "array",
        "required": false,
        "description": "Specific metadata fields to extract",
        "items": {"type": "string"},
        "default": ["genre", "cast", "director", "release_year", "duration"]
      }
    },
    "error_messages": [
      "Invalid content_ids: Content IDs cannot be empty or contain special characters.",
      "Content not found: One or more content IDs do not exist in the database.",
      "Invalid metadata_fields: Unknown metadata field specified. Use valid fields like genre, cast, director, release_year, duration, rating, language."
    ],
    "usage": "Provide an array of content_ids to extract metadata for. Optionally specify which metadata_fields to retrieve. Returns structured metadata for each content item.",
    "output_details": {
      "extracted_metadata": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Array of JSON strings containing metadata for each content item"
      },
      "extraction_count": {
        "type": "integer",
        "description": "Number of content items successfully processed"
      },
      "failed_extractions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Content IDs that failed metadata extraction"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Viewing Pattern Detector",
    "tool_description": "Analyzes user viewing activity logs to detect patterns such as binge-watching behavior, preferred viewing times, session duration preferences, and content completion rates.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "User identifier for pattern analysis"
      },
      "activity_log": {
        "type": "array",
        "required": true,
        "description": "Timestamped viewing activities",
        "items": {"type": "string"},
        "minItems": 10,
        "maxItems": 5000
      },
      "content_durations": {
        "type": "array",
        "required": true,
        "description": "Duration in minutes for each content item",
        "items": {"type": "integer"},
        "minItems": 10,
        "maxItems": 5000
      },
      "watch_times": {
        "type": "array",
        "required": true,
        "description": "Actual watch time in minutes for each session",
        "items": {"type": "integer"},
        "minItems": 10,
        "maxItems": 5000
      },
      "analysis_depth": {
        "type": "string",
        "required": false,
        "description": "Analysis depth: basic, detailed, or comprehensive",
        "default": "detailed"
      }
    },
    "error_messages": [
      "Array length mismatch: activity_log, content_durations, and watch_times must have equal lengths.",
      "Invalid user_id: User ID cannot be empty.",
      "Invalid analysis_depth: Must be one of [basic, detailed, comprehensive].",
      "Insufficient data: Minimum 10 viewing sessions required for pattern detection.",
      "Invalid duration values: content_durations and watch_times must be positive integers."
    ],
    "usage": "Provide user_id and parallel arrays of activity_log, content_durations, and watch_times. Set analysis_depth for detail level. Returns detected viewing patterns and behavioral insights.",
    "output_details": {
      "binge_tendency": {
        "type": "number",
        "description": "Binge-watching score from 0-1"
      },
      "preferred_session_length": {
        "type": "integer",
        "description": "Average preferred viewing session in minutes"
      },
      "completion_rate": {
        "type": "number",
        "description": "Average content completion rate (0-1)"
      },
      "peak_viewing_hours": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Most active viewing hours (0-23)"
      },
      "viewing_consistency": {
        "type": "string",
        "description": "Pattern consistency rating: low, medium, high"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Content Similarity Calculator",
    "tool_description": "Calculates similarity scores between content items based on metadata features using various similarity metrics to support content-based recommendations.",
    "parameters": {
      "target_content_id": {
        "type": "string",
        "required": true,
        "description": "Primary content item to find similarities for"
      },
      "comparison_content_ids": {
        "type": "array",
        "required": true,
        "description": "Content items to compare against the target",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 500
      },
      "similarity_method": {
        "type": "string",
        "required": false,
        "description": "Similarity calculation method: cosine, jaccard, or hybrid",
        "default": "hybrid"
      },
      "weight_factors": {
        "type": "array",
        "required": false,
        "description": "Weight values for different metadata features",
        "items": {"type": "number"},
        "default": [0.3, 0.2, 0.2, 0.1, 0.2]
      }
    },
    "error_messages": [
      "Invalid target_content_id: Target content ID cannot be empty or invalid.",
      "Content not found: Target content or one or more comparison content items not found.",
      "Invalid similarity_method: Must be one of [cosine, jaccard, hybrid].",
      "Invalid weight_factors: All weights must be positive numbers and sum to 1.0.",
      "Insufficient metadata: Content items lack required metadata for similarity calculation."
    ],
    "usage": "Provide target_content_id and array of comparison_content_ids. Optionally specify similarity_method and weight_factors for different features. Returns similarity scores for all comparisons.",
    "output_details": {
      "target_content_id": {
        "type": "string",
        "description": "The content item used as similarity reference"
      },
      "similarity_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Similarity scores (0-1) for each comparison content item"
      },
      "ranked_similar_content": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Content IDs ranked by similarity score (highest first)"
      },
      "calculation_method": {
        "type": "string",
        "description": "Similarity method used for calculation"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Genre Preference Scorer",
    "tool_description": "Calculates user affinity scores for different content genres based on viewing history and interaction patterns, supporting genre-based content filtering and recommendations.",
    "parameters": {
      "user_viewing_history": {
        "type": "array",
        "required": true,
        "description": "Content IDs from user viewing history",
        "items": {"type": "string"},
        "minItems": 5,
        "maxItems": 1000
      },
      "content_genres": {
        "type": "array",
        "required": true,
        "description": "Genre classifications for each content item",
        "items": {"type": "string"},
        "minItems": 5,
        "maxItems": 1000
      },
      "user_ratings": {
        "type": "array",
        "required": true,
        "description": "User rating scores (1-10) for viewed content",
        "items": {"type": "number"},
        "minItems": 5,
        "maxItems": 1000
      },
      "recency_weight": {
        "type": "number",
        "required": false,
        "description": "Weight factor for recent viewing preferences (0-1)",
        "default": 0.7
      },
      "minimum_genre_exposure": {
        "type": "integer",
        "required": false,
        "description": "Minimum content count per genre for scoring",
        "default": 3
      }
    },
    "error_messages": [
      "Array length mismatch: user_viewing_history, content_genres, and user_ratings must have equal lengths.",
      "Invalid recency_weight: Must be between 0 and 1.",
      "Invalid user_ratings: All ratings must be between 1 and 10.",
      "Invalid minimum_genre_exposure: Must be a positive integer between 1 and 20.",
      "Insufficient genre data: Not enough content per genre to calculate reliable scores."
    ],
    "usage": "Provide parallel arrays of user_viewing_history, content_genres, and user_ratings. Adjust recency_weight and minimum_genre_exposure as needed. Returns genre preference scores and recommendations.",
    "output_details": {
      "genre_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Preference scores (0-10) for each identified genre"
      },
      "genre_names": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Genre names corresponding to the scores"
      },
      "top_preferred_genres": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Top 5 preferred genres ranked by score"
      },
      "genre_diversity_score": {
        "type": "number",
        "description": "User's genre diversity preference (0-1)"
      },
      "scoring_confidence": {
        "type": "number",
        "description": "Confidence level (0-1) in the calculated scores"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Collaborative Filter Engine",
    "tool_description": "Generates recommendations using collaborative filtering by identifying users with similar preferences and suggesting content liked by similar users.",
    "parameters": {
      "target_user_id": {
        "type": "string",
        "required": true,
        "description": "User ID to generate recommendations for"
      },
      "user_item_matrix": {
        "type": "array",
        "required": true,
        "description": "User-item interaction matrix as flat array",
        "items": {"type": "number"},
        "minItems": 100,
        "maxItems": 10000
      },
      "matrix_dimensions": {
        "type": "array",
        "required": true,
        "description": "Dimensions of the user-item matrix [users, items]",
        "items": {"type": "integer"},
        "minItems": 2,
        "maxItems": 2
      },
      "similarity_threshold": {
        "type": "number",
        "required": false,
        "description": "Minimum similarity score to consider users as similar (0-1)",
        "default": 0.3
      },
      "max_similar_users": {
        "type": "integer",
        "required": false,
        "description": "Maximum number of similar users to consider",
        "default": 50
      },
      "recommendation_count": {
        "type": "integer",
        "required": false,
        "description": "Number of recommendations to generate",
        "default": 20
      }
    },
    "error_messages": [
      "Invalid target_user_id: User ID cannot be empty or not found in the matrix.",
      "Matrix dimension mismatch: user_item_matrix size must match matrix_dimensions[0] × matrix_dimensions[1].",
      "Invalid similarity_threshold: Must be between 0 and 1.",
      "Invalid max_similar_users: Must be between 1 and 500.",
      "Invalid recommendation_count: Must be between 1 and 100.",
      "Insufficient data: Not enough user interactions for collaborative filtering."
    ],
    "usage": "Provide target_user_id, user_item_matrix as flat array, and matrix_dimensions. Adjust similarity_threshold, max_similar_users, and recommendation_count as needed. Returns collaborative filtering recommendations.",
    "output_details": {
      "recommended_items": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Content IDs recommended by collaborative filtering"
      },
      "recommendation_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Confidence scores (0-1) for each recommendation"
      },
      "similar_users_count": {
        "type": "integer",
        "description": "Number of similar users used for recommendations"
      },
      "algorithm_confidence": {
        "type": "number",
        "description": "Overall confidence (0-1) in the recommendations"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Content Based Recommender",
    "tool_description": "Generates content-based recommendations by matching user preferences with content features and attributes using similarity scoring.",
    "parameters": {
      "user_preferences": {
        "type": "array",
        "required": true,
        "description": "User preference vector for different content features",
        "items": {"type": "number"},
        "minItems": 5,
        "maxItems": 50
      },
      "content_feature_vectors": {
        "type": "array",
        "required": true,
        "description": "Feature vectors for available content items",
        "items": {"type": "number"},
        "minItems": 50,
        "maxItems": 5000
      },
      "content_ids": {
        "type": "array",
        "required": true,
        "description": "Content identifiers corresponding to feature vectors",
        "items": {"type": "string"},
        "minItems": 10,
        "maxItems": 1000
      },
      "recommendation_count": {
        "type": "integer",
        "required": false,
        "description": "Number of recommendations to return",
        "default": 20
      },
      "diversity_factor": {
        "type": "number",
        "required": false,
        "description": "Factor to promote diversity in recommendations (0-1)",
        "default": 0.3
      }
    },
    "error_messages": [
      "Vector dimension mismatch: All content feature vectors must have the same length as user_preferences.",
      "Array length mismatch: content_feature_vectors length must be divisible by content_ids length.",
      "Invalid recommendation_count: Must be between 1 and 100.",
      "Invalid diversity_factor: Must be between 0 and 1.",
      "Empty content pool: No valid content items available for recommendation."
    ],
    "usage": "Provide user_preferences vector, content_feature_vectors array, and corresponding content_ids. Adjust recommendation_count and diversity_factor as needed. Returns content-based recommendations.",
    "output_details": {
      "recommended_content": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Content IDs recommended based on user preferences"
      },
      "similarity_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Similarity scores (0-1) between user preferences and recommended content"
      },
      "diversity_score": {
        "type": "number",
        "description": "Diversity measure (0-1) of the recommendation set"
      },
      "recommendation_quality": {
        "type": "string",
        "description": "Quality assessment: low, medium, high"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Trending Content Detector",
    "tool_description": "Identifies trending content based on platform activity metrics including view counts, user engagement, and velocity of popularity growth.",
    "parameters": {
      "platform_activity_data": {
        "type": "array",
        "required": true,
        "description": "Activity metrics for content items over time",
        "items": {"type": "string"},
        "minItems": 50,
        "maxItems": 10000
      },
      "time_window_hours": {
        "type": "integer",
        "required": false,
        "description": "Time window for trend detection (1-168 hours)",
        "default": 24
      },
      "trending_threshold": {
        "type": "number",
        "required": false,
        "description": "Minimum activity increase rate to consider trending",
        "default": 1.5
      }
    },
    "error_messages": [
      "Invalid platform_activity_data: Activity data must contain valid content metrics.",
      "Invalid time_window_hours: Must be between 1 and 168 hours (1 week).",
      "Invalid trending_threshold: Must be greater than 1.0.",
      "Insufficient activity data: Not enough data points to detect trending patterns."
    ],
    "usage": "Provide platform_activity_data array with content metrics. Set time_window_hours for trend detection period and trending_threshold for sensitivity. Returns trending content list.",
    "output_details": {
      "trending_content_ids": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Content IDs identified as currently trending"
      },
      "trend_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Trending intensity scores for each identified content"
      },
      "trend_categories": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Trend categories: viral, rising, steady, or declining"
      },
      "detection_timestamp": {
        "type": "string",
        "description": "Timestamp when trend detection was performed",
        "format": "date-time"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Recommendation Ranker",
    "tool_description": "Ranks and combines recommendations from multiple sources using configurable weighting schemes and ranking algorithms to produce final recommendation lists.",
    "parameters": {
      "collaborative_recommendations": {
        "type": "array",
        "required": false,
        "description": "Content IDs from collaborative filtering",
        "items": {"type": "string"},
        "default": null
      },
      "content_based_recommendations": {
        "type": "array",
        "required": false,
        "description": "Content IDs from content-based filtering",
        "items": {"type": "string"},
        "default": null
      },
      "trending_recommendations": {
        "type": "array",
        "required": false,
        "description": "Content IDs from trending content",
        "items": {"type": "string"},
        "default": null
      },
      "collaborative_scores": {
        "type": "array",
        "required": false,
        "description": "Scores for collaborative recommendations",
        "items": {"type": "number"},
        "default": null
      },
      "content_based_scores": {
        "type": "array",
        "required": false,
        "description": "Scores for content-based recommendations",
        "items": {"type": "number"},
        "default": null
      },
      "trending_scores": {
        "type": "array",
        "required": false,
        "description": "Scores for trending recommendations",
        "items": {"type": "number"},
        "default": null
      },
      "weight_collaborative": {
        "type": "number",
        "required": false,
        "description": "Weight for collaborative filtering (0-1)",
        "default": 0.4
      },
      "weight_content_based": {
        "type": "number",
        "required": false,
        "description": "Weight for content-based filtering (0-1)",
        "default": 0.4
      },
      "weight_trending": {
        "type": "number",
        "required": false,
        "description": "Weight for trending content (0-1)",
        "default": 0.2
      },
      "final_recommendation_count": {
        "type": "integer",
        "required": false,
        "description": "Number of final recommendations to return",
        "default": 20
      },
      "diversity_enforcement": {
        "type": "boolean",
        "required": false,
        "description": "Whether to enforce diversity in final rankings",
        "default": true
      },
      "ranking_method": {
        "type": "string",
        "required": false,
        "description": "Ranking algorithm: weighted_sum, rrf, or hybrid",
        "default": "weighted_sum"
      }
    },
    "error_messages": [
      "Weight sum error: weight_collaborative + weight_content_based + weight_trending must equal 1.0.",
      "Score-recommendation mismatch: Each recommendation array must have corresponding scores array of same length.",
      "Invalid ranking_method: Must be one of [weighted_sum, rrf, hybrid].",
      "Invalid final_recommendation_count: Must be between 1 and 100.",
      "No recommendations provided: At least one recommendation source must be provided."
    ],
    "usage": "Provide recommendation arrays and corresponding score arrays from different sources. Configure weights for each source and set ranking_method. Returns unified, ranked recommendation list.",
    "output_details": {
      "final_recommendations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Final ranked list of recommended content IDs"
      },
      "final_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Combined scores for each final recommendation"
      },
      "source_distribution": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Source origin for each recommendation (collaborative/content_based/trending)"
      },
      "ranking_quality": {
        "type": "number",
        "description": "Quality score (0-1) of the ranking process"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "User Feedback Processor",
    "tool_description": "Processes user feedback on recommendations including ratings, clicks, and implicit feedback to update user preferences and improve future recommendations.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "User identifier for feedback processing"
      },
      "feedback_content_ids": {
        "type": "array",
        "required": true,
        "description": "Content IDs that received user feedback",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 100
      },
      "explicit_ratings": {
        "type": "array",
        "required": false,
        "description": "User ratings (1-10) for content items",
        "items": {"type": "number"},
        "default": null
      },
      "implicit_signals": {
        "type": "array",
        "required": false,
        "description": "Implicit feedback signals: clicked, watched, shared, skipped",
        "items": {"type": "string"},
        "default": null
      },
      "feedback_timestamps": {
        "type": "array",
        "required": true,
        "description": "Timestamps for each feedback event",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 100
      },
      "learning_rate": {
        "type": "number",
        "required": false,
        "description": "Rate of preference update (0-1)",
        "default": 0.1
      }
    },
    "error_messages": [
      "Array length mismatch: feedback_content_ids and feedback_timestamps must have equal lengths.",
      "Invalid explicit_ratings: Ratings must be between 1 and 10.",
      "Invalid implicit_signals: Must be one of [clicked, watched, shared, skipped, ignored].",
      "Invalid learning_rate: Must be between 0 and 1.",
      "Invalid timestamp format: All timestamps must be in ISO 8601 format.",
      "Missing feedback data: Either explicit_ratings or implicit_signals must be provided."
    ],
    "usage": "Provide user_id, feedback_content_ids, and feedback_timestamps. Include either explicit_ratings or implicit_signals (or both). Adjust learning_rate for preference update sensitivity.",
    "output_details": {
      "updated_preferences": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Updated user preference vector after feedback processing"
      },
      "preference_changes": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Magnitude of changes in preference dimensions"
      },
      "feedback_quality": {
        "type": "string",
        "description": "Quality of feedback data: low, medium, high"
      },
      "processing_status": {
        "type": "string",
        "description": "Status of feedback processing: success, partial, failed"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Recommendation Evaluator",
    "tool_description": "Evaluates recommendation system performance using metrics like precision, recall, diversity, and user satisfaction based on actual user interactions.",
    "parameters": {
      "recommended_items": {
        "type": "array",
        "required": true,
        "description": "Content IDs that were recommended to users",
        "items": {"type": "string"},
        "minItems": 10,
        "maxItems": 1000
      },
      "user_interactions": {
        "type": "array",
        "required": true,
        "description": "Actual user interactions with recommended content",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 1000
      },
