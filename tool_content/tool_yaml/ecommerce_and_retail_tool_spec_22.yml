field_name: ecommerce_and_retail
subfield: Product Catalog Management
task: Multi-Channel Product Distribution and Syndication
tool_description: |-
  ## STEP 1 — Rate task difficulty

  This task involves coordinating product data across multiple sales channels, handling format transformations, managing inventory synchronization, and ensuring data consistency across platforms. The complexity arises from dealing with different channel requirements, API integrations, real-time updates, and potential conflicts between channels. I rate this as **hard** due to the high coordination requirements, multiple dependencies, significant error impact on sales, and complex data infrastructure needs.

  ## STEP 2 — Set a tool budget

  Given the hard difficulty rating, I'm targeting **17 tools** within the 15–20 range. This allows for comprehensive coverage of channel management, data transformation, synchronization, validation, and monitoring workflows while maintaining tool composability.

  ## STEP 3 — List all tool names and dependencies

  1. **Channel Configuration Manager** - Consumes: channel specs, auth credentials → Produces: validated channel configs
  2. **Product Data Validator** - Consumes: raw product data → Produces: validation reports, cleaned data
  3. **Channel Mapping Generator** - Consumes: product schema, channel requirements → Produces: field mappings
  4. **Data Format Transformer** - Consumes: product data, mappings → Produces: channel-specific formatted data
  5. **Inventory Sync Coordinator** - Consumes: inventory levels, channel configs → Produces: sync status, updates
  6. **Channel Feed Builder** - Consumes: transformed data → Produces: channel-specific feeds
  7. **Multi-Channel Publisher** - Consumes: feeds, channel configs → Produces: publication status
  8. **Conflict Resolution Engine** - Consumes: conflicting data sources → Produces: resolved data, decisions
  9. **Price Strategy Applicator** - Consumes: base prices, channel rules → Produces: channel-specific pricing
  10. **Content Enrichment Processor** - Consumes: basic product info → Produces: enhanced content
  11. **Category Mapping Resolver** - Consumes: internal categories, channel taxonomies → Produces: category mappings
  12. **Sync Status Monitor** - Consumes: channel activities → Produces: status reports, alerts
  13. **Performance Analytics Generator** - Consumes: channel metrics → Produces: performance insights
  14. **Bulk Operation Manager** - Consumes: operation requests → Produces: batch processing results
  15. **Channel Health Checker** - Consumes: channel endpoints → Produces: health reports
  16. **Data Quality Auditor** - Consumes: published data → Produces: quality assessments
  17. **Rollback Coordinator** - Consumes: error states → Produces: restoration status

  ## STEP 4 — Multi-tool plans

  **Simple plans:**
  - **Basic channel setup**: Channel Configuration Manager → Channel Health Checker → Channel Mapping Generator
  - **Data validation workflow**: Product Data Validator → Data Quality Auditor

  **Medium plans:**
  - **Single channel publication**: Product Data Validator → Data Format Transformer → Channel Feed Builder → Multi-Channel Publisher → Sync Status Monitor
  - **Pricing synchronization**: Price Strategy Applicator → Data Format Transformer → Multi-Channel Publisher → Performance Analytics Generator

  **Complex plans:**
  - **Full multi-channel deployment**: Product Data Validator → Content Enrichment Processor → Category Mapping Resolver → Channel Mapping Generator → Price Strategy Applicator → Data Format Transformer → Channel Feed Builder → Multi-Channel Publisher → Inventory Sync Coordinator → Sync Status Monitor → Performance Analytics Generator
  - **Conflict resolution and recovery**: Sync Status Monitor → Conflict Resolution Engine → Data Format Transformer → Multi-Channel Publisher → Data Quality Auditor → Rollback Coordinator (if issues found)

  ## STEP 5 — Produce tools

  ```json
  {
    "tool_name": "Channel Configuration Manager",
    "tool_description": "Manages and validates configuration settings for multiple sales channels, including authentication, API endpoints, and channel-specific requirements.",
    "parameters": {
      "channel_name": {
        "type": "string",
        "required": true,
        "description": "Name of the sales channel (e.g., Amazon, eBay, Shopify)"
      },
      "api_endpoint": {
        "type": "string",
        "required": true,
        "description": "Base API URL for the channel"
      },
      "auth_type": {
        "type": "string",
        "required": true,
        "description": "Authentication method: oauth, api_key, basic_auth, or token"
      },
      "credentials": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Authentication credentials in order [key, secret, additional_params]",
        "minItems": 1,
        "maxItems": 5
      },
      "rate_limit": {
        "type": "integer",
        "required": false,
        "description": "API rate limit per minute",
        "default": 100
      }
    },
    "error_messages": [
      "Invalid channel name: Channel name must be a non-empty string with no special characters except hyphens and underscores.",
      "Invalid API endpoint: Provide a valid HTTP/HTTPS URL.",
      "Unsupported auth type: Use oauth, api_key, basic_auth, or token.",
      "Insufficient credentials: Provide at least one credential value.",
      "Rate limit validation failed: Rate limit must be a positive integer between 1 and 10000."
    ],
    "usage": "Provide channel_name, api_endpoint, auth_type, and credentials array. Optionally set rate_limit. The tool validates the configuration and returns setup status.",
    "output_details": {
      "config_id": {
        "type": "string",
        "description": "Unique identifier for the channel configuration"
      },
      "validation_status": {
        "type": "string",
        "description": "Configuration validation result: valid, invalid, or warning"
      },
      "setup_timestamp": {
        "type": "string",
        "description": "When the configuration was created"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Product Data Validator",
    "tool_description": "Validates product data against schema requirements and business rules, identifying missing fields, format issues, and data quality problems.",
    "parameters": {
      "product_data": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Product data entries in JSON string format",
        "minItems": 1,
        "maxItems": 1000
      },
      "validation_schema": {
        "type": "string",
        "required": true,
        "description": "Schema definition for validation (JSON schema format)"
      },
      "strict_mode": {
        "type": "boolean",
        "required": false,
        "description": "Whether to apply strict validation rules",
        "default": false
      }
    },
    "error_messages": [
      "Invalid product data format: Product data must be valid JSON strings.",
      "Schema parsing error: Provide a valid JSON schema for validation.",
      "Empty product data: At least one product entry is required.",
      "Data size limit exceeded: Maximum 1000 product entries per validation batch."
    ],
    "usage": "Provide product_data array and validation_schema. Set strict_mode to true for rigorous validation. Returns validation results and cleaned data.",
    "output_details": {
      "valid_products": {
        "type": "integer",
        "description": "Number of products that passed validation"
      },
      "invalid_products": {
        "type": "integer",
        "description": "Number of products that failed validation"
      },
      "error_details": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Detailed error messages for failed validations"
      },
      "cleaned_data": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Validated and cleaned product data entries"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Channel Mapping Generator",
    "tool_description": "Creates field mappings between internal product schema and channel-specific requirements, handling field transformations and custom mappings.",
    "parameters": {
      "source_schema": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Source schema field names",
        "minItems": 1,
        "maxItems": 100
      },
      "target_channel": {
        "type": "string",
        "required": true,
        "description": "Target channel identifier"
      },
      "custom_mappings": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Custom field mappings in 'source_field:target_field' format",
        "default": []
      },
      "mapping_mode": {
        "type": "string",
        "required": false,
        "description": "Mapping strategy: auto, manual, or hybrid",
        "default": "auto"
      }
    },
    "error_messages": [
      "Invalid source schema: Provide at least one valid field name.",
      "Unknown target channel: Channel not recognized in the system.",
      "Invalid custom mapping format: Use 'source_field:target_field' format.",
      "Mapping mode not supported: Use auto, manual, or hybrid.",
      "Schema field limit exceeded: Maximum 100 fields supported per mapping."
    ],
    "usage": "Provide source_schema fields and target_channel. Optionally include custom_mappings and set mapping_mode. Returns comprehensive field mappings for data transformation.",
    "output_details": {
      "mapping_id": {
        "type": "string",
        "description": "Unique identifier for the generated mapping"
      },
      "field_mappings": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Generated field mappings in 'source:target' format"
      },
      "unmapped_fields": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Source fields that couldn't be mapped automatically"
      },
      "mapping_confidence": {
        "type": "number",
        "description": "Confidence score for the generated mappings (0-1)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Data Format Transformer",
    "tool_description": "Transforms product data from internal format to channel-specific formats using predefined mappings and transformation rules.",
    "parameters": {
      "product_data": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Source product data in JSON string format",
        "minItems": 1,
        "maxItems": 500
      },
      "mapping_id": {
        "type": "string",
        "required": true,
        "description": "Mapping configuration identifier"
      },
      "target_format": {
        "type": "string",
        "required": true,
        "description": "Output format: json, xml, csv, or channel_specific"
      },
      "transformation_rules": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Additional transformation rules to apply",
        "default": []
      },
      "include_metadata": {
        "type": "boolean",
        "required": false,
        "description": "Whether to include transformation metadata",
        "default": false
      }
    },
    "error_messages": [
      "Invalid product data: Ensure all entries are valid JSON strings.",
      "Mapping not found: The specified mapping_id does not exist.",
      "Unsupported target format: Use json, xml, csv, or channel_specific.",
      "Transformation rule error: One or more transformation rules are invalid.",
      "Data batch size exceeded: Maximum 500 products per transformation batch."
    ],
    "usage": "Provide product_data, mapping_id, and target_format. Optionally add transformation_rules and set include_metadata. Returns transformed data ready for channel publication.",
    "output_details": {
      "transformed_data": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Product data transformed to target format"
      },
      "transformation_status": {
        "type": "string",
        "description": "Overall transformation status: success, partial, or failed"
      },
      "processed_count": {
        "type": "integer",
        "description": "Number of products successfully transformed"
      },
      "error_count": {
        "type": "integer",
        "description": "Number of products that failed transformation"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Inventory Sync Coordinator",
    "tool_description": "Coordinates inventory level synchronization across multiple channels, managing stock updates, reservations, and availability status.",
    "parameters": {
      "product_ids": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Product identifiers to synchronize",
        "minItems": 1,
        "maxItems": 200
      },
      "inventory_levels": {
        "type": "array",
        "items": {"type": "integer"},
        "required": true,
        "description": "Current inventory quantities for each product",
        "minItems": 1,
        "maxItems": 200
      },
      "target_channels": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Channel identifiers to sync inventory",
        "minItems": 1,
        "maxItems": 20
      },
      "sync_mode": {
        "type": "string",
        "required": false,
        "description": "Synchronization mode: full, incremental, or selective",
        "default": "incremental"
      },
      "buffer_percentage": {
        "type": "number",
        "required": false,
        "description": "Safety stock buffer percentage (0-50)",
        "default": 5.0
      },
      "enable_oversell_protection": {
        "type": "boolean",
        "required": false,
        "description": "Prevent overselling across channels",
        "default": true
      }
    },
    "error_messages": [
      "Product ID mismatch: Number of product_ids must match inventory_levels array length.",
      "Invalid inventory levels: All inventory quantities must be non-negative integers.",
      "Channel configuration missing: One or more target channels are not configured.",
      "Invalid sync mode: Use full, incremental, or selective.",
      "Buffer percentage out of range: Must be between 0 and 50.",
      "Batch size limit exceeded: Maximum 200 products per sync operation."
    ],
    "usage": "Provide product_ids, inventory_levels, and target_channels arrays of equal length. Optionally configure sync_mode, buffer_percentage, and enable_oversell_protection. Returns synchronization status and results.",
    "output_details": {
      "sync_job_id": {
        "type": "string",
        "description": "Unique identifier for the synchronization job"
      },
      "channels_updated": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Channels that were successfully updated"
      },
      "channels_failed": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Channels that failed to update"
      },
      "sync_timestamp": {
        "type": "string",
        "description": "When the synchronization was completed"
      },
      "total_products_synced": {
        "type": "integer",
        "description": "Number of products successfully synchronized"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Channel Feed Builder",
    "tool_description": "Builds channel-specific product feeds from transformed data, applying feed templates and formatting requirements for each target channel.",
    "parameters": {
      "transformed_data": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Channel-ready product data entries",
        "minItems": 1,
        "maxItems": 1000
      },
      "channel_id": {
        "type": "string",
        "required": true,
        "description": "Target channel identifier"
      },
      "feed_template": {
        "type": "string",
        "required": false,
        "description": "Feed template name or custom template",
        "default": "standard"
      },
      "compression": {
        "type": "boolean",
        "required": false,
        "description": "Whether to compress the output feed",
        "default": false
      }
    },
    "error_messages": [
      "Invalid transformed data: Ensure all data entries are properly formatted strings.",
      "Channel not supported: The specified channel_id is not recognized.",
      "Template not found: The specified feed_template does not exist.",
      "Feed size limit exceeded: Maximum 1000 products per feed build operation.",
      "Data format incompatible: Transformed data format doesn't match channel requirements."
    ],
    "usage": "Provide transformed_data array and channel_id. Optionally specify feed_template and enable compression. Returns a complete channel feed ready for publication.",
    "output_details": {
      "feed_content": {
        "type": "string",
        "description": "Generated feed content in channel-specific format"
      },
      "feed_size": {
        "type": "integer",
        "description": "Size of the generated feed in bytes"
      },
      "product_count": {
        "type": "integer",
        "description": "Number of products included in the feed"
      },
      "generation_timestamp": {
        "type": "string",
        "description": "When the feed was generated"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Multi-Channel Publisher",
    "tool_description": "Publishes product feeds to multiple sales channels simultaneously, managing API calls, authentication, and publication status tracking.",
    "parameters": {
      "feed_content": {
        "type": "string",
        "required": true,
        "description": "Product feed content to publish"
      },
      "target_channels": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Channel identifiers for publication",
        "minItems": 1,
        "maxItems": 10
      },
      "publication_mode": {
        "type": "string",
        "required": false,
        "description": "Publication strategy: sequential, parallel, or batch",
        "default": "parallel"
      },
      "retry_attempts": {
        "type": "integer",
        "required": false,
        "description": "Number of retry attempts for failed publications (0-5)",
        "default": 3
      },
      "validate_before_publish": {
        "type": "boolean",
        "required": false,
        "description": "Validate feed before publishing to each channel",
        "default": true
      }
    },
    "error_messages": [
      "Empty feed content: Feed content cannot be empty or null.",
      "No target channels specified: At least one target channel is required.",
      "Channel limit exceeded: Maximum 10 channels per publication batch.",
      "Invalid publication mode: Use sequential, parallel, or batch.",
      "Retry attempts out of range: Must be between 0 and 5.",
      "Authentication failed: One or more channels failed authentication."
    ],
    "usage": "Provide feed_content and target_channels array. Optionally configure publication_mode, retry_attempts, and validate_before_publish. Returns publication status for each channel.",
    "output_details": {
      "publication_job_id": {
        "type": "string",
        "description": "Unique identifier for the publication job"
      },
      "successful_channels": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Channels where publication succeeded"
      },
      "failed_channels": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Channels where publication failed"
      },
      "publication_timestamp": {
        "type": "string",
        "description": "When the publication job completed"
      },
      "total_processing_time": {
        "type": "number",
        "description": "Total time taken for publication in seconds"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Conflict Resolution Engine",
    "tool_description": "Resolves conflicts between different data sources and channels, applying business rules and priority settings to determine authoritative data values.",
    "parameters": {
      "conflicting_data": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Data entries with conflicts in JSON format",
        "minItems": 2,
        "maxItems": 50
      },
      "resolution_strategy": {
        "type": "string",
        "required": true,
        "description": "Conflict resolution approach: priority_based, timestamp_based, merge, or manual"
      },
      "source_priorities": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Data source names in priority order (highest to lowest)",
        "default": []
      },
      "conflict_fields": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Specific fields to check for conflicts",
        "default": []
      },
      "auto_resolve": {
        "type": "boolean",
        "required": false,
        "description": "Automatically resolve conflicts without manual intervention",
        "default": true
      }
    },
    "error_messages": [
      "Insufficient data for conflict resolution: At least 2 conflicting data entries required.",
      "Invalid resolution strategy: Use priority_based, timestamp_based, merge, or manual.",
      "Conflict data format error: All entries must be valid JSON strings.",
      "Priority source not found: One or more sources in source_priorities don't exist in the data.",
      "Batch size limit exceeded: Maximum 50 conflicting entries per resolution batch."
    ],
    "usage": "Provide conflicting_data array and resolution_strategy. For priority_based resolution, include source_priorities. Optionally specify conflict_fields and set auto_resolve. Returns resolved data and resolution decisions.",
    "output_details": {
      "resolved_data": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Data entries after conflict resolution"
      },
      "resolution_decisions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Explanations of resolution decisions made"
      },
      "conflicts_resolved": {
        "type": "integer",
        "description": "Number of conflicts successfully resolved"
      },
      "manual_review_required": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Conflicts that require manual review"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Price Strategy Applicator",
    "tool_description": "Applies pricing strategies and rules to products for different channels, handling currency conversion, markups, and promotional pricing.",
    "parameters": {
      "product_data": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Product data with base pricing information",
        "minItems": 1,
        "maxItems": 300
      },
      "pricing_strategy": {
        "type": "string",
        "required": true,
        "description": "Pricing approach: fixed_markup, dynamic, competitive, or channel_specific"
      },
      "target_channels": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Channels to apply pricing strategies",
        "minItems": 1,
        "maxItems": 15
      },
      "markup_percentage": {
        "type": "number",
        "required": false,
        "description": "Default markup percentage for fixed_markup strategy",
        "default": 20.0
      },
      "currency_conversion": {
        "type": "boolean",
        "required": false,
        "description": "Enable automatic currency conversion",
        "default": false
      },
      "promotional_rules": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Promotional pricing rules to apply",
        "default": []
      },
      "minimum_margin": {
        "type": "number",
        "required": false,
        "description": "Minimum profit margin percentage to maintain",
        "default": 5.0
      }
    },
    "error_messages": [
      "Invalid product data format: Ensure all product entries contain valid pricing information.",
      "Unsupported pricing strategy: Use fixed_markup, dynamic, competitive, or channel_specific.",
      "Channel configuration missing: One or more target channels are not properly configured.",
      "Invalid markup percentage: Must be a positive number between 0 and 1000.",
      "Minimum margin conflict: Minimum margin cannot exceed markup percentage.",
      "Promotional rule format error: Rules must follow the specified format guidelines.",
      "Product batch limit exceeded: Maximum 300 products per pricing operation."
    ],
    "usage": "Provide product_data, pricing_strategy, and target_channels. Configure markup_percentage, enable currency_conversion if needed, add promotional_rules, and set minimum_margin. Returns products with channel-specific pricing applied.",
    "output_details": {
      "priced_products": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Products with applied pricing strategies"
      },
      "pricing_summary": {
        "type": "string",
        "description": "Summary of pricing changes applied"
      },
      "channels_processed": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Channels that received pricing updates"
      },
      "price_adjustments": {
        "type": "integer",
        "description": "Number of price adjustments made"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Content Enrichment Processor",
    "tool_description": "Enriches basic product information with additional content like descriptions, keywords, images, and metadata for improved channel presentation.",
    "parameters": {
      "basic_product_data": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Basic product information to enrich",
        "minItems": 1,
        "maxItems": 100
      },
      "enrichment_types": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Types of enrichment to apply: description, keywords, images, specifications, categories",
        "minItems": 1,
        "maxItems": 10
      },
      "content_quality": {
        "type": "string",
        "required": false,
        "description": "Content quality level: basic, standard, or premium",
        "default": "standard"
      },
      "target_audience": {
        "type": "string",
        "required": false,
        "description": "Target audience for content optimization",
        "default": "general"
      }
    },
    "error_messages": [
      "Invalid product data: Basic product data must contain valid product information.",
      "Unsupported enrichment type: Use description, keywords, images, specifications, or categories.",
      "Invalid content quality: Use basic, standard, or premium.",
      "Product batch limit exceeded: Maximum 100 products per enrichment batch.",
      "Enrichment service unavailable: Content enrichment service is temporarily unavailable."
    ],
    "usage": "Provide basic_product_data and enrichment_types arrays. Optionally set content_quality and target_audience. Returns enriched product data with enhanced content.",
    "output_details": {
      "enriched_products": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Products with enriched content"
      },
      "enrichment_status": {
        "type": "string",
        "description": "Overall enrichment process status"
      },
      "content_additions": {
        "type": "integer",
        "description": "Number of content elements added"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Category Mapping Resolver",
    "tool_description": "Maps internal product categories to channel-specific taxonomies and category structures, ensuring proper product categorization across platforms.",
    "parameters": {
      "internal_categories": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Internal category names or IDs",
        "minItems": 1,
        "maxItems": 50
      },
      "target_channel": {
        "type": "string",
        "required": true,
        "description": "Channel identifier for category mapping"
      },
      "mapping_confidence_threshold": {
        "type": "number",
        "required": false,
        "description": "Minimum confidence score for automatic mapping (0-1)",
        "default": 0.8
      }
    },
    "error_messages": [
      "Empty category list: At least one internal category is required.",
      "Invalid target channel: Channel taxonomy not available for the specified channel.",
      "Confidence threshold out of range: Must be between 0 and 1.",
      "Category limit exceeded: Maximum 50 categories per mapping operation.",
      "Taxonomy service error: Unable to access channel taxonomy information."
    ],
    "usage": "Provide internal_categories array and target_channel. Optionally adjust mapping_confidence_threshold. Returns category mappings with confidence scores.",
    "output_details": {
      "category_mappings": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Category mappings in 'internal:channel' format"
      },
      "unmapped_categories": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Categories that couldn't be mapped automatically"
      },
      "mapping_confidence_scores": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Confidence scores for each mapping"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Sync Status Monitor",
    "tool_description": "Monitors synchronization status across all channels, tracking job progress, identifying failures, and providing real-time status updates.",
    "parameters": {
      "job_ids": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Specific job IDs to monitor",
        "default": []
      },
      "channels": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "description": "Specific channels to monitor",
        "default": []
      },
      "time_range_hours": {
        "type": "integer",
        "required": false,
        "description": "Time range in hours for status monitoring (1-168)",
        "default": 24
      }
    },
    "error_messages": [
      "Invalid time range: Time range must be between 1 and 168 hours (1 week).",
      "Job ID not found: One or more specified job IDs do not exist.",
      "Channel not configured: One or more specified channels are not set up for monitoring.",
      "Monitoring service unavailable: Status monitoring service is temporarily down."
    ],
    "usage": "Optionally provide job_ids or channels to monitor specific items, or leave empty to monitor all. Set time_range_hours to adjust monitoring window. Returns comprehensive status information
