field_name: cloud_platforms
subfield: Infrastructure Provisioning and Management
task: Container orchestration and management including deployment, scaling, and monitoring of containerized applications
tool_description: |-
  **STEP 1 — Rate task difficulty**

  This task is **hard**. Container orchestration involves complex multi-layered systems with numerous interdependencies including cluster management, service discovery, load balancing, auto-scaling, health monitoring, and security policies. The scope encompasses infrastructure provisioning, application deployment, runtime management, and observability across distributed systems with significant risk from misconfigurations that can cause service outages.

  **STEP 2 — Set a tool budget**

  Given the hard difficulty rating, I'll target **17 tools** to cover the comprehensive workflow from cluster setup through monitoring and maintenance.

  **STEP 3 — List all tool names and dependencies**

  Tools and their data flow:
  - **Cluster Provisioner** → produces cluster configuration
  - **Container Image Builder** → produces container images
  - **Service Deployer** → consumes cluster config, images → produces deployment specs
  - **Load Balancer Configurator** → consumes deployment specs → produces routing rules
  - **Auto Scaler Controller** → consumes deployment specs, metrics → produces scaling actions
  - **Health Monitor** → consumes deployment info → produces health status
  - **Resource Quota Manager** → consumes cluster config → produces resource limits
  - **Secret Manager** → produces encrypted configurations
  - **Config Map Handler** → produces application configurations
  - **Volume Manager** → produces persistent storage configs
  - **Network Policy Creator** → consumes cluster topology → produces security rules
  - **Service Discovery Setup** → consumes service specs → produces discovery configs
  - **Rolling Update Manager** → consumes deployment specs → produces update strategies
  - **Log Aggregator** → consumes container logs → produces centralized logs
  - **Metrics Collector** → consumes system metrics → produces monitoring data
  - **Backup Controller** → consumes persistent data → produces backup artifacts
  - **Troubleshooter** → consumes logs, metrics → produces diagnostic reports

  **STEP 4 — Multi-tool plans**

  **Simple plans:**
  1. Basic deployment: Cluster Provisioner → Container Image Builder → Service Deployer → Health Monitor
  2. Storage setup: Cluster Provisioner → Volume Manager → Secret Manager → Config Map Handler

  **Medium plans:**
  1. Production deployment: Cluster Provisioner → Container Image Builder → Service Deployer → Load Balancer Configurator → Auto Scaler Controller → Health Monitor → Log Aggregator
  2. Security hardening: Cluster Provisioner → Network Policy Creator → Secret Manager → Resource Quota Manager → Service Discovery Setup → Health Monitor

  **Complex plans:**
  1. Full production pipeline: All 17 tools in sequence for complete containerized application lifecycle
  2. Disaster recovery setup: Cluster Provisioner → Service Deployer → Volume Manager → Backup Controller → Health Monitor → Troubleshooter → Rolling Update Manager → Metrics Collector

  **STEP 5 — Produce tools**

  ```json
  {
    "tool_name": "Cluster Provisioner",
    "tool_description": "Provisions and configures Kubernetes clusters with specified node configurations, networking, and resource allocation across cloud providers.",
    "parameters": {
      "cluster_name": {
        "type": "string",
        "required": true,
        "description": "Unique name for the Kubernetes cluster"
      },
      "cloud_provider": {
        "type": "string",
        "required": true,
        "description": "Cloud provider: aws, gcp, azure, or bare_metal"
      },
      "node_count": {
        "type": "integer",
        "required": true,
        "description": "Number of worker nodes (1-100)"
      },
      "node_instance_type": {
        "type": "string",
        "required": true,
        "description": "Instance type/size for worker nodes"
      },
      "kubernetes_version": {
        "type": "string",
        "required": false,
        "description": "Kubernetes version to install",
        "default": "1.28"
      },
      "region": {
        "type": "string",
        "required": true,
        "description": "Cloud region for cluster deployment"
      },
      "enable_auto_scaling": {
        "type": "boolean",
        "required": false,
        "description": "Enable cluster auto-scaling",
        "default": true
      },
      "max_nodes": {
        "type": "integer",
        "required": false,
        "description": "Maximum nodes for auto-scaling (1-500)",
        "default": 10
      },
      "network_cidr": {
        "type": "string",
        "required": false,
        "description": "CIDR block for cluster network",
        "default": "10.0.0.0/16"
      },
      "enable_logging": {
        "type": "boolean",
        "required": false,
        "description": "Enable cluster-level logging",
        "default": true
      },
      "enable_monitoring": {
        "type": "boolean",
        "required": false,
        "description": "Enable cluster monitoring",
        "default": true
      }
    },
    "error_messages": [
      "Invalid cloud provider: Use one of [aws, gcp, azure, bare_metal]",
      "Invalid node count: Must be between 1 and 100",
      "Invalid max_nodes: Must be between 1 and 500 and greater than node_count",
      "Invalid region: Specify a valid region for the selected cloud provider",
      "Invalid CIDR format: Use valid CIDR notation (e.g., 10.0.0.0/16)",
      "Unsupported Kubernetes version: Use supported version format (e.g., 1.28)",
      "Insufficient permissions: Ensure cloud provider credentials have cluster creation permissions"
    ],
    "usage": "Provide cluster_name, cloud_provider, node_count, node_instance_type, and region. Optionally configure kubernetes_version, scaling settings, and networking. Tool provisions cluster and returns connection details.",
    "output_details": {
      "cluster_id": {
        "type": "string",
        "description": "Unique identifier of the provisioned cluster"
      },
      "cluster_endpoint": {
        "type": "string",
        "description": "API server endpoint URL"
      },
      "status": {
        "type": "string",
        "description": "Cluster provisioning status"
      },
      "node_count": {
        "type": "integer",
        "description": "Number of nodes successfully provisioned"
      },
      "kubeconfig": {
        "type": "string",
        "description": "Base64 encoded kubeconfig for cluster access"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Container Image Builder",
    "tool_description": "Builds, tags, and pushes container images from source code or Dockerfile with security scanning and optimization features.",
    "parameters": {
      "source_path": {
        "type": "string",
        "required": true,
        "description": "Path to source code directory or Dockerfile"
      },
      "image_name": {
        "type": "string",
        "required": true,
        "description": "Name for the container image"
      },
      "image_tag": {
        "type": "string",
        "required": false,
        "description": "Tag for the image version",
        "default": "latest"
      },
      "registry_url": {
        "type": "string",
        "required": true,
        "description": "Container registry URL to push the image"
      },
      "dockerfile_path": {
        "type": "string",
        "required": false,
        "description": "Relative path to Dockerfile",
        "default": "Dockerfile"
      }
    },
    "error_messages": [
      "Source path not found: Ensure the source_path exists and is accessible",
      "Dockerfile not found: Check dockerfile_path exists in source_path",
      "Build failed: Review Dockerfile syntax and build context",
      "Registry authentication failed: Verify registry credentials and permissions",
      "Push failed: Check registry connectivity and image size limits",
      "Invalid image name: Use valid Docker image naming conventions"
    ],
    "usage": "Provide source_path, image_name, and registry_url. Optionally specify image_tag and dockerfile_path. Tool builds image from source and pushes to registry.",
    "output_details": {
      "image_uri": {
        "type": "string",
        "description": "Full URI of the built and pushed image"
      },
      "image_digest": {
        "type": "string",
        "description": "SHA256 digest of the image"
      },
      "build_status": {
        "type": "string",
        "description": "Build process status"
      },
      "image_size_mb": {
        "type": "number",
        "description": "Size of the built image in megabytes"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Service Deployer",
    "tool_description": "Deploys containerized applications to Kubernetes clusters with configurable replicas, resources, and deployment strategies.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "image_uri": {
        "type": "string",
        "required": true,
        "description": "Full container image URI to deploy"
      },
      "service_name": {
        "type": "string",
        "required": true,
        "description": "Name for the deployed service"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace for deployment",
        "default": "default"
      },
      "replicas": {
        "type": "integer",
        "required": false,
        "description": "Number of pod replicas (1-100)",
        "default": 3
      },
      "cpu_request": {
        "type": "string",
        "required": false,
        "description": "CPU resource request (e.g., '100m', '1')",
        "default": "100m"
      },
      "memory_request": {
        "type": "string",
        "required": false,
        "description": "Memory resource request (e.g., '128Mi', '1Gi')",
        "default": "128Mi"
      },
      "cpu_limit": {
        "type": "string",
        "required": false,
        "description": "CPU resource limit",
        "default": "500m"
      },
      "memory_limit": {
        "type": "string",
        "required": false,
        "description": "Memory resource limit",
        "default": "512Mi"
      },
      "port": {
        "type": "integer",
        "required": false,
        "description": "Container port to expose (1-65535)",
        "default": 80
      },
      "environment_variables": {
        "type": "array",
        "required": false,
        "description": "Environment variables as key=value pairs",
        "items": {"type": "string"},
        "default": []
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are correct",
      "Invalid image URI: Ensure image_uri is accessible and properly formatted",
      "Namespace not found: Create namespace or use existing one",
      "Invalid replica count: Must be between 1 and 100",
      "Invalid resource format: Use Kubernetes resource format (e.g., '100m', '1Gi')",
      "Port out of range: Use port between 1 and 65535",
      "Deployment failed: Check cluster resources and image pull permissions",
      "Invalid environment variables: Use format 'KEY=value'"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, image_uri, and service_name. Configure resources, replicas, and environment as needed. Tool creates Kubernetes deployment and service.",
    "output_details": {
      "deployment_name": {
        "type": "string",
        "description": "Name of the created Kubernetes deployment"
      },
      "service_name": {
        "type": "string",
        "description": "Name of the created Kubernetes service"
      },
      "namespace": {
        "type": "string",
        "description": "Namespace where resources were deployed"
      },
      "replica_status": {
        "type": "string",
        "description": "Status of replica deployment"
      },
      "service_endpoint": {
        "type": "string",
        "description": "Internal service endpoint for the deployment"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Load Balancer Configurator",
    "tool_description": "Configures load balancers and ingress controllers for distributing traffic across containerized services with SSL/TLS termination.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "service_name": {
        "type": "string",
        "required": true,
        "description": "Target service name for load balancing"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace of the service",
        "default": "default"
      },
      "load_balancer_type": {
        "type": "string",
        "required": true,
        "description": "Type of load balancer: nginx, traefik, or cloud_lb"
      },
      "domain_name": {
        "type": "string",
        "required": false,
        "description": "Domain name for ingress routing",
        "default": null
      },
      "enable_ssl": {
        "type": "boolean",
        "required": false,
        "description": "Enable SSL/TLS termination",
        "default": true
      },
      "ssl_cert_path": {
        "type": "string",
        "required": false,
        "description": "Path to SSL certificate file",
        "default": null
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are valid",
      "Service not found: Ensure service_name exists in the specified namespace",
      "Invalid load balancer type: Use one of [nginx, traefik, cloud_lb]",
      "SSL certificate not found: Verify ssl_cert_path exists and is readable",
      "Invalid domain name: Provide valid DNS domain name format",
      "Load balancer deployment failed: Check cluster permissions and resources",
      "Ingress creation failed: Verify ingress controller is installed"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, service_name, and load_balancer_type. Configure SSL and domain settings as needed. Tool sets up load balancing and ingress routing.",
    "output_details": {
      "load_balancer_ip": {
        "type": "string",
        "description": "External IP address of the load balancer"
      },
      "ingress_name": {
        "type": "string",
        "description": "Name of the created ingress resource"
      },
      "ssl_enabled": {
        "type": "boolean",
        "description": "Whether SSL/TLS is configured"
      },
      "external_url": {
        "type": "string",
        "description": "External URL to access the service"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Auto Scaler Controller",
    "tool_description": "Configures horizontal and vertical pod autoscaling based on CPU, memory, and custom metrics with scaling policies and limits.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "deployment_name": {
        "type": "string",
        "required": true,
        "description": "Target deployment name for autoscaling"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace of the deployment",
        "default": "default"
      },
      "min_replicas": {
        "type": "integer",
        "required": false,
        "description": "Minimum number of replicas (1-100)",
        "default": 2
      },
      "max_replicas": {
        "type": "integer",
        "required": false,
        "description": "Maximum number of replicas (1-1000)",
        "default": 10
      },
      "cpu_threshold": {
        "type": "integer",
        "required": false,
        "description": "CPU utilization percentage threshold (1-100)",
        "default": 70
      },
      "memory_threshold": {
        "type": "integer",
        "required": false,
        "description": "Memory utilization percentage threshold (1-100)",
        "default": 80
      },
      "scale_up_cooldown": {
        "type": "integer",
        "required": false,
        "description": "Scale up cooldown period in seconds",
        "default": 300
      },
      "scale_down_cooldown": {
        "type": "integer",
        "required": false,
        "description": "Scale down cooldown period in seconds",
        "default": 300
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are valid",
      "Deployment not found: Ensure deployment_name exists in the specified namespace",
      "Invalid replica range: min_replicas must be less than max_replicas and within bounds",
      "Invalid threshold: CPU and memory thresholds must be between 1 and 100",
      "Metrics server not found: Install metrics-server for autoscaling to work",
      "HPA creation failed: Check deployment has resource requests configured",
      "Invalid cooldown period: Cooldown values must be positive integers"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, and deployment_name. Configure scaling thresholds and limits. Tool creates HorizontalPodAutoscaler resource with specified policies.",
    "output_details": {
      "hpa_name": {
        "type": "string",
        "description": "Name of the created HPA resource"
      },
      "current_replicas": {
        "type": "integer",
        "description": "Current number of replicas"
      },
      "scaling_status": {
        "type": "string",
        "description": "Current scaling status"
      },
      "target_metrics": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of configured scaling metrics"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Health Monitor",
    "tool_description": "Monitors container and service health with configurable probes, alerting thresholds, and notification channels for early issue detection.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "service_name": {
        "type": "string",
        "required": true,
        "description": "Service name to monitor"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace of the service",
        "default": "default"
      },
      "health_check_path": {
        "type": "string",
        "required": false,
        "description": "HTTP path for health checks",
        "default": "/health"
      },
      "check_interval": {
        "type": "integer",
        "required": false,
        "description": "Health check interval in seconds (10-3600)",
        "default": 30
      },
      "timeout_seconds": {
        "type": "integer",
        "required": false,
        "description": "Health check timeout in seconds (1-300)",
        "default": 10
      },
      "failure_threshold": {
        "type": "integer",
        "required": false,
        "description": "Number of failures before marking unhealthy (1-20)",
        "default": 3
      },
      "alert_webhook": {
        "type": "string",
        "required": false,
        "description": "Webhook URL for sending alerts",
        "default": null
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are valid",
      "Service not found: Ensure service_name exists in the specified namespace",
      "Invalid check interval: Must be between 10 and 3600 seconds",
      "Invalid timeout: Must be between 1 and 300 seconds and less than check_interval",
      "Invalid failure threshold: Must be between 1 and 20",
      "Webhook URL invalid: Provide valid HTTP/HTTPS URL for alert_webhook",
      "Health check probe failed: Verify health_check_path is accessible"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, and service_name. Configure health check parameters and alert settings. Tool sets up monitoring probes and health status reporting.",
    "output_details": {
      "monitor_id": {
        "type": "string",
        "description": "Unique identifier for the health monitor"
      },
      "health_status": {
        "type": "string",
        "description": "Current health status of the service"
      },
      "last_check_time": {
        "type": "string",
        "description": "Timestamp of last health check"
      },
      "healthy_pods": {
        "type": "integer",
        "description": "Number of healthy pods"
      },
      "total_pods": {
        "type": "integer",
        "description": "Total number of pods"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Resource Quota Manager",
    "tool_description": "Manages resource quotas and limits for namespaces to prevent resource exhaustion and ensure fair resource allocation across workloads.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "namespace": {
        "type": "string",
        "required": true,
        "description": "Target namespace for quota management"
      },
      "cpu_limit": {
        "type": "string",
        "required": false,
        "description": "Total CPU limit for namespace (e.g., '4', '2000m')",
        "default": "2"
      },
      "memory_limit": {
        "type": "string",
        "required": false,
        "description": "Total memory limit for namespace (e.g., '8Gi', '4096Mi')",
        "default": "4Gi"
      },
      "storage_limit": {
        "type": "string",
        "required": false,
        "description": "Persistent volume storage limit (e.g., '10Gi')",
        "default": "10Gi"
      },
      "pod_limit": {
        "type": "integer",
        "required": false,
        "description": "Maximum number of pods in namespace (1-1000)",
        "default": 10
      },
      "service_limit": {
        "type": "integer",
        "required": false,
        "description": "Maximum number of services in namespace (1-100)",
        "default": 5
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are valid",
      "Namespace not found: Ensure target namespace exists or will be created",
      "Invalid resource format: Use Kubernetes resource format (e.g., '2', '4Gi', '1000m')",
      "Invalid pod limit: Must be between 1 and 1000",
      "Invalid service limit: Must be between 1 and 100",
      "Quota creation failed: Check cluster permissions for resource quota management",
      "Resource limit too low: Ensure limits accommodate existing workloads"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, and namespace. Configure resource limits as needed. Tool creates ResourceQuota and LimitRange objects to enforce constraints.",
    "output_details": {
      "quota_name": {
        "type": "string",
        "description": "Name of the created resource quota"
      },
      "namespace": {
        "type": "string",
        "description": "Target namespace for the quota"
      },
      "cpu_limit": {
        "type": "string",
        "description": "Applied CPU limit"
      },
      "memory_limit": {
        "type": "string",
        "description": "Applied memory limit"
      },
      "quota_status": {
        "type": "string",
        "description": "Status of quota creation"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Secret Manager",
    "tool_description": "Creates and manages Kubernetes secrets for storing sensitive data like passwords, API keys, and certificates with encryption at rest.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "secret_name": {
        "type": "string",
        "required": true,
        "description": "Name for the secret resource"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace for the secret",
        "default": "default"
      },
      "secret_type": {
        "type": "string",
        "required": false,
        "description": "Type of secret: generic, tls, docker-registry",
        "default": "generic"
      },
      "data_pairs": {
        "type": "array",
        "required": true,
        "description": "Key-value pairs for secret data as 'key=value'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 50
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are valid",
      "Invalid secret name: Use valid Kubernetes resource naming conventions",
      "Invalid secret type: Use one of [generic, tls, docker-registry]",
      "Invalid data format: Use 'key=value' format for data_pairs",
      "Secret already exists: Choose a different secret_name or update existing",
      "Namespace not found: Ensure target namespace exists",
      "Data too large: Secret data size exceeds Kubernetes limits (1MB)"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, secret_name, and data_pairs. Specify secret_type for special types. Tool creates encrypted Kubernetes secret resource.",
    "output_details": {
      "secret_name": {
        "type": "string",
        "description": "Name of the created secret"
      },
      "namespace": {
        "type": "string",
        "description": "Namespace containing the secret"
      },
      "secret_type": {
        "type": "string",
        "description": "Type of the created secret"
      },
      "data_keys": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of data keys stored in the secret"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Config Map Handler",
    "tool_description": "Creates and manages Kubernetes ConfigMaps for storing non-sensitive configuration data accessible to containerized applications.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "configmap_name": {
        "type": "string",
        "required": true,
        "description": "Name for the ConfigMap resource"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace for the ConfigMap",
        "default": "default"
      },
      "config_data": {
        "type": "array",
        "required": true,
        "description": "Configuration key-value pairs as 'key=value'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 100
      }
    },
    "error_messages": [
      "Cluster connection failed: Verify cluster_endpoint and kubeconfig are valid",
      "Invalid ConfigMap name: Use valid Kubernetes resource naming conventions",
      "Invalid config data format: Use 'key=value' format for config_data",
      "ConfigMap already exists: Choose different name or update existing resource",
      "Namespace not found: Ensure target namespace exists",
      "Data too large: ConfigMap data size exceeds Kubernetes limits (1MB)"
    ],
    "usage": "Provide cluster_endpoint, kubeconfig, configmap_name, and config_data array. Tool creates ConfigMap resource with specified configuration data for application use.",
    "output_details": {
      "configmap_name": {
        "type": "string",
        "description": "Name of the created ConfigMap"
      },
      "namespace": {
        "type": "string",
        "description": "Namespace containing the ConfigMap"
      },
      "data_keys": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of configuration keys in the ConfigMap"
      },
      "creation_status": {
        "type": "string",
        "description": "Status of ConfigMap creation"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Volume Manager",
    "tool_description": "Manages persistent volumes and volume claims for containerized applications with support for different storage classes and access modes.",
    "parameters": {
      "cluster_endpoint": {
        "type": "string",
        "required": true,
        "description": "Kubernetes cluster API endpoint"
      },
      "kubeconfig": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded kubeconfig for cluster authentication"
      },
      "volume_name": {
        "type": "string",
        "required": true,
        "description": "Name for the persistent volume claim"
      },
      "namespace": {
        "type": "string",
        "required": false,
        "description": "Kubernetes namespace for the volume",
        "default": "default"
      },
      "storage_size": {
        "type": "string",
        "required": true,
        "description": "Storage size (e.g., '10Gi', '500Mi')"
      },
      "storage_class": {
        "type": "string",
        "required": false,
        "description": "Storage class name for provisioning",
        "default": "standar
