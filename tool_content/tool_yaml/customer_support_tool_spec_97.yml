field_name: customer_support
subfield: call_center_operations
task: Manage call queues and wait times to optimize customer experience
tool_description: |-
  **STEP 1 — Rate task difficulty**

  This task is **medium** difficulty. It involves real-time coordination of multiple queues, dynamic resource allocation, and balancing competing objectives (wait times vs agent utilization). The scope includes queue management, agent assignment, performance monitoring, and customer experience optimization with moderate coordination dependencies and operational risk.

  **STEP 2 — Set a tool budget**

  Target: **12 tools** (within the 10-15 range for medium difficulty tasks)

  **STEP 3 — List all tool names with dependencies and affordances**

  1. **Queue Monitor** - Consumes: queue IDs → Produces: real-time queue metrics
  2. **Agent Status Tracker** - Consumes: agent IDs → Produces: agent availability/status data
  3. **Call Classifier** - Consumes: call metadata → Produces: priority/category assignments
  4. **Queue Assignment Engine** - Consumes: call data, queue metrics → Produces: optimal queue assignments
  5. **Wait Time Predictor** - Consumes: queue state, historical data → Produces: estimated wait times
  6. **Agent Matcher** - Consumes: call requirements, agent skills → Produces: agent-call pairings
  7. **Overflow Controller** - Consumes: queue thresholds, current loads → Produces: overflow decisions
  8. **Customer Notification System** - Consumes: wait estimates, customer data → Produces: notification confirmations
  9. **Performance Analytics** - Consumes: historical call data → Produces: performance insights
  10. **Service Level Monitor** - Consumes: queue metrics, SLA targets → Produces: compliance reports
  11. **Dynamic Routing Engine** - Consumes: system state, routing rules → Produces: routing decisions
  12. **Queue Configuration Manager** - Consumes: operational parameters → Produces: queue settings

  **STEP 4 — Multi-tool plans**

  **Simple Plans:**
  - **Basic Queue Monitoring**: Queue Monitor → Service Level Monitor (track basic queue performance)
  - **Agent Status Check**: Agent Status Tracker → Agent Matcher (match available agents to calls)

  **Medium Plans:**
  - **Smart Call Routing**: Call Classifier → Queue Assignment Engine → Agent Matcher → Customer Notification System (classify, route, assign, and notify)
  - **Wait Time Management**: Queue Monitor → Wait Time Predictor → Customer Notification System (predict and communicate wait times)

  **Complex Plans:**
  - **Full Queue Optimization**: Queue Monitor → Call Classifier → Queue Assignment Engine → Wait Time Predictor → Agent Matcher → Overflow Controller → Dynamic Routing Engine (comprehensive queue management with overflow handling)
  - **Performance-Driven Operations**: Performance Analytics → Queue Configuration Manager → Service Level Monitor → Dynamic Routing Engine → Customer Notification System (data-driven optimization with customer communication)

  **STEP 5 — Produce tools**

  ```json
  {
    "tool_name": "Queue Monitor",
    "tool_description": "Monitors real-time metrics for call center queues including call counts, wait times, and queue status.",
    "parameters": {
      "queue_ids": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "List of queue identifiers to monitor",
        "minItems": 1,
        "maxItems": 20
      },
      "refresh_interval": {
        "type": "integer",
        "required": false,
        "description": "Monitoring refresh interval in seconds (5-300)",
        "default": 30
      }
    },
    "error_messages": [
      "Invalid queue IDs: One or more queue identifiers not found in the system.",
      "Refresh interval out of range: Must be between 5 and 300 seconds.",
      "System unavailable: Queue monitoring service is temporarily unavailable."
    ],
    "usage": "Provide queue_ids array to monitor specific queues. Optionally set refresh_interval for update frequency. Returns current queue metrics and status information.",
    "output_details": {
      "queue_metrics": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Array of queue metric summaries including calls waiting, average wait time, and status"
      },
      "total_calls_waiting": {
        "type": "integer",
        "description": "Total number of calls waiting across all monitored queues"
      },
      "average_wait_time": {
        "type": "number",
        "description": "Average wait time in minutes across all queues"
      },
      "timestamp": {
        "type": "string",
        "description": "Timestamp of the monitoring snapshot"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Agent Status Tracker",
    "tool_description": "Tracks availability, skills, and current status of call center agents for optimal assignment decisions.",
    "parameters": {
      "agent_ids": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Specific agent IDs to track, if empty tracks all agents",
        "default": "None"
      },
      "include_skills": {
        "type": "boolean",
        "required": false,
        "description": "Include agent skill information in response",
        "default": true
      },
      "status_filter": {
        "type": "string",
        "required": false,
        "description": "Filter by status: available, busy, offline, break",
        "default": "None"
      }
    },
    "error_messages": [
      "Agent ID not found: One or more specified agent IDs do not exist.",
      "Invalid status filter: Use one of [available, busy, offline, break].",
      "Access denied: Insufficient permissions to view agent status information."
    ],
    "usage": "Optionally specify agent_ids to track specific agents, set include_skills to get skill data, and use status_filter to focus on agents with particular status. Returns comprehensive agent status information.",
    "output_details": {
      "agent_statuses": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Array of agent status summaries including ID, availability, and skills"
      },
      "available_count": {
        "type": "integer",
        "description": "Number of agents currently available"
      },
      "busy_count": {
        "type": "integer",
        "description": "Number of agents currently on calls"
      },
      "offline_count": {
        "type": "integer",
        "description": "Number of agents currently offline"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Call Classifier",
    "tool_description": "Analyzes incoming call metadata to assign priority levels and categorize calls for optimal routing.",
    "parameters": {
      "call_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the incoming call"
      },
      "customer_tier": {
        "type": "string",
        "required": true,
        "description": "Customer tier: premium, standard, basic"
      },
      "call_reason": {
        "type": "string",
        "required": true,
        "description": "Reason for call: technical_support, billing, sales, complaint, general_inquiry"
      },
      "customer_history": {
        "type": "string",
        "required": false,
        "description": "Previous interaction summary",
        "default": "None"
      },
      "urgency_indicators": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Array of urgency keywords or indicators",
        "default": "None"
      }
    },
    "error_messages": [
      "Invalid customer tier: Must be one of [premium, standard, basic].",
      "Invalid call reason: Must be one of [technical_support, billing, sales, complaint, general_inquiry].",
      "Call ID already processed: This call has already been classified.",
      "Missing required data: Call ID and customer tier are mandatory."
    ],
    "usage": "Provide call_id, customer_tier, and call_reason for basic classification. Include customer_history and urgency_indicators for more accurate priority assignment.",
    "output_details": {
      "priority_level": {
        "type": "string",
        "description": "Assigned priority level: high, medium, low"
      },
      "category": {
        "type": "string",
        "description": "Call category based on reason and analysis"
      },
      "recommended_queue": {
        "type": "string",
        "description": "Suggested queue for routing this call"
      },
      "classification_confidence": {
        "type": "number",
        "description": "Confidence score for classification (0-1)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Queue Assignment Engine",
    "tool_description": "Determines optimal queue assignment for calls based on call characteristics, queue capacity, and performance metrics.",
    "parameters": {
      "call_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the call to be assigned"
      },
      "call_priority": {
        "type": "string",
        "required": true,
        "description": "Call priority level: high, medium, low"
      },
      "call_category": {
        "type": "string",
        "required": true,
        "description": "Call category from classification"
      },
      "available_queues": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "List of available queue identifiers",
        "minItems": 1
      },
      "queue_capacities": {
        "type": "array",
        "items": {
          "type": "integer"
        },
        "required": true,
        "description": "Current capacity for each available queue",
        "minItems": 1
      },
      "balance_factor": {
        "type": "number",
        "required": false,
        "description": "Load balancing weight (0-1, where 1 = maximum balancing)",
        "default": 0.7
      },
      "skill_requirements": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Required agent skills for this call",
        "default": "None"
      }
    },
    "error_messages": [
      "Mismatched arrays: available_queues and queue_capacities must have the same length.",
      "Invalid priority level: Must be one of [high, medium, low].",
      "No suitable queue: No available queue can handle this call type.",
      "Balance factor out of range: Must be between 0 and 1.",
      "All queues at capacity: No queue has available capacity for new calls."
    ],
    "usage": "Provide call details (call_id, priority, category), available queues with their capacities. Optionally set balance_factor for load balancing preference and skill_requirements for specialized routing.",
    "output_details": {
      "assigned_queue": {
        "type": "string",
        "description": "Queue identifier where the call should be routed"
      },
      "assignment_reason": {
        "type": "string",
        "description": "Explanation for why this queue was selected"
      },
      "estimated_position": {
        "type": "integer",
        "description": "Expected position in the assigned queue"
      },
      "confidence_score": {
        "type": "number",
        "description": "Confidence in assignment decision (0-1)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Wait Time Predictor",
    "tool_description": "Predicts customer wait times based on current queue state, agent performance, and historical patterns.",
    "parameters": {
      "queue_id": {
        "type": "string",
        "required": true,
        "description": "Queue identifier for wait time prediction"
      },
      "position_in_queue": {
        "type": "integer",
        "required": true,
        "description": "Customer's position in the queue (1-based)"
      },
      "time_of_day": {
        "type": "string",
        "required": true,
        "description": "Current time for contextual prediction",
        "format": "date-time"
      },
      "historical_window": {
        "type": "integer",
        "required": false,
        "description": "Days of historical data to consider (1-30)",
        "default": 7
      },
      "call_complexity": {
        "type": "string",
        "required": false,
        "description": "Expected call complexity: simple, medium, complex",
        "default": "medium"
      }
    },
    "error_messages": [
      "Queue not found: The specified queue ID does not exist.",
      "Invalid position: Position must be a positive integer within queue bounds.",
      "Invalid time format: Use ISO 8601 date-time format.",
      "Historical window out of range: Must be between 1 and 30 days.",
      "Invalid complexity level: Must be one of [simple, medium, complex]."
    ],
    "usage": "Provide queue_id, position_in_queue, and current time_of_day. Optionally adjust historical_window for prediction accuracy and call_complexity for better estimates.",
    "output_details": {
      "predicted_wait_minutes": {
        "type": "number",
        "description": "Estimated wait time in minutes"
      },
      "confidence_interval_low": {
        "type": "number",
        "description": "Lower bound of wait time estimate"
      },
      "confidence_interval_high": {
        "type": "number",
        "description": "Upper bound of wait time estimate"
      },
      "prediction_accuracy": {
        "type": "number",
        "description": "Historical accuracy of predictions for this queue (0-1)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Agent Matcher",
    "tool_description": "Matches calls to the most suitable available agents based on skills, performance, and call requirements.",
    "parameters": {
      "call_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the call requiring agent assignment"
      },
      "required_skills": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "Skills required for handling this call",
        "minItems": 1,
        "maxItems": 10
      },
      "call_priority": {
        "type": "string",
        "required": true,
        "description": "Priority level: high, medium, low"
      },
      "preferred_language": {
        "type": "string",
        "required": false,
        "description": "Customer's preferred language",
        "default": "english"
      },
      "customer_tier": {
        "type": "string",
        "required": false,
        "description": "Customer tier for agent matching",
        "default": "standard"
      },
      "avoid_agents": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Agent IDs to avoid for this assignment",
        "default": "None"
      }
    },
    "error_messages": [
      "No agents available: No agents currently available with required skills.",
      "Invalid priority level: Must be one of [high, medium, low].",
      "Skill not recognized: One or more required skills not found in system.",
      "Language not supported: Preferred language not available.",
      "All suitable agents excluded: Available agents are in avoid_agents list."
    ],
    "usage": "Provide call_id, required_skills, and call_priority. Optionally specify preferred_language, customer_tier, and avoid_agents for refined matching.",
    "output_details": {
      "matched_agent_id": {
        "type": "string",
        "description": "ID of the best matched agent"
      },
      "match_score": {
        "type": "number",
        "description": "Quality of the match (0-1, higher is better)"
      },
      "agent_skills": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Skills possessed by the matched agent"
      },
      "estimated_availability": {
        "type": "string",
        "description": "When the agent will be available"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Overflow Controller",
    "tool_description": "Manages call overflow scenarios by detecting capacity thresholds and triggering alternative routing or callback options.",
    "parameters": {
      "queue_id": {
        "type": "string",
        "required": true,
        "description": "Primary queue identifier experiencing overflow"
      },
      "current_wait_time": {
        "type": "number",
        "required": true,
        "description": "Current average wait time in minutes"
      },
      "queue_length": {
        "type": "integer",
        "required": true,
        "description": "Number of calls currently in queue"
      },
      "overflow_threshold_time": {
        "type": "number",
        "required": false,
        "description": "Wait time threshold for overflow action (minutes)",
        "default": 10.0
      },
      "overflow_threshold_length": {
        "type": "integer",
        "required": false,
        "description": "Queue length threshold for overflow action",
        "default": 20
      },
      "alternative_queues": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Alternative queues for overflow routing",
        "default": "None"
      },
      "callback_enabled": {
        "type": "boolean",
        "required": false,
        "description": "Whether callback option should be offered",
        "default": true
      },
      "priority_calls_only": {
        "type": "boolean",
        "required": false,
        "description": "Apply overflow only to high priority calls",
        "default": false
      }
    },
    "error_messages": [
      "Queue not found: The specified queue ID does not exist.",
      "Invalid threshold values: Thresholds must be positive numbers.",
      "Alternative queue unavailable: One or more alternative queues not operational.",
      "Negative wait time: Current wait time cannot be negative.",
      "Invalid queue length: Queue length must be a non-negative integer."
    ],
    "usage": "Provide queue_id, current_wait_time, and queue_length. Set overflow thresholds, alternative_queues, and options for callback and priority handling to control overflow behavior.",
    "output_details": {
      "overflow_triggered": {
        "type": "boolean",
        "description": "Whether overflow condition was detected"
      },
      "recommended_action": {
        "type": "string",
        "description": "Suggested overflow action: route_alternative, offer_callback, increase_capacity"
      },
      "alternative_queue_id": {
        "type": "string",
        "description": "Recommended alternative queue if applicable"
      },
      "severity_level": {
        "type": "string",
        "description": "Overflow severity: low, medium, high, critical"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Customer Notification System",
    "tool_description": "Sends automated notifications to customers about wait times, queue position, callback options, and service updates.",
    "parameters": {
      "customer_phone": {
        "type": "string",
        "required": true,
        "description": "Customer phone number for notification"
      },
      "notification_type": {
        "type": "string",
        "required": true,
        "description": "Type: wait_update, position_update, callback_offer, service_disruption"
      },
      "estimated_wait_time": {
        "type": "number",
        "required": false,
        "description": "Estimated wait time in minutes",
        "default": "None"
      },
      "queue_position": {
        "type": "integer",
        "required": false,
        "description": "Current position in queue",
        "default": "None"
      },
      "message_template": {
        "type": "string",
        "required": false,
        "description": "Custom message template to use",
        "default": "standard"
      },
      "callback_window": {
        "type": "string",
        "required": false,
        "description": "Callback time window if offering callback",
        "default": "None"
      },
      "notification_channel": {
        "type": "string",
        "required": false,
        "description": "Channel: sms, voice, email",
        "default": "sms"
      }
    },
    "error_messages": [
      "Invalid phone number: Phone number format is incorrect or invalid.",
      "Unknown notification type: Must be one of [wait_update, position_update, callback_offer, service_disruption].",
      "Invalid notification channel: Must be one of [sms, voice, email].",
      "Missing required data: Some notification types require wait time or position information.",
      "Notification failed: Unable to deliver notification to specified number/address."
    ],
    "usage": "Provide customer_phone and notification_type. Include relevant data like estimated_wait_time, queue_position based on notification type. Customize with message_template and notification_channel.",
    "output_details": {
      "notification_sent": {
        "type": "boolean",
        "description": "Whether notification was successfully sent"
      },
      "delivery_status": {
        "type": "string",
        "description": "Delivery status: sent, delivered, failed, pending"
      },
      "message_content": {
        "type": "string",
        "description": "Content of the notification message sent"
      },
      "delivery_timestamp": {
        "type": "string",
        "description": "When notification was delivered"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Performance Analytics",
    "tool_description": "Analyzes historical call center performance data to identify trends, bottlenecks, and optimization opportunities.",
    "parameters": {
      "start_date": {
        "type": "string",
        "required": true,
        "description": "Analysis start date",
        "format": "date-time"
      },
      "end_date": {
        "type": "string",
        "required": true,
        "description": "Analysis end date",
        "format": "date-time"
      },
      "metrics": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "Metrics to analyze: wait_time, abandonment_rate, first_call_resolution, agent_utilization",
        "minItems": 1,
        "maxItems": 10
      },
      "granularity": {
        "type": "string",
        "required": false,
        "description": "Data granularity: hourly, daily, weekly",
        "default": "daily"
      },
      "queue_filter": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Filter by specific queue IDs",
        "default": "None"
      },
      "include_forecasting": {
        "type": "boolean",
        "required": false,
        "description": "Include predictive forecasting in analysis",
        "default": false
      }
    },
    "error_messages": [
      "Invalid date range: End date must be after start date.",
      "Date range too large: Maximum analysis period is 90 days.",
      "Unknown metric: Use valid metrics from the supported list.",
      "Invalid granularity: Must be one of [hourly, daily, weekly].",
      "Insufficient data: Not enough historical data for requested analysis period."
    ],
    "usage": "Specify start_date, end_date, and metrics array for analysis. Optionally filter by queues, set granularity, and enable forecasting for predictive insights.",
    "output_details": {
      "analysis_summary": {
        "type": "string",
        "description": "High-level summary of performance analysis"
      },
      "metric_values": {
        "type": "array",
        "items": {
          "type": "number"
        },
        "description": "Array of metric values over the analysis period"
      },
      "trend_direction": {
        "type": "string",
        "description": "Overall trend: improving, declining, stable"
      },
      "bottlenecks_identified": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "List of identified performance bottlenecks"
      },
      "recommendations": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Performance improvement recommendations"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Service Level Monitor",
    "tool_description": "Monitors service level agreement compliance and alerts when performance targets are at risk or violated.",
    "parameters": {
      "sla_targets": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "SLA targets to monitor (e.g., '80% calls answered in 20 seconds')",
        "minItems": 1,
        "maxItems": 5
      },
      "monitoring_period": {
        "type": "string",
        "required": true,
        "description": "Monitoring timeframe: real_time, hourly, daily, weekly"
      },
      "queue_scope": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Queue IDs to include in monitoring",
        "default": "None"
      },
      "alert_threshold": {
        "type": "number",
        "required": false,
        "description": "Performance threshold for alerts (0.1-1.0, where 1.0 = 100%)",
        "default": 0.9
      }
    },
    "error_messages": [
      "Invalid SLA format: SLA targets must follow the format 'percentage calls metric threshold'.",
      "Unknown monitoring period: Must be one of [real_time, hourly, daily, weekly].",
      "Alert threshold out of range: Must be between 0.1 and 1.0.",
      "Queue not found: One or more specified queues do not exist.",
      "Insufficient permissions: Cannot access SLA monitoring for specified scope."
    ],
    "usage": "Define sla_targets array with specific performance goals and set monitoring_period. Optionally scope to specific queues and set alert_threshold for proactive notifications.",
    "output_details": {
      "compliance_status": {
        "type": "string",
        "description": "Overall compliance status: compliant, at_risk, violation"
      },
      "current_performance": {
        "type": "array",
        "items": {
          "type": "number"
        },
        "description": "Current performance values for each SLA target"
      },
      "sla_violations": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "List of current SLA violations"
      },
      "time_to_violation": {
        "type": "number",
        "description": "Estimated minutes until potential SLA violation"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Dynamic Routing Engine",
    "tool_description": "Implements intelligent call routing decisions based on real-time conditions, business rules, and optimization algorithms.",
    "parameters": {
      "call_data": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "Call information: ID, priority, category, customer data",
        "minItems": 4,
        "maxItems": 10
      },
      "routing_strategy": {
        "type": "string",
        "required": true,
        "description": "Strategy: load_balance, skill_based, priority_first, shortest_wait"
      },
      "business_hours": {
        "type": "boolean",
        "required": true,
        "description": "Whether current time is within business hours"
      },
      "system_load": {
        "type": "string",
        "required": true,
        "description": "Current system load level: low, medium, high, critical"
      },
      "routing_rules": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Custom routing rules to apply",
        "default": "None"
      },
      "fallback_queue": {
        "type": "string",
        "required": false,
        "description": "Fallback queue if primary routing fails",
        "default": "general"
      },
      "max_wait_override": {
        "type": "number",
        "required": false,
        "description": "Maximum wait time before override routing (minutes)",
        "default": 15.0
      },
      "vip_customer": {
        "type": "boolean",
        "required": false,
        "description": "Whether customer has VIP status",
        "default": false
      },
      "geographic_preference": {
        "type": "string",
        "required": false,
        "description": "Preferred geographic routing region",
        "default": "None"
      },
      "callback_eligible": {
        "type": "boolean",
        "required": false,
        "description": "Whether call is eligible for callback option",
        "default": true
      },
      "skill_weights": {
        "type": "array",
        "items": {
          "type": "number"
        },
        "required": false,
        "description": "Importance weights for different skills (0-1)",
        "default": "None"
      },
      "queue_priorities": {
        "type": "array",
        "items": {
          "type": "number"
        },
        "required": false,
        "description": "Priority weights for different queues (0-1)",
        "default": "None"
      }
    },
    "error_messages": [
      "Invalid call data format: Call data must include ID, priority, category, and customer information.",
      "Unknown routing strategy: Must be one of [load_balance, skill_based, priority_first, shortest_wait].",
      "Invalid system load level: Must be one of [low, medium, high, critical].",
      "Malformed routing rules: Check routing rule syntax and format.",
      "Fallback queue unavailable: Specified fallback queue is not operational.",
      "Weight array mismatch: Skill weights and queue priorities arrays must match available options."
    ],
    "usage": "Provide call_data array, routing_strategy, business_hours status, and system_load. Use optional parameters to customize routing behavior, set fallbacks, and apply business rules.",
    "output_details": {
      "routing_decision": {
        "type": "string",
        "description": "Final routing decision: queue assignment, callback offer, or alternative action"
      },
      "assigned_queue": {
        "type": "string",
        "description": "Queue ID where call was routed"
      },
      "routing_reason": {
        "type": "string",
        "description": "Explanation
