field_name: databases
subfield: Database Schema Design and Modeling
task: Design normalized relational database schemas based on business requirements
tool_description: |-
  ## STEP 1 — Rate task difficulty

  This task is **hard** due to the complexity of translating business requirements into properly normalized database schemas. It requires understanding business domains, identifying entities and relationships, applying normalization rules, handling constraints and dependencies, and ensuring scalability and performance considerations.

  ## STEP 2 — Set a tool budget

  Given the hard difficulty rating, I will target **17 tools** within the 15-20 range to cover the comprehensive workflow from requirements analysis to schema validation and optimization.

  ## STEP 3 — List all tool names with dependencies and affordances

  1. **Business Requirements Parser** - Consumes: raw requirements text → Produces: structured business entities and rules
  2. **Entity Identifier** - Consumes: business requirements → Produces: candidate entities list
  3. **Attribute Extractor** - Consumes: entities and requirements → Produces: entity attributes with data types
  4. **Relationship Mapper** - Consumes: entities → Produces: entity relationships and cardinalities
  5. **Primary Key Generator** - Consumes: entities and attributes → Produces: primary key assignments
  6. **Foreign Key Resolver** - Consumes: entities and relationships → Produces: foreign key constraints
  7. **Normalization Analyzer** - Consumes: table structures → Produces: normalization form analysis
  8. **Functional Dependency Detector** - Consumes: attributes and sample data → Produces: functional dependencies
  9. **Table Structure Generator** - Consumes: normalized entities → Produces: SQL table definitions
  10. **Constraint Validator** - Consumes: schema and business rules → Produces: constraint definitions
  11. **Index Recommender** - Consumes: tables and query patterns → Produces: index suggestions
  12. **Schema Optimizer** - Consumes: initial schema → Produces: optimized schema recommendations
  13. **ERD Generator** - Consumes: entities and relationships → Produces: visual ERD representation
  14. **SQL DDL Exporter** - Consumes: finalized schema → Produces: executable SQL scripts
  15. **Schema Validator** - Consumes: complete schema → Produces: validation report
  16. **Performance Analyzer** - Consumes: schema and usage patterns → Produces: performance metrics
  17. **Documentation Generator** - Consumes: final schema → Produces: comprehensive documentation

  ## STEP 4 — Multi-tool plans

  **Simple Plans:**
  1. **Basic Entity Extraction**: Business Requirements Parser → Entity Identifier → Attribute Extractor (identifies core business objects)
  2. **Quick Schema Generation**: Table Structure Generator → SQL DDL Exporter (creates basic SQL from existing entities)

  **Medium Plans:**
  1. **Standard Normalization**: Entity Identifier → Attribute Extractor → Functional Dependency Detector → Normalization Analyzer → Table Structure Generator (creates normalized tables)
  2. **Relationship Design**: Entity Identifier → Relationship Mapper → Primary Key Generator → Foreign Key Resolver (establishes entity relationships)
  3. **Schema Validation**: Table Structure Generator → Constraint Validator → Schema Validator (ensures schema correctness)

  **Complex Plans:**
  1. **Complete Schema Development**: Business Requirements Parser → Entity Identifier → Attribute Extractor → Relationship Mapper → Primary Key Generator → Foreign Key Resolver → Normalization Analyzer → Table Structure Generator → Constraint Validator → Index Recommender → Schema Optimizer → SQL DDL Exporter
  2. **Full Design with Documentation**: All tools in sequence ending with ERD Generator → Documentation Generator (complete design lifecycle)

  ## STEP 5 — Produce tools

  ```json
  {
    "tool_name": "Business Requirements Parser",
    "tool_description": "Analyzes raw business requirements text to extract structured information about business processes, rules, and data needs for database design.",
    "parameters": {
      "requirements_text": {
        "type": "string",
        "required": true,
        "description": "Raw business requirements document or description text"
      },
      "domain": {
        "type": "string",
        "required": false,
        "default": "general",
        "description": "Business domain context (e.g., finance, healthcare, retail, manufacturing)"
      },
      "parsing_focus": {
        "type": "string",
        "required": false,
        "default": "comprehensive",
        "description": "Parsing focus: comprehensive, entities_only, processes_only, or rules_only"
      }
    },
    "error_messages": [
      "Empty requirements text: Provide non-empty requirements text for analysis.",
      "Unsupported domain: Use a recognized business domain or 'general' for mixed domains.",
      "Invalid parsing focus: Use one of [comprehensive, entities_only, processes_only, rules_only].",
      "Requirements too short: Provide at least 50 characters of meaningful requirements text."
    ],
    "usage": "Provide requirements_text with business needs description. Optionally specify domain and parsing_focus for targeted analysis. Returns structured business information for database design.",
    "output_details": {
      "business_entities": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of identified business entities from requirements"
      },
      "business_processes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of key business processes mentioned"
      },
      "business_rules": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of business rules and constraints identified"
      },
      "data_requirements": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Specific data storage and retrieval requirements"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Entity Identifier",
    "tool_description": "Identifies and categorizes database entities from business requirements, distinguishing between strong entities, weak entities, and associative entities.",
    "parameters": {
      "business_entities": {
        "type": "array",
        "required": true,
        "description": "List of business entities from requirements analysis",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 50
      },
      "business_processes": {
        "type": "array",
        "required": true,
        "description": "List of business processes that involve these entities",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      }
    },
    "error_messages": [
      "Empty entities list: Provide at least one business entity for identification.",
      "Empty processes list: Provide at least one business process for context.",
      "Too many entities: Limit to 50 entities per analysis session.",
      "Invalid entity format: Entities should be meaningful business object names."
    ],
    "usage": "Provide business_entities and business_processes arrays from requirements analysis. Returns categorized entities suitable for database modeling.",
    "output_details": {
      "strong_entities": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Independent entities that can exist on their own"
      },
      "weak_entities": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Entities dependent on other entities for existence"
      },
      "associative_entities": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Entities representing relationships between other entities"
      },
      "entity_priorities": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Entities ranked by business importance and centrality"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Attribute Extractor",
    "tool_description": "Extracts and assigns attributes to database entities, including data type recommendations and attribute properties like nullability and uniqueness.",
    "parameters": {
      "entities": {
        "type": "array",
        "required": true,
        "description": "List of database entities to extract attributes for",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 20
      },
      "business_rules": {
        "type": "array",
        "required": true,
        "description": "Business rules that may define entity attributes",
        "items": {"type": "string"},
        "minItems": 0,
        "maxItems": 50
      },
      "domain_context": {
        "type": "string",
        "required": false,
        "default": "general",
        "description": "Business domain for context-aware attribute suggestion"
      },
      "include_audit_fields": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to include standard audit fields like created_date, modified_date"
      },
      "suggest_data_types": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to suggest appropriate data types for attributes"
      }
    },
    "error_messages": [
      "Empty entities list: Provide at least one entity for attribute extraction.",
      "Invalid domain context: Use a recognized business domain or 'general'.",
      "Too many business rules: Limit business rules to 50 items for processing.",
      "Entity name format error: Entity names should be valid identifiers without special characters."
    ],
    "usage": "Provide entities list and business_rules array. Optionally set domain_context, include_audit_fields, and suggest_data_types. Returns comprehensive attribute definitions for each entity.",
    "output_details": {
      "entity_attributes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Formatted list of entity.attribute definitions"
      },
      "attribute_data_types": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Suggested data types for each attribute"
      },
      "nullable_attributes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Attributes that can accept null values"
      },
      "unique_attributes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Attributes that should have unique constraints"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Relationship Mapper",
    "tool_description": "Maps relationships between entities, determining cardinalities (one-to-one, one-to-many, many-to-many) and relationship types.",
    "parameters": {
      "entities": {
        "type": "array",
        "required": true,
        "description": "List of entities to map relationships between",
        "items": {"type": "string"},
        "minItems": 2,
        "maxItems": 25
      },
      "business_processes": {
        "type": "array",
        "required": true,
        "description": "Business processes that indicate entity interactions",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "relationship_hints": {
        "type": "array",
        "required": false,
        "default": null,
        "description": "Explicit relationship hints in format 'EntityA-relationship-EntityB'",
        "items": {"type": "string"}
      }
    },
    "error_messages": [
      "Insufficient entities: Provide at least 2 entities to map relationships.",
      "Empty business processes: Provide at least one business process for relationship context.",
      "Too many entities: Limit to 25 entities for manageable relationship mapping.",
      "Invalid relationship hint format: Use format 'EntityA-relationship-EntityB' for hints."
    ],
    "usage": "Provide entities and business_processes arrays. Optionally include relationship_hints for explicit relationships. Returns comprehensive relationship mappings with cardinalities.",
    "output_details": {
      "relationships": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Identified relationships in format 'EntityA-EntityB'"
      },
      "cardinalities": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Cardinality for each relationship (1:1, 1:M, M:N)"
      },
      "relationship_types": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Relationship types (identifying, non-identifying, associative)"
      },
      "junction_tables_needed": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Many-to-many relationships requiring junction tables"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Primary Key Generator",
    "tool_description": "Generates appropriate primary keys for database entities, choosing between natural keys, surrogate keys, and composite keys based on entity characteristics.",
    "parameters": {
      "entities": {
        "type": "array",
        "required": true,
        "description": "List of entities needing primary key assignment",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "entity_attributes": {
        "type": "array",
        "required": true,
        "description": "Attributes for each entity in format 'entity.attribute'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 200
      },
      "prefer_surrogate_keys": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to prefer surrogate keys over natural keys"
      },
      "key_naming_convention": {
        "type": "string",
        "required": false,
        "default": "id_suffix",
        "description": "Primary key naming convention: id_suffix, pk_prefix, or entity_name"
      }
    },
    "error_messages": [
      "Empty entities list: Provide at least one entity for primary key generation.",
      "Mismatched attributes: Ensure entity_attributes correspond to provided entities.",
      "Invalid naming convention: Use one of [id_suffix, pk_prefix, entity_name].",
      "Insufficient attributes: Each entity must have at least one attribute for key generation."
    ],
    "usage": "Provide entities and their entity_attributes arrays. Optionally set prefer_surrogate_keys and key_naming_convention. Returns primary key assignments for each entity.",
    "output_details": {
      "primary_keys": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Primary key assignments in format 'entity:key_column'"
      },
      "key_types": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Type of each primary key (natural, surrogate, composite)"
      },
      "key_data_types": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Recommended data types for primary key columns"
      },
      "auto_increment_keys": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Keys that should use auto-increment functionality"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Foreign Key Resolver",
    "tool_description": "Resolves and defines foreign key constraints between related entities based on identified relationships and primary keys.",
    "parameters": {
      "relationships": {
        "type": "array",
        "required": true,
        "description": "Entity relationships in format 'ParentEntity-ChildEntity'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 50
      },
      "primary_keys": {
        "type": "array",
        "required": true,
        "description": "Primary key assignments in format 'entity:key_column'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "cardinalities": {
        "type": "array",
        "required": true,
        "description": "Relationship cardinalities (1:1, 1:M, M:N)",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 50
      },
      "cascade_delete": {
        "type": "boolean",
        "required": false,
        "default": false,
        "description": "Whether to enable cascade delete by default"
      },
      "cascade_update": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to enable cascade update by default"
      }
    },
    "error_messages": [
      "Mismatched array lengths: Ensure relationships and cardinalities arrays have same length.",
      "Missing primary keys: All entities in relationships must have defined primary keys.",
      "Invalid relationship format: Use format 'ParentEntity-ChildEntity' for relationships.",
      "Invalid cardinality: Use one of [1:1, 1:M, M:1, M:N] for cardinalities."
    ],
    "usage": "Provide relationships, primary_keys, and cardinalities arrays with matching indices. Optionally set cascade_delete and cascade_update preferences. Returns complete foreign key constraint definitions.",
    "output_details": {
      "foreign_keys": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Foreign key definitions in format 'child_table.fk_column->parent_table.pk_column'"
      },
      "constraint_names": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Generated constraint names for each foreign key"
      },
      "referential_actions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Referential integrity actions (CASCADE, RESTRICT, SET NULL)"
      },
      "junction_table_fks": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Foreign keys needed in junction tables for M:N relationships"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Normalization Analyzer",
    "tool_description": "Analyzes table structures for normalization forms (1NF, 2NF, 3NF, BCNF) and identifies normalization violations with recommended corrections.",
    "parameters": {
      "table_structures": {
        "type": "array",
        "required": true,
        "description": "Table definitions with columns in format 'table:column1,column2,...'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 25
      },
      "functional_dependencies": {
        "type": "array",
        "required": true,
        "description": "Known functional dependencies in format 'table:column1->column2'",
        "items": {"type": "string"},
        "minItems": 0,
        "maxItems": 100
      },
      "target_normal_form": {
        "type": "string",
        "required": false,
        "default": "3NF",
        "description": "Target normalization level: 1NF, 2NF, 3NF, or BCNF"
      },
      "allow_denormalization": {
        "type": "boolean",
        "required": false,
        "default": false,
        "description": "Whether to allow strategic denormalization for performance"
      },
      "preserve_existing_structure": {
        "type": "boolean",
        "required": false,
        "default": false,
        "description": "Whether to preserve existing table structure where possible"
      }
    },
    "error_messages": [
      "Invalid table structure format: Use format 'table_name:column1,column2,...' for table definitions.",
      "Invalid dependency format: Use format 'table:column1->column2' for functional dependencies.",
      "Unsupported normal form: Use one of [1NF, 2NF, 3NF, BCNF] as target_normal_form.",
      "Empty table structures: Provide at least one table structure for analysis."
    ],
    "usage": "Provide table_structures and functional_dependencies arrays. Optionally set target_normal_form, allow_denormalization, and preserve_existing_structure. Returns normalization analysis and recommendations.",
    "output_details": {
      "current_normal_forms": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Current normalization level for each table"
      },
      "normalization_violations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Identified normalization violations and their descriptions"
      },
      "recommended_changes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Specific recommendations to achieve target normalization"
      },
      "new_tables_needed": {
        "type": "array",
        "items": {"type": "string"},
        "description": "New tables needed to resolve normalization issues"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Functional Dependency Detector",
    "tool_description": "Detects functional dependencies between attributes within entities based on business rules and sample data patterns.",
    "parameters": {
      "entity_attributes": {
        "type": "array",
        "required": true,
        "description": "Entity attributes in format 'entity.attribute'",
        "items": {"type": "string"},
        "minItems": 2,
        "maxItems": 100
      },
      "business_rules": {
        "type": "array",
        "required": true,
        "description": "Business rules that may imply functional dependencies",
        "items": {"type": "string"},
        "minItems": 0,
        "maxItems": 50
      },
      "sample_data_hints": {
        "type": "array",
        "required": false,
        "default": null,
        "description": "Sample data patterns that suggest dependencies",
        "items": {"type": "string"}
      },
      "confidence_threshold": {
        "type": "number",
        "required": false,
        "default": 0.8,
        "description": "Minimum confidence level for dependency detection (0.5-1.0)"
      }
    },
    "error_messages": [
      "Insufficient attributes: Provide at least 2 attributes for dependency analysis.",
      "Invalid confidence threshold: Use a value between 0.5 and 1.0 for confidence_threshold.",
      "Too many attributes: Limit to 100 attributes for manageable analysis.",
      "Invalid attribute format: Use format 'entity.attribute' for attribute specifications."
    ],
    "usage": "Provide entity_attributes and business_rules arrays. Optionally include sample_data_hints and set confidence_threshold. Returns detected functional dependencies with confidence scores.",
    "output_details": {
      "functional_dependencies": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Detected dependencies in format 'entity:attributeA->attributeB'"
      },
      "dependency_confidence": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Confidence scores for each detected dependency"
      },
      "transitive_dependencies": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Transitive dependencies that may cause normalization issues"
      },
      "partial_dependencies": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Partial dependencies on composite keys"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Table Structure Generator",
    "tool_description": "Generates complete table structures with columns, data types, constraints, and indexes based on normalized entity designs.",
    "parameters": {
      "entities": {
        "type": "array",
        "required": true,
        "description": "List of entities to generate table structures for",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "entity_attributes": {
        "type": "array",
        "required": true,
        "description": "Attributes for entities in format 'entity.attribute:datatype'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 200
      },
      "primary_keys": {
        "type": "array",
        "required": true,
        "description": "Primary key assignments in format 'entity:key_column'",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "foreign_keys": {
        "type": "array",
        "required": false,
        "default": null,
        "description": "Foreign key definitions",
        "items": {"type": "string"}
      },
      "table_naming_convention": {
        "type": "string",
        "required": false,
        "default": "singular",
        "description": "Table naming style: singular, plural, or prefixed"
      },
      "column_naming_convention": {
        "type": "string",
        "required": false,
        "default": "snake_case",
        "description": "Column naming style: snake_case, camelCase, or PascalCase"
      },
      "include_timestamps": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to include created_at and updated_at columns"
      },
      "database_engine": {
        "type": "string",
        "required": false,
        "default": "mysql",
        "description": "Target database engine: mysql, postgresql, sqlite, or mssql"
      }
    },
    "error_messages": [
      "Mismatched entities and attributes: Ensure all entities have corresponding attributes defined.",
      "Missing primary keys: All entities must have primary key assignments.",
      "Invalid naming convention: Use supported naming conventions for tables and columns.",
      "Unsupported database engine: Use one of [mysql, postgresql, sqlite, mssql].",
      "Invalid attribute format: Use format 'entity.attribute:datatype' for attribute definitions."
    ],
    "usage": "Provide entities, entity_attributes, and primary_keys arrays. Optionally specify foreign_keys, naming conventions, include_timestamps, and database_engine. Returns complete table structure definitions.",
    "output_details": {
      "table_definitions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Complete table structure definitions with all columns and constraints"
      },
      "table_names": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Generated table names following naming convention"
      },
      "column_specifications": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Detailed column specifications with data types and constraints"
      },
      "constraint_definitions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "All constraint definitions including primary keys, foreign keys, and checks"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Constraint Validator",
    "tool_description": "Validates and defines database constraints including check constraints, unique constraints, and business rule constraints based on requirements.",
    "parameters": {
      "table_definitions": {
        "type": "array",
        "required": true,
        "description": "Table structure definitions to validate constraints for",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "business_rules": {
        "type": "array",
        "required": true,
        "description": "Business rules that translate to database constraints",
        "items": {"type": "string"},
        "minItems": 0,
        "maxItems": 50
      },
      "validate_referential_integrity": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to validate foreign key referential integrity"
      },
      "enforce_business_rules": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to create constraints for business rules"
      },
      "constraint_naming_style": {
        "type": "string",
        "required": false,
        "default": "descriptive",
        "description": "Constraint naming style: descriptive, abbreviated, or systematic"
      }
    },
    "error_messages": [
      "Empty table definitions: Provide at least one table definition for constraint validation.",
      "Invalid constraint naming style: Use one of [descriptive, abbreviated, systematic].",
      "Conflicting constraints: Some business rules create conflicting constraint requirements.",
      "Invalid table definition format: Ensure table definitions are properly formatted."
    ],
    "usage": "Provide table_definitions and business_rules arrays. Optionally set validation preferences and constraint_naming_style. Returns comprehensive constraint definitions and validation results.",
    "output_details": {
      "check_constraints": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Check constraint definitions derived from business rules"
      },
      "unique_constraints": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Unique constraint definitions for data integrity"
      },
      "validation_errors": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Identified constraint violations or conflicts"
      },
      "constraint_recommendations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Recommended additional constraints for data quality"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Recommender",
    "tool_description": "Recommends database indexes based on table structures, expected query patterns, and performance requirements.",
    "parameters": {
      "table_definitions": {
        "type": "array",
        "required": true,
        "description": "Table structure definitions to analyze for index recommendations",
        "items": {"type": "string"},
        "minItems": 1,
        "maxItems": 30
      },
      "expected_query_patterns": {
        "type": "array",
        "required": false,
        "default": null,
        "description": "Expected SQL query patterns or WHERE clause conditions",
        "items": {"type": "string"}
      },
      "performance_priority": {
        "type": "string",
        "required": false,
        "default": "balanced",
        "description": "Performance priority: read_heavy, write_heavy, or balanced"
      },
      "storage_constraints": {
        "type": "boolean",
        "required": false,
        "default": false,
        "description": "Whether to consider storage space constraints in recommendations"
      }
    },
    "error_messages": [
      "Empty table definitions: Provide at least one table definition for index analysis.",
      "Invalid performance priority: Use one of [read_heavy, write_heavy, balanced].",
      "Too many tables: Limit to 30 tables for manageable index analysis.",
      "Malformed query patterns: Ensure query patterns are valid SQL-like expressions."
    ],
    "usage": "Provide table_definitions array and optionally expected_query_patterns. Set performance_priority and storage_constraints based on requirements. Returns optimized index recommendations.",
    "output_details": {
      "recommended_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Recommended index definitions with column specifications"
      },
      "index_types": {
        "type": "array",
        "items": {"type": "string"},
        "
