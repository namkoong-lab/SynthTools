field_name: databases
subfield: Query Optimization and Performance Tuning
task: Query execution plan analysis and visualization
tool_description: |-
  **STEP 1 — Rate task difficulty**

  This task is **hard** due to the complexity of database internals, the need to parse and interpret complex execution plans across different database systems, the requirement for deep understanding of optimization strategies, and the high impact of incorrect analysis on production system performance.

  **STEP 2 — Set a tool budget**

  Given the hard difficulty rating, I'm targeting **17 tools** to cover the breadth of query plan analysis, optimization recommendations, visualization, and performance monitoring capabilities.

  **STEP 3 — List all tool names and dependencies**

  Tools and their data flow:
  1. **Query Plan Extractor** - Consumes: SQL queries → Produces: Raw execution plans
  2. **Plan Parser** - Consumes: Raw execution plans → Produces: Structured plan data
  3. **Cost Analyzer** - Consumes: Structured plan data → Produces: Cost breakdowns
  4. **Index Usage Analyzer** - Consumes: Structured plan data → Produces: Index usage reports
  5. **Join Strategy Evaluator** - Consumes: Structured plan data → Produces: Join analysis
  6. **Table Scan Detector** - Consumes: Structured plan data → Produces: Scan reports
  7. **Cardinality Estimator** - Consumes: Query + table stats → Produces: Cardinality estimates
  8. **Plan Visualizer** - Consumes: Structured plan data → Produces: Visual representations
  9. **Performance Bottleneck Identifier** - Consumes: Plan data + metrics → Produces: Bottleneck reports
  10. **Query Rewrite Suggester** - Consumes: Query + plan data → Produces: Optimization suggestions
  11. **Index Recommendation Engine** - Consumes: Query patterns → Produces: Index recommendations
  12. **Statistics Analyzer** - Consumes: Table metadata → Produces: Statistics reports
  13. **Parallel Execution Analyzer** - Consumes: Plan data → Produces: Parallelism analysis
  14. **Memory Usage Estimator** - Consumes: Plan data → Produces: Memory estimates
  15. **Plan Comparison Tool** - Consumes: Multiple plans → Produces: Comparison reports
  16. **Historical Performance Tracker** - Consumes: Query metrics over time → Produces: Trend analysis
  17. **Optimization Report Generator** - Consumes: Analysis outputs → Produces: Comprehensive reports

  **STEP 4 — Multi-tool plans**

  **Simple Plans:**
  1. **Basic Plan Analysis** (Query Plan Extractor → Plan Parser → Plan Visualizer): Extract and visualize a single query's execution plan
  2. **Quick Index Check** (Query Plan Extractor → Plan Parser → Index Usage Analyzer): Identify missing or unused indexes in a query

  **Medium Plans:**
  1. **Cost Analysis Workflow** (Query Plan Extractor → Plan Parser → Cost Analyzer → Performance Bottleneck Identifier → Optimization Report Generator): Comprehensive cost analysis with optimization recommendations
  2. **Join Optimization Flow** (Query Plan Extractor → Plan Parser → Join Strategy Evaluator → Query Rewrite Suggester): Analyze and optimize join operations

  **Complex Plans:**
  1. **Complete Performance Audit** (Query Plan Extractor → Plan Parser → Cost Analyzer → Join Strategy Evaluator → Table Scan Detector → Index Usage Analyzer → Performance Bottleneck Identifier → Query Rewrite Suggester → Index Recommendation Engine → Optimization Report Generator): Full query optimization pipeline
  2. **Comparative Performance Analysis** (Multiple queries through Query Plan Extractor → Plan Parser → Plan Comparison Tool → Historical Performance Tracker → Memory Usage Estimator → Statistics Analyzer → Optimization Report Generator): Compare multiple query versions over time with resource analysis

  **STEP 5 — Produce tools**

  ```json
  {
    "tool_name": "Query Plan Extractor",
    "tool_description": "Extracts execution plans from database systems for given SQL queries, supporting multiple database engines and plan output formats.",
    "parameters": {
      "sql_query": {
        "type": "string",
        "required": true,
        "description": "The SQL query to extract execution plan for"
      },
      "database_type": {
        "type": "string",
        "required": true,
        "description": "Database system type (postgresql, mysql, oracle, sqlserver, sqlite)"
      },
      "plan_format": {
        "type": "string",
        "required": false,
        "default": "text",
        "description": "Output format for execution plan (text, xml, json)"
      }
    },
    "error_messages": [
      "Invalid SQL syntax: The provided SQL query contains syntax errors. Check query structure and keywords.",
      "Unsupported database type: Use one of [postgresql, mysql, oracle, sqlserver, sqlite].",
      "Connection failed: Unable to connect to database. Verify connection parameters.",
      "Query execution failed: Query failed during execution. Check for runtime errors or permission issues.",
      "Invalid plan format: Use one of [text, xml, json]."
    ],
    "usage": "Provide a valid SQL query and specify the database type. Optionally set the plan format. The tool will extract and return the execution plan in the requested format.",
    "output_details": {
      "execution_plan": {
        "type": "string",
        "description": "Raw execution plan output from the database"
      },
      "query_hash": {
        "type": "string",
        "description": "Unique hash identifier for the query"
      },
      "extraction_timestamp": {
        "type": "string",
        "description": "Timestamp when plan was extracted"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Plan Parser",
    "tool_description": "Parses raw execution plans into structured data format, extracting operators, costs, cardinalities, and relationships for further analysis.",
    "parameters": {
      "raw_plan": {
        "type": "string",
        "required": true,
        "description": "Raw execution plan text from database"
      },
      "database_type": {
        "type": "string",
        "required": true,
        "description": "Database system type (postgresql, mysql, oracle, sqlserver, sqlite)"
      },
      "plan_format": {
        "type": "string",
        "required": true,
        "description": "Format of the raw plan (text, xml, json)"
      },
      "include_statistics": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to extract detailed statistics from plan"
      }
    },
    "error_messages": [
      "Plan parsing failed: Raw plan format is corrupted or unreadable. Ensure plan was extracted correctly.",
      "Unsupported database type: Use one of [postgresql, mysql, oracle, sqlserver, sqlite].",
      "Format mismatch: Plan format parameter doesn't match actual raw plan format.",
      "Missing plan data: Raw plan appears to be empty or incomplete."
    ],
    "usage": "Provide the raw execution plan, database type, and plan format. The tool will parse the plan into a structured format with operators, costs, and relationships.",
    "output_details": {
      "operators": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of execution plan operators"
      },
      "total_cost": {
        "type": "number",
        "description": "Total estimated cost of query execution"
      },
      "estimated_rows": {
        "type": "integer",
        "description": "Estimated number of rows to be processed"
      },
      "execution_time_estimate": {
        "type": "number",
        "description": "Estimated execution time in milliseconds"
      },
      "plan_structure": {
        "type": "string",
        "description": "Hierarchical structure of the execution plan"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Cost Analyzer",
    "tool_description": "Analyzes execution plan costs, breaking down resource consumption by operation type and identifying expensive operations within the query plan.",
    "parameters": {
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "cost_threshold": {
        "type": "number",
        "required": false,
        "default": 10.0,
        "description": "Minimum cost percentage to flag as expensive operation"
      },
      "analysis_depth": {
        "type": "string",
        "required": false,
        "default": "detailed",
        "description": "Level of analysis (basic, detailed, comprehensive)"
      },
      "include_io_costs": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to include I/O cost analysis"
      },
      "include_cpu_costs": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to include CPU cost analysis"
      }
    },
    "error_messages": [
      "Invalid parsed plan: Structured plan data is malformed or incomplete. Re-run Plan Parser.",
      "Cost threshold out of range: Threshold must be between 0.1 and 100.0.",
      "Invalid analysis depth: Use one of [basic, detailed, comprehensive].",
      "Missing cost data: Plan does not contain sufficient cost information for analysis."
    ],
    "usage": "Provide structured plan data and set cost thresholds and analysis preferences. The tool will analyze costs and identify expensive operations.",
    "output_details": {
      "total_cost_breakdown": {
        "type": "string",
        "description": "Detailed breakdown of total query cost"
      },
      "expensive_operations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of operations exceeding cost threshold"
      },
      "io_cost_percentage": {
        "type": "number",
        "description": "Percentage of total cost attributed to I/O operations"
      },
      "cpu_cost_percentage": {
        "type": "number",
        "description": "Percentage of total cost attributed to CPU operations"
      },
      "cost_distribution": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Cost distribution across different operation types"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Usage Analyzer",
    "tool_description": "Analyzes index usage patterns in execution plans, identifying unused indexes, missing indexes, and inefficient index selections.",
    "parameters": {
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "table_schemas": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Schema information for tables in the query"
      },
      "existing_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "List of existing indexes on queried tables"
      }
    },
    "error_messages": [
      "Invalid parsed plan: Plan data is malformed or missing index information.",
      "Missing table schemas: Provide complete schema information for all tables referenced in query.",
      "Invalid index definitions: One or more index definitions are malformed.",
      "Schema mismatch: Table schemas don't match tables referenced in execution plan."
    ],
    "usage": "Provide structured plan data, table schemas, and existing index information. The tool will analyze index usage and identify optimization opportunities.",
    "output_details": {
      "used_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Indexes actually used in the execution plan"
      },
      "unused_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Available indexes not used in execution"
      },
      "index_efficiency_score": {
        "type": "number",
        "description": "Overall index usage efficiency score (0-100)"
      },
      "missing_index_suggestions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Suggested indexes that could improve performance"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Join Strategy Evaluator",
    "tool_description": "Evaluates join operations in execution plans, analyzing join algorithms, order, and efficiency to identify optimization opportunities.",
    "parameters": {
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "table_statistics": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Statistical information about tables involved in joins"
      },
      "join_threshold": {
        "type": "number",
        "required": false,
        "default": 1000000,
        "description": "Row count threshold for flagging large joins"
      },
      "analyze_join_order": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to analyze join order optimization"
      },
      "suggest_alternatives": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to suggest alternative join strategies"
      }
    },
    "error_messages": [
      "No joins found: Execution plan does not contain any join operations to analyze.",
      "Invalid table statistics: Table statistics format is incorrect or incomplete.",
      "Join threshold out of range: Threshold must be a positive integer greater than 0.",
      "Missing join information: Plan lacks sufficient detail about join operations."
    ],
    "usage": "Provide structured plan data and table statistics. Configure thresholds and analysis options. The tool will evaluate join strategies and suggest improvements.",
    "output_details": {
      "join_operations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "List of all join operations found in the plan"
      },
      "join_algorithms": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Join algorithms used (nested loop, hash join, merge join, etc.)"
      },
      "join_efficiency_score": {
        "type": "number",
        "description": "Overall join efficiency rating (0-100)"
      },
      "optimization_suggestions": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Specific suggestions for improving join performance"
      },
      "estimated_join_costs": {
        "type": "array",
        "items": {"type": "number"},
        "description": "Cost estimates for each join operation"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Table Scan Detector",
    "tool_description": "Identifies table scan operations in execution plans and evaluates whether they can be optimized with indexes or query restructuring.",
    "parameters": {
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "scan_cost_threshold": {
        "type": "number",
        "required": false,
        "default": 100.0,
        "description": "Cost threshold above which scans are flagged as expensive"
      }
    },
    "error_messages": [
      "Invalid parsed plan: Plan data is malformed or missing scan operation details.",
      "Cost threshold invalid: Threshold must be a positive number greater than 0.",
      "No scan operations found: Execution plan does not contain any table scan operations."
    ],
    "usage": "Provide structured plan data and optionally set a cost threshold for flagging expensive scans. The tool will identify and analyze table scan operations.",
    "output_details": {
      "full_table_scans": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Tables subjected to full table scans"
      },
      "index_scans": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Index scan operations identified"
      },
      "expensive_scans": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Scan operations exceeding cost threshold"
      },
      "scan_optimization_potential": {
        "type": "boolean",
        "description": "Whether scan operations have optimization potential"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Cardinality Estimator",
    "tool_description": "Estimates row counts and data distribution for query operations, comparing database estimates with statistical projections to identify estimation errors.",
    "parameters": {
      "sql_query": {
        "type": "string",
        "required": true,
        "description": "SQL query to analyze for cardinality estimation"
      },
      "table_schemas": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Schema definitions for all tables in the query"
      },
      "table_statistics": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Statistical information about table contents"
      },
      "estimation_method": {
        "type": "string",
        "required": false,
        "default": "histogram",
        "description": "Method for cardinality estimation (histogram, sampling, mathematical)"
      },
      "confidence_level": {
        "type": "number",
        "required": false,
        "default": 95.0,
        "description": "Confidence level for estimates (50-99)"
      },
      "include_correlations": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to consider column correlations in estimation"
      }
    },
    "error_messages": [
      "Invalid SQL query: Query syntax is incorrect or contains unsupported operations.",
      "Missing table statistics: Required statistical information is incomplete or missing.",
      "Invalid estimation method: Use one of [histogram, sampling, mathematical].",
      "Confidence level out of range: Must be between 50 and 99.",
      "Schema mismatch: Table schemas don't match query references."
    ],
    "usage": "Provide SQL query, table schemas, and statistics. Configure estimation method and parameters. The tool will generate cardinality estimates and accuracy assessments.",
    "output_details": {
      "estimated_cardinalities": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Row count estimates for each operation"
      },
      "estimation_accuracy": {
        "type": "number",
        "description": "Estimated accuracy of cardinality predictions (0-100)"
      },
      "database_estimates": {
        "type": "array",
        "items": {"type": "integer"},
        "description": "Database's own cardinality estimates"
      },
      "estimation_errors": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Identified estimation errors and their impact"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Plan Visualizer",
    "tool_description": "Creates visual representations of execution plans including tree diagrams, cost flow charts, and interactive plan explorers for better understanding of query execution.",
    "parameters": {
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "visualization_type": {
        "type": "string",
        "required": true,
        "description": "Type of visualization (tree, flowchart, timeline, heatmap)"
      },
      "include_costs": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to include cost information in visualization"
      },
      "include_cardinalities": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to include row count estimates in visualization"
      },
      "color_scheme": {
        "type": "string",
        "required": false,
        "default": "default",
        "description": "Color scheme for visualization (default, colorblind, monochrome)"
      }
    },
    "error_messages": [
      "Invalid parsed plan: Plan data is malformed or incomplete for visualization.",
      "Unsupported visualization type: Use one of [tree, flowchart, timeline, heatmap].",
      "Invalid color scheme: Use one of [default, colorblind, monochrome].",
      "Visualization generation failed: Unable to create visualization from provided data."
    ],
    "usage": "Provide structured plan data and select visualization type and options. The tool will generate a visual representation of the execution plan.",
    "output_details": {
      "visualization_data": {
        "type": "string",
        "description": "Generated visualization in requested format"
      },
      "legend": {
        "type": "string",
        "description": "Legend explaining visualization symbols and colors"
      },
      "summary_metrics": {
        "type": "string",
        "description": "Key metrics displayed in the visualization"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Performance Bottleneck Identifier",
    "tool_description": "Identifies performance bottlenecks in execution plans by analyzing resource consumption patterns, wait times, and operation dependencies.",
    "parameters": {
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "cost_analysis": {
        "type": "string",
        "required": true,
        "description": "Cost breakdown from Cost Analyzer"
      },
      "runtime_metrics": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "default": "None",
        "description": "Actual runtime performance metrics if available"
      },
      "bottleneck_threshold": {
        "type": "number",
        "required": false,
        "default": 20.0,
        "description": "Percentage threshold for identifying bottleneck operations"
      },
      "resource_focus": {
        "type": "string",
        "required": false,
        "default": "all",
        "description": "Resource type to focus on (cpu, io, memory, network, all)"
      }
    },
    "error_messages": [
      "Invalid plan data: Parsed plan or cost analysis data is malformed.",
      "Bottleneck threshold invalid: Must be between 1.0 and 50.0.",
      "Invalid resource focus: Use one of [cpu, io, memory, network, all].",
      "Insufficient data: Not enough information to identify bottlenecks reliably."
    ],
    "usage": "Provide plan and cost analysis data, optionally include runtime metrics. Configure threshold and resource focus. The tool will identify performance bottlenecks.",
    "output_details": {
      "primary_bottlenecks": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Main bottleneck operations identified"
      },
      "bottleneck_severity": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Severity rating for each bottleneck (low, medium, high, critical)"
      },
      "resource_constraints": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Resource constraints contributing to bottlenecks"
      },
      "impact_analysis": {
        "type": "string",
        "description": "Analysis of bottleneck impact on overall performance"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Query Rewrite Suggester",
    "tool_description": "Analyzes queries and execution plans to suggest query rewrites, restructuring, and alternative formulations that could improve performance.",
    "parameters": {
      "original_query": {
        "type": "string",
        "required": true,
        "description": "Original SQL query to optimize"
      },
      "parsed_plan": {
        "type": "string",
        "required": true,
        "description": "Structured plan data from Plan Parser"
      },
      "bottleneck_analysis": {
        "type": "string",
        "required": true,
        "description": "Bottleneck identification results"
      },
      "database_type": {
        "type": "string",
        "required": true,
        "description": "Database system type for syntax-specific suggestions"
      },
      "suggestion_types": {
        "type": "array",
        "items": {"type": "string"},
        "required": false,
        "default": ["all"],
        "description": "Types of suggestions to generate (subquery, join, predicate, all)"
      },
      "preserve_semantics": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to preserve exact query semantics"
      },
      "aggressiveness": {
        "type": "string",
        "required": false,
        "default": "moderate",
        "description": "Optimization aggressiveness level (conservative, moderate, aggressive)"
      }
    },
    "error_messages": [
      "Invalid original query: SQL query syntax is incorrect or unparseable.",
      "Missing analysis data: Required plan or bottleneck analysis data is missing.",
      "Unsupported database type: Database type not supported for rewrite suggestions.",
      "Invalid suggestion types: Use valid suggestion type combinations.",
      "Invalid aggressiveness level: Use one of [conservative, moderate, aggressive]."
    ],
    "usage": "Provide original query, plan data, and bottleneck analysis. Configure suggestion preferences. The tool will generate optimized query alternatives.",
    "output_details": {
      "suggested_rewrites": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Alternative query formulations"
      },
      "optimization_rationale": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Explanation for each suggested rewrite"
      },
      "expected_improvement": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Expected performance improvement for each suggestion"
      },
      "risk_assessment": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Risk level for each suggested rewrite"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Index Recommendation Engine",
    "tool_description": "Analyzes query patterns and execution plans to recommend optimal index creation, modification, or removal strategies for improved performance.",
    "parameters": {
      "query_patterns": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "SQL queries or query patterns to analyze"
      },
      "existing_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Current index definitions on relevant tables"
      },
      "table_schemas": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Schema information for analyzed tables"
      },
      "workload_frequency": {
        "type": "array",
        "items": {"type": "number"},
        "required": false,
        "default": "None",
        "description": "Execution frequency for each query pattern"
      },
      "storage_constraints": {
        "type": "number",
        "required": false,
        "default": "None",
        "description": "Maximum additional storage allowed for new indexes (MB)"
      },
      "maintenance_tolerance": {
        "type": "string",
        "required": false,
        "default": "medium",
        "description": "Tolerance for index maintenance overhead (low, medium, high)"
      }
    },
    "error_messages": [
      "Invalid query patterns: One or more query patterns contain syntax errors.",
      "Incomplete schema information: Table schemas are missing or incomplete.",
      "Index definition errors: Existing index definitions are malformed.",
      "Frequency mismatch: Workload frequency array length doesn't match query pattern count.",
      "Invalid maintenance tolerance: Use one of [low, medium, high]."
    ],
    "usage": "Provide query patterns, existing indexes, and table schemas. Optionally specify workload frequency and constraints. The tool will recommend index optimizations.",
    "output_details": {
      "recommended_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "New indexes recommended for creation"
      },
      "redundant_indexes": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Existing indexes that can be removed"
      },
      "index_modifications": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Existing indexes that should be modified"
      },
      "impact_estimates": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Expected performance impact of each recommendation"
      },
      "implementation_priority": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Priority level for each recommendation (high, medium, low)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Statistics Analyzer",
    "tool_description": "Analyzes table and column statistics to identify outdated statistics, missing histograms, and statistical anomalies that affect query optimization.",
    "parameters": {
      "table_names": {
        "type": "array",
        "items": {"type": "string"},
        "required": true,
        "description": "Names of tables to analyze statistics for"
      },
      "database_type": {
        "type": "string",
        "required": true,
        "description": "Database system type for statistics format"
      },
      "statistics_age_threshold": {
        "type": "integer",
        "required": false,
        "default": 7,
        "description": "Age threshold in days for flagging outdated statistics"
      },
      "include_column_stats": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to analyze column-level statistics"
      },
      "include_histograms": {
        "type": "boolean",
        "required": false,
        "default": true,
        "description": "Whether to analyze histogram data"
      }
    },
    "error_messages": [
      "Table not found: One or more specified tables do not exist in the database.",
      "Insufficient permissions: Unable to access statistics for specified tables.",
      "Invalid age threshold: Threshold must be a positive integer between 1 and 365.",
      "Statistics unavailable: No statistics found for one or more tables."
    ],
    "usage": "Provide table names and database type. Configure analysis options and age thresholds. The tool will analyze table statistics and identify issues.",
    "output_details": {
      "outdated_statistics": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Tables with outdated statistics requiring updates"
      },
      "missing_statistics": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Tables or columns lacking statistical information"
      },
      "statistics_quality_score": {
        "type": "number",
        "description": "Overall quality score for table statistics (0-100)"
      },
      "update_recommendations": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Specific
