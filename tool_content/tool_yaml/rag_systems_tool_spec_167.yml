field_name: rag_systems
subfield: text_chunking_and_segmentation
task: Fixed-size chunking with configurable overlap for uniform processing
tool_description: "**STEP 1 — Rate task difficulty**\n\nThis task involves implementing fixed-size text chunking with configurable overlap, which is a medium difficulty task. It requires handling various text formats, managing overlap calculations, preserving document boundaries, and ensuring consistent chunk sizes while dealing with edge cases like very short documents or unusual overlap ratios.\n\n**STEP 2 — Set a tool budget**\n\nBased on medium difficulty, I'll target 12 tools to cover the various aspects of text chunking: input validation, preprocessing, boundary detection, chunking algorithms, overlap management, metadata handling, quality control, and output formatting.\n\n**STEP 3 — List all tool names with dependencies and affordances**\n\n1. **Text Format Detector** - Consumes: raw text → Produces: format type, encoding info\n2. **Document Preprocessor** - Consumes: raw text, format type → Produces: cleaned text, structure info\n3. **Boundary Analyzer** - Consumes: text, boundary rules → Produces: boundary positions, segment info\n4. **Chunk Size Calculator** - Consumes: text length, target size, overlap → Produces: optimal chunk parameters\n5. **Fixed Size Chunker** - Consumes: text, chunk size, positions → Produces: text chunks\n6. **Overlap Manager** - Consumes: chunks, overlap config → Produces: chunks with overlap\n7. **Metadata Extractor** - Consumes: original text, chunks → Produces: chunk metadata\n8. **Chunk Validator** - Consumes: chunks, validation rules → Produces: validation results, corrections\n9. **Content Preservor** - Consumes: chunks, original structure → Produces: structure-aware chunks\n10. **Quality Assessor** - Consumes: chunks, quality metrics → Produces: quality scores, recommendations\n11. **Chunk Merger** - Consumes: multiple chunk sets → Produces: merged chunk collection\n12. **Output Formatter** - Consumes: chunks, metadata → Produces: formatted output\n\n**STEP 4 — Multi-tool plans**\n\n**Simple Plans:**\n1. Basic chunking: Text Format Detector → Document Preprocessor → Fixed Size Chunker → Output Formatter\n2. Quality check: Fixed Size Chunker → Chunk Validator → Quality Assessor → Output Formatter\n\n**Medium Plans:**\n1. Standard workflow: Text Format Detector → Document Preprocessor → Chunk Size Calculator → Fixed Size Chunker → Overlap Manager → Output Formatter\n2. Structure-aware chunking: Boundary Analyzer → Content Preservor → Fixed Size Chunker → Metadata Extractor → Output Formatter\n\n**Complex Plans:**\n1. Full pipeline: Text Format Detector → Document Preprocessor → Boundary Analyzer → Chunk Size Calculator → Fixed Size Chunker → Overlap Manager → Metadata Extractor → Chunk Validator → Quality Assessor → Output Formatter\n2. Multi-document processing: Document Preprocessor → Fixed Size Chunker → Overlap Manager → Metadata Extractor → Chunk Merger → Quality Assessor → Output Formatter\n\n**STEP 5 — Tools**\n\n```json\n{\n  \"tool_name\": \"Text Format Detector\",\n  \"tool_description\": \"Analyzes input text to detect format type, encoding, and structural characteristics to guide preprocessing decisions.\",\n  \"parameters\": {\n    \"text_content\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"The raw text content to analyze\"\n    },\n    \"sample_size\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"description\": \"Number of characters to sample for analysis (100-10000)\",\n      \"default\": 1000\n    }\n  },\n  \"error_messages\": [\n    \"Empty text content: Provide non-empty text content for analysis.\",\n    \"Invalid sample size: Sample size must be between 100 and 10000 characters.\"\n  ],\n  \"usage\": \"Provide text_content and optionally set sample_size. The tool analyzes the text structure and returns format information.\",\n  \"output_details\": {\n    \"format_type\": {\n      \"type\": \"string\",\n      \"description\": \"Detected format type (plain_text, markdown, html, json, xml)\"\n    },\n    \"encoding\": {\n      \"type\": \"string\", \n      \"description\": \"Detected character encoding\"\
  \n    },\n    \"line_endings\": {\n      \"type\": \"string\",\n      \"description\": \"Type of line endings detected (unix, windows, mac)\"\n    },\n    \"has_structure\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether structured elements like headers or lists are present\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Document Preprocessor\",\n  \"tool_description\": \"Cleans and normalizes text content by removing unwanted characters, normalizing whitespace, and preparing text for chunking.\",\n  \"parameters\": {\n    \"text_content\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"The raw text content to preprocess\"\n    },\n    \"format_type\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Format type from format detector\"\n    },\n    \"preserve_newlines\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to preserve original line breaks\",\n      \"default\": true\n    },\n    \"normalize_unicode\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to normalize Unicode characters\",\n      \"default\": true\n    },\n    \"remove_extra_whitespace\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to remove excessive whitespace\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Empty text content: Provide non-empty text content for preprocessing.\",\n    \"Invalid format type: Format type must be one of [plain_text, markdown, html, json, xml].\"\n  ],\n  \"usage\": \"Provide text_content and format_type, optionally configure preprocessing options. Returns cleaned text ready for chunking.\",\n  \"output_details\": {\n    \"cleaned_text\": {\n      \"type\": \"string\",\n      \"description\": \"The preprocessed and cleaned text content\"\n    },\n    \"original_length\": {\n      \"type\": \"integer\",\n      \"description\": \"Length of original text in characters\"\n    },\n    \"cleaned_length\": {\n      \"type\": \"integer\",\n      \"description\": \"Length of cleaned text in characters\"\n    },\n    \"modifications_applied\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"List of preprocessing modifications applied\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Boundary Analyzer\",\n  \"tool_description\": \"Identifies natural text boundaries like sentences, paragraphs, and sections to inform intelligent chunking decisions.\",\n  \"parameters\": {\n    \"text_content\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"The text content to analyze for boundaries\"\n    },\n    \"boundary_types\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Types of boundaries to detect\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"language\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Text language for boundary detection (en, es, fr, de, etc.)\",\n      \"default\": \"en\"\n    }\n  },\n  \"error_messages\": [\n    \"Empty text content: Provide non-empty text content for boundary analysis.\",\n    \"Invalid boundary types: Boundary types must include at least one of [sentence, paragraph, section, line].\",\n    \"Unsupported language: Language must be a valid ISO 639-1 language code.\"\n  ],\n  \"usage\": \"Provide text_content and boundary_types array, optionally specify language. Returns positions of detected boundaries.\",\n  \"output_details\": {\n    \"sentence_boundaries\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"description\": \"Character positions of sentence boundaries\"\n    },\n    \"paragraph_boundaries\": {\n      \"type\": \"array\", \n      \"items\": {\"type\": \"integer\"},\n      \"description\": \"Character positions of paragraph boundaries\"\n    },\n    \"section_boundaries\": {\n      \"type\": \"array\",\n      \"items\"\
  : {\"type\": \"integer\"}, \n      \"description\": \"Character positions of section boundaries\"\n    },\n    \"total_boundaries\": {\n      \"type\": \"integer\",\n      \"description\": \"Total number of boundaries detected\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Chunk Size Calculator\", \n  \"tool_description\": \"Calculates optimal chunk parameters based on text length, target chunk size, overlap requirements, and boundary constraints.\",\n  \"parameters\": {\n    \"text_length\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Total length of text to be chunked in characters\"\n    },\n    \"target_chunk_size\": {\n      \"type\": \"integer\", \n      \"required\": true,\n      \"description\": \"Desired chunk size in characters (100-10000)\"\n    },\n    \"overlap_percentage\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Percentage of overlap between chunks (0-50)\",\n      \"default\": 10\n    },\n    \"min_chunk_size\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"description\": \"Minimum acceptable chunk size in characters\",\n      \"default\": 50\n    },\n    \"respect_boundaries\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to adjust chunk sizes to respect text boundaries\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Invalid text length: Text length must be greater than 0.\",\n    \"Invalid chunk size: Target chunk size must be between 100 and 10000 characters.\",\n    \"Invalid overlap percentage: Overlap percentage must be between 0 and 50.\",\n    \"Invalid min chunk size: Minimum chunk size must be at least 10 characters and less than target chunk size.\"\n  ],\n  \"usage\": \"Provide text_length and target_chunk_size, optionally configure overlap and boundary settings. Returns optimized chunking parameters.\",\n  \"output_details\": {\n    \"optimal_chunk_size\": {\n      \"type\": \"integer\",\n      \"description\": \"Calculated optimal chunk size in characters\"\n    },\n    \"overlap_chars\": {\n      \"type\": \"integer\", \n      \"description\": \"Number of overlapping characters between chunks\"\n    },\n    \"estimated_chunks\": {\n      \"type\": \"integer\",\n      \"description\": \"Estimated number of chunks to be created\"\n    },\n    \"step_size\": {\n      \"type\": \"integer\",\n      \"description\": \"Step size for moving window (chunk_size - overlap)\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Fixed Size Chunker\",\n  \"tool_description\": \"Creates fixed-size text chunks from input text using specified chunk size and step parameters.\",\n  \"parameters\": {\n    \"text_content\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"The text content to chunk\"\n    },\n    \"chunk_size\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Size of each chunk in characters (100-10000)\"\n    },\n    \"step_size\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Step size for moving window (1-chunk_size)\"\n    },\n    \"pad_last_chunk\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to include the last chunk if it's smaller than chunk_size\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Empty text content: Provide non-empty text content for chunking.\",\n    \"Invalid chunk size: Chunk size must be between 100 and 10000 characters.\",\n    \"Invalid step size: Step size must be between 1 and chunk_size.\",\n    \"Text too short: Text must be at least as long as the chunk size.\"\n  ],\n  \"usage\": \"Provide text_content, chunk_size, and step_size. Optionally configure padding behavior. Returns array of fixed-size text chunks.\",\n  \"output_details\": {\n    \"chunks\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of text chunks\"\n    },\n    \"chunk_count\"\
  : {\n      \"type\": \"integer\",\n      \"description\": \"Total number of chunks created\"\n    },\n    \"total_characters\": {\n      \"type\": \"integer\",\n      \"description\": \"Total characters across all chunks\"\n    },\n    \"average_chunk_size\": {\n      \"type\": \"number\",\n      \"description\": \"Average size of chunks in characters\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Overlap Manager\",\n  \"tool_description\": \"Manages and validates overlap between text chunks, ensuring proper overlap ratios and handling edge cases.\",\n  \"parameters\": {\n    \"chunks\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of text chunks to process\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"target_overlap_chars\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Target number of overlapping characters between chunks\"\n    },\n    \"overlap_validation\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to validate overlap consistency\",\n      \"default\": true\n    },\n    \"fix_overlap_issues\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to automatically fix overlap problems\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Empty chunks array: Provide at least one chunk for overlap processing.\",\n    \"Invalid overlap chars: Target overlap characters must be non-negative and reasonable for chunk sizes.\",\n    \"Overlap validation failed: Chunks do not have consistent overlap as expected.\",\n    \"Cannot fix overlap: Automatic overlap fixing failed due to incompatible chunk sizes.\"\n  ],\n  \"usage\": \"Provide chunks array and target_overlap_chars, optionally enable validation and auto-fixing. Returns processed chunks with proper overlap.\",\n  \"output_details\": {\n    \"processed_chunks\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of chunks with validated/corrected overlap\"\n    },\n    \"overlap_ratios\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Actual overlap ratios between consecutive chunks\"\n    },\n    \"overlap_issues_found\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of overlap issues detected\"\n    },\n    \"overlap_issues_fixed\": {\n      \"type\": \"integer\", \n      \"description\": \"Number of overlap issues automatically corrected\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Metadata Extractor\",\n  \"tool_description\": \"Extracts and generates metadata for each text chunk including position information, content characteristics, and relationships.\",\n  \"parameters\": {\n    \"original_text\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"The original text before chunking\"\n    },\n    \"chunks\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of text chunks to generate metadata for\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"chunk_positions\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Starting positions of each chunk in the original text\",\n      \"items\": {\"type\": \"integer\"}\n    },\n    \"include_content_stats\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to include content statistics in metadata\",\n      \"default\": true\n    },\n    \"include_relationships\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to include chunk relationship information\",\n      \"default\": true\n    },\n    \"document_id\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Optional document identifier for metadata\",\n      \"default\": null\n    }\n  },\n  \"error_messages\": [\n    \"Empty original text: Provide non-empty original text for metadata extraction.\"\
  ,\n    \"Empty chunks array: Provide at least one chunk for metadata generation.\",\n    \"Position array mismatch: Chunk positions array must have same length as chunks array.\",\n    \"Invalid positions: All chunk positions must be valid indices within the original text.\"\n  ],\n  \"usage\": \"Provide original_text, chunks, and chunk_positions arrays. Optionally configure metadata options and document_id. Returns metadata for each chunk.\",\n  \"output_details\": {\n    \"chunk_metadata\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"JSON strings containing metadata for each chunk\"\n    },\n    \"total_chunks\": {\n      \"type\": \"integer\",\n      \"description\": \"Total number of chunks processed\"\n    },\n    \"metadata_fields\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"List of metadata fields included for each chunk\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Chunk Validator\",\n  \"tool_description\": \"Validates text chunks against quality rules, size constraints, and content requirements to ensure chunking quality.\",\n  \"parameters\": {\n    \"chunks\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of text chunks to validate\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"min_chunk_size\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Minimum acceptable chunk size in characters\"\n    },\n    \"max_chunk_size\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Maximum acceptable chunk size in characters\"\n    },\n    \"check_encoding\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to validate text encoding\",\n      \"default\": true\n    },\n    \"check_completeness\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to check for incomplete sentences or words\",\n      \"default\": true\n    },\n    \"allowed_empty_chunks\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"description\": \"Number of empty chunks allowed\",\n      \"default\": 0\n    },\n    \"validation_rules\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Additional validation rules to apply\",\n      \"items\": {\"type\": \"string\"},\n      \"default\": []\n    }\n  },\n  \"error_messages\": [\n    \"Empty chunks array: Provide at least one chunk for validation.\",\n    \"Invalid size constraints: Minimum chunk size must be less than maximum chunk size.\",\n    \"Size constraint violation: Some chunks violate the specified size constraints.\",\n    \"Encoding issues detected: Some chunks contain invalid character encodings.\",\n    \"Completeness check failed: Some chunks contain incomplete sentences or truncated words.\"\n  ],\n  \"usage\": \"Provide chunks array and size constraints, optionally configure validation options and rules. Returns validation results and any issues found.\",\n  \"output_details\": {\n    \"validation_passed\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether all chunks passed validation\"\n    },\n    \"total_issues\": {\n      \"type\": \"integer\",\n      \"description\": \"Total number of validation issues found\"\n    },\n    \"issue_types\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Types of validation issues detected\"\n    },\n    \"problematic_chunks\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"description\": \"Indices of chunks that failed validation\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Content Preservor\",\n  \"tool_description\": \"Preserves important content structure and formatting elements during chunking to maintain document integrity.\",\n  \"parameters\": {\n    \"text_content\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"\
  The text content with structure to preserve\"\n    },\n    \"preserve_headers\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to preserve header structures\",\n      \"default\": true\n    },\n    \"preserve_lists\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to preserve list structures\",\n      \"default\": true\n    },\n    \"preserve_tables\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to preserve table structures\",\n      \"default\": true\n    },\n    \"preserve_code_blocks\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to preserve code block structures\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Empty text content: Provide non-empty text content for structure preservation.\",\n    \"No preservable structure: Text does not contain any recognizable structure elements to preserve.\"\n  ],\n  \"usage\": \"Provide text_content and configure which structural elements to preserve. Returns text with preserved structure markers.\",\n  \"output_details\": {\n    \"structured_text\": {\n      \"type\": \"string\",\n      \"description\": \"Text with structure preservation markers\"\n    },\n    \"structure_map\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Map of preserved structural elements and their positions\"\n    },\n    \"preservation_count\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of structural elements preserved\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Quality Assessor\",\n  \"tool_description\": \"Assesses the quality of text chunks using multiple metrics including readability, coherence, and information completeness.\",\n  \"parameters\": {\n    \"chunks\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of text chunks to assess\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"assessment_metrics\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Quality metrics to evaluate\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"quality_threshold\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Minimum acceptable quality score (0-1)\",\n      \"default\": 0.7\n    },\n    \"language\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Language for quality assessment\",\n      \"default\": \"en\"\n    }\n  },\n  \"error_messages\": [\n    \"Empty chunks array: Provide at least one chunk for quality assessment.\",\n    \"Invalid assessment metrics: Metrics must include at least one of [readability, coherence, completeness, diversity].\",\n    \"Invalid quality threshold: Quality threshold must be between 0 and 1.\",\n    \"Assessment failed: Unable to compute quality metrics for some chunks.\"\n  ],\n  \"usage\": \"Provide chunks and assessment_metrics arrays, optionally set quality_threshold and language. Returns quality scores and recommendations.\",\n  \"output_details\": {\n    \"overall_quality_score\": {\n      \"type\": \"number\",\n      \"description\": \"Overall quality score across all chunks\"\n    },\n    \"chunk_quality_scores\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Individual quality scores for each chunk\"\n    },\n    \"quality_metrics\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Detailed quality metrics results\"\n    },\n    \"recommendations\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Recommendations for improving chunk quality\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Chunk Merger\",\n  \"tool_description\": \"Merges multiple sets of text chunks while maintaining proper ordering and resolving overlaps or gaps.\",\n  \"parameters\":\
  \ {\n    \"chunk_sets\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of chunk arrays to merge\",\n      \"items\": {\"type\": \"array\"}\n    },\n    \"merge_strategy\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Strategy for merging chunks: sequential, interleaved, or priority_based\"\n    },\n    \"resolve_overlaps\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to automatically resolve overlapping content\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Empty chunk sets: Provide at least one non-empty chunk set for merging.\",\n    \"Invalid merge strategy: Strategy must be one of [sequential, interleaved, priority_based].\",\n    \"Overlap resolution failed: Unable to resolve overlapping content between chunk sets.\",\n    \"Inconsistent chunk formats: All chunk sets must contain compatible chunk formats.\"\n  ],\n  \"usage\": \"Provide chunk_sets array and merge_strategy, optionally enable overlap resolution. Returns merged and ordered chunk collection.\",\n  \"output_details\": {\n    \"merged_chunks\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of merged chunks in proper order\"\n    },\n    \"merge_statistics\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Statistics about the merging process\"\n    },\n    \"overlaps_resolved\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of overlaps automatically resolved\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Output Formatter\",\n  \"tool_description\": \"Formats chunked text output according to specified format requirements and adds final metadata and indexing.\",\n  \"parameters\": {\n    \"chunks\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of text chunks to format\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"output_format\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Desired output format: json, csv, txt, or xml\"\n    },\n    \"include_metadata\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to include chunk metadata in output\",\n      \"default\": true\n    },\n    \"include_indices\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to include chunk indices in output\",\n      \"default\": true\n    },\n    \"compression\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to compress the output\",\n      \"default\": false\n    }\n  },\n  \"error_messages\": [\n    \"Empty chunks array: Provide at least one chunk for formatting.\",\n    \"Invalid output format: Format must be one of [json, csv, txt, xml].\",\n    \"Formatting failed: Unable to format chunks in the specified output format.\",\n    \"Compression failed: Unable to compress the formatted output.\"\n  ],\n  \"usage\": \"Provide chunks array and output_format, optionally configure metadata inclusion and compression. Returns formatted chunk output.\",\n  \"output_details\": {\n    \"formatted_output\": {\n      \"type\": \"string\",\n      \"description\": \"The formatted chunk output as a string\"\n    },\n    \"output_size\": {\n      \"type\": \"integer\",\n      \"description\": \"Size of the formatted output in bytes\"\n    },\n    \"chunk_count\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of chunks in the formatted output\"\n    },\n    \"format_version\": {\n      \"type\": \"string\",\n      \"description\": \"Version of the output format used\"\n    }\n  }\n}\n```"
