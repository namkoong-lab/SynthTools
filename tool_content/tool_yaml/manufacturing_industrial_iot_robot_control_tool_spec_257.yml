field_name: manufacturing_industrial_iot_robot_control
subfield: robotic_arm_programming_control
task: Program trajectory planning and path optimization for robotic movements
tool_description: "**STEP 1 — Rate task difficulty**\nProgramming trajectory planning and path optimization for robotic movements is a hard task. It involves complex mathematical computations (inverse kinematics, path smoothing), real-time constraint handling (joint limits, collision avoidance), multi-objective optimization (time, energy, smoothness), and coordination between multiple subsystems with high precision requirements and safety-critical implications.\n\n**STEP 2 — Set a tool budget**\nGiven the hard difficulty rating, I'll target 17 tools within the 15-20 range to cover the comprehensive workflow from initial pose definition through trajectory generation, optimization, validation, and execution.\n\n**STEP 3 — Tool names and dependencies**\n1. **Joint Angle Calculator** - consumes: target poses → produces: joint configurations\n2. **Workspace Validator** - consumes: poses/paths → produces: reachability validation\n3. **Collision Detector** - consumes: trajectory points → produces: collision reports\n4. **Path Point Generator** - consumes: start/end poses → produces: waypoint sequences\n5. **Trajectory Interpolator** - consumes: waypoints → produces: smooth trajectories\n6. **Velocity Profile Generator** - consumes: path segments → produces: velocity profiles\n7. **Joint Limit Checker** - consumes: joint angles → produces: constraint validation\n8. **Path Optimizer** - consumes: initial paths → produces: optimized trajectories\n9. **Smoothness Analyzer** - consumes: trajectories → produces: smoothness metrics\n10. **Execution Time Estimator** - consumes: trajectories → produces: timing estimates\n11. **Energy Calculator** - consumes: motion profiles → produces: energy consumption\n12. **Trajectory Validator** - consumes: complete trajectories → produces: validation reports\n13. **Multi-Path Comparator** - consumes: multiple trajectories → produces: comparison rankings\n14. **Real-time Adapter** - consumes: trajectories → produces: real-time compatible formats\n15. **Safety Monitor** - consumes: motion plans → produces: safety assessments\n16. **Trajectory Merger** - consumes: path segments → produces: combined trajectories\n17. **Motion Simulator** - consumes: trajectories → produces: simulation results\n\n**STEP 4 — Multi-tool plans**\n\n**Simple Plans:**\n1. Basic point-to-point motion: Joint Angle Calculator → Joint Limit Checker → Trajectory Validator\n2. Workspace validation: Workspace Validator → Safety Monitor\n\n**Medium Plans:**\n1. Standard trajectory planning: Path Point Generator → Trajectory Interpolator → Velocity Profile Generator → Joint Limit Checker → Trajectory Validator\n2. Collision-free planning: Path Point Generator → Collision Detector → Path Optimizer → Trajectory Validator → Motion Simulator\n\n**Complex Plans:**\n1. Full optimization workflow: Joint Angle Calculator → Workspace Validator → Path Point Generator → Collision Detector → Trajectory Interpolator → Velocity Profile Generator → Path Optimizer → Smoothness Analyzer → Energy Calculator → Multi-Path Comparator → Real-time Adapter → Safety Monitor → Trajectory Validator\n2. Multi-segment planning: Path Point Generator → Trajectory Interpolator → Trajectory Merger → Collision Detector → Path Optimizer → Execution Time Estimator → Energy Calculator → Motion Simulator → Trajectory Validator\n\n**STEP 5 — Produce tools**\n\n```json\n{\n  \"tool_name\": \"Joint Angle Calculator\",\n  \"tool_description\": \"Computes joint angles required to achieve specified end-effector poses using inverse kinematics for robotic arms.\",\n  \"parameters\": {\n    \"target_position\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Target XYZ coordinates in meters\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 3,\n      \"maxItems\": 3\n    },\n    \"target_orientation\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Target orientation as quaternion [w,x,y,z]\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 4,\n      \"maxItems\": 4\n    },\n    \"\
  robot_config\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Robot configuration identifier (e.g., 6DOF_ARM, SCARA_4DOF)\"\n    },\n    \"solution_preference\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Preferred solution type: elbow_up, elbow_down, closest_to_current\",\n      \"default\": \"closest_to_current\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid target pose: Position coordinates must be within robot workspace bounds.\",\n    \"Unreachable pose: Target pose cannot be achieved with current robot configuration.\",\n    \"Invalid quaternion: Orientation quaternion must be normalized (magnitude = 1).\",\n    \"Unknown robot config: Specified robot configuration is not supported.\"\n  ],\n  \"usage\": \"Provide target_position as [x,y,z], target_orientation as normalized quaternion, and robot_config. Optionally specify solution_preference for multiple valid solutions.\",\n  \"output_details\": {\n    \"joint_angles\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Computed joint angles in radians\"\n    },\n    \"solution_valid\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether a valid solution was found\"\n    },\n    \"configuration_used\": {\n      \"type\": \"string\",\n      \"description\": \"Which kinematic solution was selected\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Workspace Validator\",\n  \"tool_description\": \"Validates whether specified poses or paths are within the robot's reachable workspace and identifies workspace violations.\",\n  \"parameters\": {\n    \"poses\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Array of poses to validate, each as 7 values: [x,y,z,qw,qx,qy,qz]\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 7\n    },\n    \"robot_config\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Robot configuration identifier\"\n    },\n    \"safety_margin\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Safety margin from workspace boundary in meters\",\n      \"default\": 0.05\n    }\n  },\n  \"error_messages\": [\n    \"Invalid pose format: Each pose must contain exactly 7 values [x,y,z,qw,qx,qy,qz].\",\n    \"Empty pose array: At least one pose must be provided for validation.\",\n    \"Invalid safety margin: Safety margin must be non-negative and less than 0.5 meters.\"\n  ],\n  \"usage\": \"Provide array of poses as flattened 7-element groups, robot_config, and optional safety_margin. Returns validation status for each pose.\",\n  \"output_details\": {\n    \"valid_poses\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"boolean\"},\n      \"description\": \"Validation status for each input pose\"\n    },\n    \"violation_distances\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Distance to workspace boundary for each pose (negative if outside)\"\n    },\n    \"overall_valid\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether all poses are within valid workspace\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Collision Detector\",\n  \"tool_description\": \"Detects potential collisions along trajectory points by checking robot self-collision and collisions with environment obstacles.\",\n  \"parameters\": {\n    \"trajectory_points\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Joint configurations along trajectory, flattened array\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 6\n    },\n    \"num_joints\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Number of joints per configuration\"\n    },\n    \"obstacle_positions\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Obstacle center positions as [x1,y1,z1,x2,y2,z2,...]\",\n      \"items\": {\"type\": \"number\"\
  },\n      \"default\": []\n    },\n    \"obstacle_sizes\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Obstacle sizes as [r1,r2,...] for spherical obstacles\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"robot_config\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Robot configuration for collision model\"\n    },\n    \"safety_distance\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Minimum safe distance to obstacles in meters\",\n      \"default\": 0.1\n    }\n  },\n  \"error_messages\": [\n    \"Invalid trajectory format: Number of trajectory points must be divisible by num_joints.\",\n    \"Mismatched obstacle data: obstacle_positions and obstacle_sizes arrays must have compatible lengths.\",\n    \"Invalid joint count: num_joints must be between 3 and 10.\",\n    \"Negative safety distance: safety_distance must be non-negative.\"\n  ],\n  \"usage\": \"Provide trajectory_points as flattened joint angles, num_joints, robot_config, and optional obstacle data. Returns collision status for each trajectory point.\",\n  \"output_details\": {\n    \"collision_detected\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether any collisions were detected\"\n    },\n    \"collision_points\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"description\": \"Indices of trajectory points with collisions\"\n    },\n    \"min_distances\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Minimum distance to obstacles at each trajectory point\"\n    },\n    \"self_collision_points\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"description\": \"Indices where self-collision occurs\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Path Point Generator\",\n  \"tool_description\": \"Generates intermediate waypoints between start and end poses using specified interpolation methods for path planning.\",\n  \"parameters\": {\n    \"start_pose\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Starting pose as [x,y,z,qw,qx,qy,qz]\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 7,\n      \"maxItems\": 7\n    },\n    \"end_pose\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Target pose as [x,y,z,qw,qx,qy,qz]\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 7,\n      \"maxItems\": 7\n    },\n    \"num_points\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Number of intermediate waypoints to generate\"\n    },\n    \"interpolation_method\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Interpolation type: linear, cubic, quintic, slerp\",\n      \"default\": \"cubic\"\n    },\n    \"include_endpoints\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"description\": \"Whether to include start and end poses in output\",\n      \"default\": true\n    }\n  },\n  \"error_messages\": [\n    \"Invalid pose format: Start and end poses must each contain exactly 7 values.\",\n    \"Invalid point count: num_points must be between 2 and 1000.\",\n    \"Unsupported interpolation: Use linear, cubic, quintic, or slerp.\",\n    \"Invalid quaternions: Quaternions in poses must be normalized.\"\n  ],\n  \"usage\": \"Specify start_pose, end_pose, num_points, and optional interpolation_method. Returns array of intermediate waypoints.\",\n  \"output_details\": {\n    \"waypoints\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Generated waypoints as flattened array of 7-element poses\"\n    },\n    \"path_length\": {\n      \"type\": \"number\",\n      \"description\": \"Total Cartesian path length in meters\"\n    },\n    \"interpolation_used\": {\n      \"type\": \"string\",\n      \"description\": \"Interpolation method that\
  \ was applied\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Trajectory Interpolator\",\n  \"tool_description\": \"Creates smooth trajectories from discrete waypoints by applying spline interpolation and temporal parameterization.\",\n  \"parameters\": {\n    \"waypoints\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Input waypoints as flattened joint angles\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 12\n    },\n    \"num_joints\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Number of joints per waypoint\"\n    },\n    \"time_points\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Time stamps for each waypoint in seconds\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"spline_order\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"description\": \"Spline polynomial order (3 for cubic, 5 for quintic)\",\n      \"default\": 3\n    },\n    \"output_frequency\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Output trajectory frequency in Hz\",\n      \"default\": 100.0\n    },\n    \"boundary_conditions\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Boundary condition type: zero_velocity, natural, clamped\",\n      \"default\": \"zero_velocity\"\n    },\n    \"max_velocity\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Maximum velocity for each joint in rad/s\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"max_acceleration\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Maximum acceleration for each joint in rad/s²\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    }\n  },\n  \"error_messages\": [\n    \"Invalid waypoint format: Number of waypoint values must be divisible by num_joints.\",\n    \"Insufficient waypoints: At least 2 waypoints required for interpolation.\",\n    \"Time point mismatch: If provided, time_points array must match number of waypoints.\",\n    \"Invalid spline order: spline_order must be 3 or 5.\",\n    \"Invalid frequency: output_frequency must be between 10 and 1000 Hz.\",\n    \"Constraint violation: max_velocity and max_acceleration arrays must match num_joints if provided.\"\n  ],\n  \"usage\": \"Provide waypoints as flattened joint angles, num_joints, and optional timing/constraint parameters. Returns smooth interpolated trajectory.\",\n  \"output_details\": {\n    \"trajectory\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Interpolated trajectory as flattened joint positions\"\n    },\n    \"time_stamps\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Time stamps for each trajectory point\"\n    },\n    \"total_duration\": {\n      \"type\": \"number\",\n      \"description\": \"Total trajectory duration in seconds\"\n    },\n    \"num_points\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of points in output trajectory\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Velocity Profile Generator\",\n  \"tool_description\": \"Generates velocity and acceleration profiles for path segments with specified motion constraints and timing requirements.\",\n  \"parameters\": {\n    \"path_distances\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Cumulative distances along path segments\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 2\n    },\n    \"max_velocity\": {\n      \"type\": \"number\",\n      \"required\": true,\n      \"description\": \"Maximum allowed velocity\"\n    },\n    \"max_acceleration\": {\n      \"type\": \"number\",\n      \"required\": true,\n      \"description\": \"Maximum allowed acceleration\"\n    },\n    \"start_velocity\": {\n      \"type\": \"number\",\n      \"required\"\
  : false,\n      \"description\": \"Initial velocity\",\n      \"default\": 0.0\n    },\n    \"end_velocity\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Final velocity\",\n      \"default\": 0.0\n    },\n    \"profile_type\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"description\": \"Velocity profile type: trapezoidal, s_curve, bang_bang\",\n      \"default\": \"trapezoidal\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid distance array: Path distances must be monotonically increasing and positive.\",\n    \"Invalid velocity constraints: max_velocity must be positive.\",\n    \"Invalid acceleration constraints: max_acceleration must be positive.\", \n    \"Boundary velocity error: start_velocity and end_velocity must not exceed max_velocity.\",\n    \"Unsupported profile type: Use trapezoidal, s_curve, or bang_bang.\"\n  ],\n  \"usage\": \"Provide path_distances array, max_velocity, max_acceleration, and optional boundary conditions. Returns time-parameterized velocity profile.\",\n  \"output_details\": {\n    \"velocities\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Velocity values at each path point\"\n    },\n    \"accelerations\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Acceleration values at each path point\"\n    },\n    \"time_stamps\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Time stamps corresponding to each path point\"\n    },\n    \"total_time\": {\n      \"type\": \"number\",\n      \"description\": \"Total time to complete the path\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Joint Limit Checker\",\n  \"tool_description\": \"Validates joint angle trajectories against position, velocity, and acceleration limits to ensure robot safety.\",\n  \"parameters\": {\n    \"joint_positions\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Joint positions to check as flattened array\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 3\n    },\n    \"joint_velocities\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Joint velocities to check as flattened array\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"joint_accelerations\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Joint accelerations to check as flattened array\", \n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"num_joints\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Number of joints in the robot\"\n    },\n    \"position_limits_min\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Minimum position limits for each joint\",\n      \"items\": {\"type\": \"number\"}\n    },\n    \"position_limits_max\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Maximum position limits for each joint\",\n      \"items\": {\"type\": \"number\"}\n    },\n    \"velocity_limits\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Maximum velocity limits for each joint\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"acceleration_limits\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Maximum acceleration limits for each joint\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"safety_margin\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Safety margin as fraction of limit (0.0 to 0.2)\",\n      \"default\": 0.05\n    }\n  },\n  \"error_messages\": [\n    \"Array size mismatch: joint_positions length must be divisible by num_joints.\",\n    \"Limit array mismatch: position_limits_min and position_limits_max must each have num_joints elements.\",\n    \"\
  Velocity array mismatch: If provided, joint_velocities length must be divisible by num_joints.\",\n    \"Invalid safety margin: safety_margin must be between 0.0 and 0.2.\",\n    \"Inconsistent limits: position_limits_min values must be less than position_limits_max values.\"\n  ],\n  \"usage\": \"Provide joint_positions, num_joints, position limits, and optional velocity/acceleration data with their limits. Returns violation analysis.\",\n  \"output_details\": {\n    \"position_violations\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"boolean\"},\n      \"description\": \"Position limit violations for each trajectory point\"\n    },\n    \"velocity_violations\": {\n      \"type\": \"array\", \n      \"items\": {\"type\": \"boolean\"},\n      \"description\": \"Velocity limit violations for each trajectory point\"\n    },\n    \"all_valid\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether all constraints are satisfied\"\n    },\n    \"violation_details\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Detailed violation descriptions for each point\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Path Optimizer\",\n  \"tool_description\": \"Optimizes robot trajectories using specified optimization objectives like minimum time, energy, or smoothness with constraint handling.\",\n  \"parameters\": {\n    \"initial_trajectory\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Initial trajectory as flattened joint positions\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 12\n    },\n    \"num_joints\": {\n      \"type\": \"integer\", \n      \"required\": true,\n      \"description\": \"Number of joints per trajectory point\"\n    },\n    \"optimization_objective\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Optimization goal: minimum_time, minimum_energy, maximum_smoothness, minimum_jerk\"\n    },\n    \"joint_limits_min\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Minimum joint position limits\",\n      \"items\": {\"type\": \"number\"}\n    },\n    \"joint_limits_max\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Maximum joint position limits\", \n      \"items\": {\"type\": \"number\"}\n    },\n    \"velocity_limits\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Maximum velocity limits for each joint\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"acceleration_limits\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Maximum acceleration limits for each joint\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"obstacle_positions\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Obstacle positions for avoidance\",\n      \"items\": {\"type\": \"number\"},\n      \"default\": []\n    },\n    \"max_iterations\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"description\": \"Maximum optimization iterations\",\n      \"default\": 100\n    },\n    \"convergence_tolerance\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Convergence tolerance for optimization\",\n      \"default\": 0.001\n    },\n    \"waypoint_flexibility\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Allowed deviation from original waypoints (0.0 to 1.0)\",\n      \"default\": 0.1\n    }\n  },\n  \"error_messages\": [\n    \"Invalid trajectory format: initial_trajectory length must be divisible by num_joints.\",\n    \"Unsupported objective: Use minimum_time, minimum_energy, maximum_smoothness, or minimum_jerk.\",\n    \"Limit mismatch: joint_limits_min and joint_limits_max must each have num_joints elements.\",\n    \"Invalid iteration count: max_iterations must be between 10 and 1000.\",\n    \"Invalid tolerance: convergence_tolerance\
  \ must be between 1e-6 and 0.1.\",\n    \"Invalid flexibility: waypoint_flexibility must be between 0.0 and 1.0.\"\n  ],\n  \"usage\": \"Provide initial_trajectory, num_joints, optimization_objective, joint limits, and optional constraints. Returns optimized trajectory with performance metrics.\",\n  \"output_details\": {\n    \"optimized_trajectory\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Optimized trajectory as flattened joint positions\"\n    },\n    \"objective_value\": {\n      \"type\": \"number\",\n      \"description\": \"Final objective function value\"\n    },\n    \"iterations_used\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of optimization iterations performed\"\n    },\n    \"convergence_achieved\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether optimization converged successfully\"\n    },\n    \"improvement_ratio\": {\n      \"type\": \"number\",\n      \"description\": \"Improvement ratio compared to initial trajectory\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Smoothness Analyzer\",\n  \"tool_description\": \"Analyzes trajectory smoothness using multiple metrics including jerk, curvature, and continuity measures for motion quality assessment.\",\n  \"parameters\": {\n    \"trajectory\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Trajectory data as flattened joint positions\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 18\n    },\n    \"num_joints\": {\n      \"type\": \"integer\",\n      \"required\": true,\n      \"description\": \"Number of joints per trajectory point\"\n    },\n    \"time_step\": {\n      \"type\": \"number\",\n      \"required\": true,\n      \"description\": \"Time interval between trajectory points in seconds\"\n    },\n    \"metrics\": {\n      \"type\": \"array\",\n      \"required\": false,\n      \"description\": \"Smoothness metrics to compute: jerk, curvature, continuity, acceleration_variance\",\n      \"items\": {\"type\": \"string\"},\n      \"default\": [\"jerk\", \"curvature\"]\n    }\n  },\n  \"error_messages\": [\n    \"Invalid trajectory format: trajectory length must be divisible by num_joints with at least 3 points.\",\n    \"Invalid time step: time_step must be positive and less than 1.0 seconds.\",\n    \"Invalid joint count: num_joints must be between 3 and 10.\",\n    \"Unsupported metric: Use jerk, curvature, continuity, or acceleration_variance.\"\n  ],\n  \"usage\": \"Provide trajectory as flattened joint positions, num_joints, time_step, and optional metrics list. Returns comprehensive smoothness analysis.\",\n  \"output_details\": {\n    \"overall_smoothness_score\": {\n      \"type\": \"number\",\n      \"description\": \"Combined smoothness score (0-100, higher is smoother)\"\n    },\n    \"jerk_metrics\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"RMS jerk values for each joint\"\n    },\n    \"curvature_metrics\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Maximum curvature values for each joint\"\n    },\n    \"discontinuities_detected\": {\n      \"type\": \"integer\",\n      \"description\": \"Number of discontinuities found in trajectory\"\n    },\n    \"problem_regions\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"integer\"},\n      \"description\": \"Trajectory point indices with smoothness issues\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Execution Time Estimator\",\n  \"tool_description\": \"Estimates trajectory execution time considering robot dynamics, motion constraints, and control system characteristics.\",\n  \"parameters\": {\n    \"trajectory\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Trajectory as flattened joint positions\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 12\n    },\n    \"num_joints\": {\n      \"type\": \"integer\",\n      \"required\": true,\n    \
  \  \"description\": \"Number of joints in trajectory\"\n    },\n    \"max_velocities\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Maximum velocity for each joint\",\n      \"items\": {\"type\": \"number\"}\n    },\n    \"max_accelerations\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Maximum acceleration for each joint\",\n      \"items\": {\"type\": \"number\"}\n    },\n    \"control_frequency\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"description\": \"Control system frequency in Hz\",\n      \"default\": 100.0\n    }\n  },\n  \"error_messages\": [\n    \"Invalid trajectory format: trajectory length must be divisible by num_joints.\",\n    \"Constraint array mismatch: max_velocities and max_accelerations must each have num_joints elements.\",\n    \"Invalid velocity limits: All max_velocities values must be positive.\",\n    \"Invalid acceleration limits: All max_accelerations values must be positive.\",\n    \"Invalid control frequency: control_frequency must be between 10 and 1000 Hz.\"\n  ],\n  \"usage\": \"Provide trajectory, num_joints, velocity and acceleration limits, and optional control_frequency. Returns detailed timing analysis.\",\n  \"output_details\": {\n    \"estimated_duration\": {\n      \"type\": \"number\",\n      \"description\": \"Total estimated execution time in seconds\"\n    },\n    \"segment_durations\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Duration estimate for each trajectory segment\"\n    },\n    \"limiting_joint\": {\n      \"type\": \"integer\", \n      \"description\": \"Joint index that limits overall execution speed\"\n    },\n    \"bottleneck_type\": {\n      \"type\": \"string\",\n      \"description\": \"Whether bottleneck is velocity or acceleration limited\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Energy Calculator\",\n  \"tool_description\": \"Computes energy consumption estimates for robot trajectories based on joint torques, velocities, and motor characteristics.\",\n  \"parameters\": {\n    \"trajectory\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Joint positions as flattened array\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 12\n    },\n    \"velocities\": {\n      \"type\": \"array\",\n      \"required\": true,\n      \"description\": \"Joint velocities as flattened array\",\n      \"items\": {\"type\": \"number\"},\n      \"minItems\": 6\n    },\n    \"accelerations\": {\n      \"type\": \"array\",\n      \"required\": true,"
