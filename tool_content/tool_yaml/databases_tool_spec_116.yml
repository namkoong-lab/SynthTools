field_name: databases
subfield: Database Security and Access Control
task: User Authentication and Identity Verification
tool_description: |-
  ## STEP 1 — Rate task difficulty

  This task has medium difficulty. It involves multiple authentication methods, identity verification protocols, session management, and integration with various identity providers, but follows well-established security patterns and standards with clear success/failure outcomes.

  ## STEP 2 — Set a tool budget

  Given the medium difficulty, I'll target 12 tools to cover the various aspects of user authentication and identity verification comprehensively.

  ## STEP 3 — List all tool names and dependencies

  1. **Password Validator** - Consumes: password, policy rules | Produces: validation results, strength score
  2. **Multi Factor Auth Generator** - Consumes: user info, MFA type | Produces: MFA tokens/codes
  3. **Multi Factor Auth Verifier** - Consumes: user input, stored tokens | Produces: verification status
  4. **Session Token Manager** - Consumes: user credentials, session params | Produces: JWT tokens, session data
  5. **Identity Provider Connector** - Consumes: provider config, user data | Produces: authentication status
  6. **User Credential Validator** - Consumes: username, password, database connection | Produces: validation results
  7. **Biometric Data Processor** - Consumes: biometric data, templates | Produces: processed features, match scores
  8. **Access Attempt Logger** - Consumes: login attempts, user data | Produces: audit logs, alerts
  9. **Account Lockout Manager** - Consumes: failed attempts, policies | Produces: lockout status, unlock times
  10. **Certificate Validator** - Consumes: digital certificates, CA info | Produces: validation results
  11. **Single Sign On Handler** - Consumes: SSO tokens, provider data | Produces: authentication status
  12. **Risk Assessment Engine** - Consumes: login context, user patterns | Produces: risk scores, recommendations

  ## STEP 4 — Multi-tool plans

  **Simple Plans:**
  - Basic Login: User Credential Validator → Session Token Manager → Access Attempt Logger
  - Password Reset: Password Validator → Session Token Manager → Access Attempt Logger

  **Medium Plans:**
  - Enhanced Authentication: User Credential Validator → Multi Factor Auth Generator → Multi Factor Auth Verifier → Session Token Manager → Access Attempt Logger
  - SSO Login: Single Sign On Handler → Risk Assessment Engine → Session Token Manager → Access Attempt Logger

  **Complex Plans:**
  - High-Security Login: User Credential Validator → Risk Assessment Engine → Multi Factor Auth Generator → Biometric Data Processor → Multi Factor Auth Verifier → Certificate Validator → Session Token Manager → Access Attempt Logger → Account Lockout Manager
  - Enterprise Authentication: Identity Provider Connector → Certificate Validator → Risk Assessment Engine → Multi Factor Auth Generator → Multi Factor Auth Verifier → Session Token Manager → Access Attempt Logger

  ## STEP 5 — Produce tools

  ```json
  {
    "tool_name": "Password Validator",
    "tool_description": "Validates password strength and compliance with security policies, checking for common patterns, dictionary words, and policy requirements.",
    "parameters": {
      "password": {
        "type": "string",
        "required": true,
        "description": "The password to validate"
      },
      "min_length": {
        "type": "integer",
        "required": false,
        "description": "Minimum password length",
        "default": 8
      },
      "require_uppercase": {
        "type": "boolean",
        "required": false,
        "description": "Whether uppercase letters are required",
        "default": true
      },
      "require_lowercase": {
        "type": "boolean",
        "required": false,
        "description": "Whether lowercase letters are required",
        "default": true
      },
      "require_numbers": {
        "type": "boolean",
        "required": false,
        "description": "Whether numbers are required",
        "default": true
      },
      "require_special": {
        "type": "boolean",
        "required": false,
        "description": "Whether special characters are required",
        "default": true
      }
    },
    "error_messages": [
      "Empty password: Password cannot be empty or null.",
      "Invalid length constraint: min_length must be between 1 and 128 characters.",
      "Password too weak: Password does not meet the specified complexity requirements."
    ],
    "usage": "Provide a password and optional policy parameters to validate password strength and compliance with security requirements.",
    "output_details": {
      "is_valid": {
        "type": "boolean",
        "description": "Whether the password meets all requirements"
      },
      "strength_score": {
        "type": "integer",
        "description": "Password strength score from 0-100"
      },
      "violations": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "List of policy violations found"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Multi Factor Auth Generator",
    "tool_description": "Generates multi-factor authentication tokens, codes, or challenges for various MFA methods including TOTP, SMS, email, and hardware tokens.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the user"
      },
      "mfa_method": {
        "type": "string",
        "required": true,
        "description": "MFA method: totp, sms, email, hardware_token, push_notification"
      },
      "contact_info": {
        "type": "string",
        "required": false,
        "description": "Phone number or email for SMS/email MFA",
        "default": "None"
      },
      "token_length": {
        "type": "integer",
        "required": false,
        "description": "Length of generated token (4-12 digits)",
        "default": 6
      },
      "expiry_seconds": {
        "type": "integer",
        "required": false,
        "description": "Token expiration time in seconds",
        "default": 300
      }
    },
    "error_messages": [
      "Invalid MFA method: Use one of [totp, sms, email, hardware_token, push_notification].",
      "Missing contact info: SMS and email methods require valid contact_info parameter.",
      "Invalid token length: token_length must be between 4 and 12.",
      "Invalid expiry time: expiry_seconds must be between 30 and 3600.",
      "User not found: The specified user_id does not exist in the system."
    ],
    "usage": "Specify user_id and mfa_method, provide contact_info for SMS/email methods, and optionally set token parameters to generate MFA challenges.",
    "output_details": {
      "token_id": {
        "type": "string",
        "description": "Unique identifier for the generated token"
      },
      "challenge_data": {
        "type": "string",
        "description": "The challenge data or token sent to user"
      },
      "expires_at": {
        "type": "string",
        "description": "Token expiration timestamp"
      },
      "delivery_status": {
        "type": "string",
        "description": "Status of token delivery (sent, failed, pending)"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Multi Factor Auth Verifier",
    "tool_description": "Verifies multi-factor authentication responses against stored tokens and challenges, supporting various MFA methods.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the user"
      },
      "token_id": {
        "type": "string",
        "required": true,
        "description": "Token identifier from MFA generation"
      },
      "user_response": {
        "type": "string",
        "required": true,
        "description": "User's response to the MFA challenge"
      },
      "allow_time_drift": {
        "type": "integer",
        "required": false,
        "description": "Allowed time drift in seconds for TOTP",
        "default": 30
      }
    },
    "error_messages": [
      "Token not found: The specified token_id does not exist or has expired.",
      "Invalid response: The user_response does not match the expected format.",
      "Token expired: The MFA token has exceeded its validity period.",
      "Verification failed: The provided response does not match the challenge.",
      "User mismatch: The token was not issued for the specified user_id."
    ],
    "usage": "Provide user_id, token_id from MFA generation, and user_response to verify the MFA challenge completion.",
    "output_details": {
      "is_verified": {
        "type": "boolean",
        "description": "Whether the MFA verification was successful"
      },
      "verification_time": {
        "type": "string",
        "description": "Timestamp of verification attempt"
      },
      "remaining_attempts": {
        "type": "integer",
        "description": "Number of verification attempts remaining"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Session Token Manager",
    "tool_description": "Creates, validates, and manages JWT session tokens with configurable expiration, claims, and refresh capabilities for authenticated users.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "Unique identifier for the authenticated user"
      },
      "operation": {
        "type": "string",
        "required": true,
        "description": "Operation type: create, validate, refresh, revoke"
      },
      "existing_token": {
        "type": "string",
        "required": false,
        "description": "Existing JWT token for validate/refresh/revoke operations",
        "default": "None"
      },
      "session_duration": {
        "type": "integer",
        "required": false,
        "description": "Session duration in minutes",
        "default": 60
      },
      "refresh_enabled": {
        "type": "boolean",
        "required": false,
        "description": "Whether refresh tokens should be generated",
        "default": true
      },
      "user_roles": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "User roles to include in token claims",
        "default": "None"
      },
      "custom_claims": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Additional custom claims as key:value pairs",
        "default": "None"
      },
      "ip_address": {
        "type": "string",
        "required": false,
        "description": "Client IP address for security binding",
        "default": "None"
      },
      "device_fingerprint": {
        "type": "string",
        "required": false,
        "description": "Device fingerprint for additional security",
        "default": "None"
      }
    },
    "error_messages": [
      "Invalid operation: Use one of [create, validate, refresh, revoke].",
      "Missing token: validate, refresh, and revoke operations require existing_token parameter.",
      "Invalid token format: The provided token is not a valid JWT format.",
      "Token expired: The session token has exceeded its validity period.",
      "Invalid session duration: session_duration must be between 5 and 10080 minutes (1 week).",
      "User not authorized: The user does not have permission to perform this operation.",
      "Token validation failed: The token signature or claims are invalid."
    ],
    "usage": "Specify user_id and operation type, provide existing_token for validation operations, and configure session parameters for token creation.",
    "output_details": {
      "access_token": {
        "type": "string",
        "description": "JWT access token for API authentication"
      },
      "refresh_token": {
        "type": "string",
        "description": "Refresh token for obtaining new access tokens"
      },
      "expires_at": {
        "type": "string",
        "description": "Token expiration timestamp"
      },
      "is_valid": {
        "type": "boolean",
        "description": "Whether the token is valid (for validate operation)"
      },
      "token_claims": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Extracted claims from the token"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Identity Provider Connector",
    "tool_description": "Connects to external identity providers (LDAP, Active Directory, OAuth providers) to authenticate users and retrieve identity information.",
    "parameters": {
      "provider_type": {
        "type": "string",
        "required": true,
        "description": "Identity provider type: ldap, active_directory, oauth2, saml, openid_connect"
      },
      "provider_url": {
        "type": "string",
        "required": true,
        "description": "URL or connection string for the identity provider"
      },
      "username": {
        "type": "string",
        "required": true,
        "description": "Username for authentication"
      },
      "credentials": {
        "type": "string",
        "required": true,
        "description": "Password or token for authentication"
      },
      "domain": {
        "type": "string",
        "required": false,
        "description": "Domain name for AD/LDAP authentication",
        "default": "None"
      },
      "base_dn": {
        "type": "string",
        "required": false,
        "description": "Base DN for LDAP searches",
        "default": "None"
      },
      "client_id": {
        "type": "string",
        "required": false,
        "description": "OAuth client ID",
        "default": "None"
      },
      "client_secret": {
        "type": "string",
        "required": false,
        "description": "OAuth client secret",
        "default": "None"
      },
      "scope": {
        "type": "string",
        "required": false,
        "description": "OAuth scope for permissions",
        "default": "openid profile email"
      },
      "timeout_seconds": {
        "type": "integer",
        "required": false,
        "description": "Connection timeout in seconds",
        "default": 30
      }
    },
    "error_messages": [
      "Unsupported provider: Use one of [ldap, active_directory, oauth2, saml, openid_connect].",
      "Connection failed: Unable to connect to the identity provider at the specified URL.",
      "Authentication failed: Invalid credentials provided for the identity provider.",
      "Missing required parameters: OAuth providers require client_id and client_secret.",
      "LDAP configuration error: LDAP providers require base_dn parameter.",
      "Timeout exceeded: Connection to identity provider timed out.",
      "SSL/TLS error: Secure connection to identity provider could not be established."
    ],
    "usage": "Configure provider connection details and credentials to authenticate users against external identity systems and retrieve user attributes.",
    "output_details": {
      "authentication_status": {
        "type": "string",
        "description": "Authentication result: success, failed, error"
      },
      "user_attributes": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Retrieved user attributes from identity provider"
      },
      "groups": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "User group memberships"
      },
      "provider_user_id": {
        "type": "string",
        "description": "User identifier from the identity provider"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "User Credential Validator",
    "tool_description": "Validates user credentials against database-stored password hashes using secure hashing algorithms and timing-attack resistant comparison.",
    "parameters": {
      "username": {
        "type": "string",
        "required": true,
        "description": "Username or email address for login"
      },
      "password": {
        "type": "string",
        "required": true,
        "description": "Plain text password provided by user"
      },
      "database_connection": {
        "type": "string",
        "required": true,
        "description": "Database connection string or identifier"
      }
    },
    "error_messages": [
      "Database connection failed: Unable to connect to the user credential database.",
      "User not found: The specified username does not exist in the system.",
      "Invalid credentials: The provided password does not match the stored hash.",
      "Account disabled: The user account has been disabled or suspended.",
      "Database query error: Error occurred while querying user credentials."
    ],
    "usage": "Provide username, password, and database connection to validate user credentials against stored password hashes with secure comparison methods.",
    "output_details": {
      "is_valid": {
        "type": "boolean",
        "description": "Whether the credentials are valid"
      },
      "user_id": {
        "type": "string",
        "description": "Internal user identifier if validation successful"
      },
      "account_status": {
        "type": "string",
        "description": "User account status: active, disabled, locked, expired"
      },
      "last_login": {
        "type": "string",
        "description": "Timestamp of user's last successful login"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Biometric Data Processor",
    "tool_description": "Processes and matches biometric data including fingerprints, facial recognition, and voice patterns for identity verification.",
    "parameters": {
      "biometric_type": {
        "type": "string",
        "required": true,
        "description": "Type of biometric data: fingerprint, face, voice, iris"
      },
      "biometric_data": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded biometric data for processing"
      },
      "operation": {
        "type": "string",
        "required": true,
        "description": "Operation type: enroll, verify, identify"
      },
      "user_id": {
        "type": "string",
        "required": false,
        "description": "User identifier for enrollment or verification",
        "default": "None"
      },
      "quality_threshold": {
        "type": "number",
        "required": false,
        "description": "Minimum quality score for biometric data (0.0-1.0)",
        "default": 0.7
      },
      "match_threshold": {
        "type": "number",
        "required": false,
        "description": "Minimum match score for verification (0.0-1.0)",
        "default": 0.8
      },
      "template_format": {
        "type": "string",
        "required": false,
        "description": "Biometric template format: iso, ansi, proprietary",
        "default": "iso"
      }
    },
    "error_messages": [
      "Invalid biometric type: Use one of [fingerprint, face, voice, iris].",
      "Poor biometric quality: The provided biometric data does not meet quality requirements.",
      "Invalid data format: The biometric_data is not properly base64 encoded.",
      "Template extraction failed: Unable to extract biometric features from provided data.",
      "No enrolled templates: User has no enrolled biometric templates for comparison.",
      "Invalid threshold values: quality_threshold and match_threshold must be between 0.0 and 1.0."
    ],
    "usage": "Provide biometric data and specify operation type to enroll new templates, verify against existing templates, or identify users from biometric samples.",
    "output_details": {
      "operation_status": {
        "type": "string",
        "description": "Processing result: success, failed, insufficient_quality"
      },
      "quality_score": {
        "type": "number",
        "description": "Quality score of the provided biometric data"
      },
      "match_score": {
        "type": "number",
        "description": "Match score for verification operations"
      },
      "template_id": {
        "type": "string",
        "description": "Generated template identifier for enrollment"
      },
      "matched_user_id": {
        "type": "string",
        "description": "Identified user ID for identification operations"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Access Attempt Logger",
    "tool_description": "Logs and monitors authentication attempts, tracking successful and failed logins with detailed context for security auditing and threat detection.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "User identifier attempting authentication"
      },
      "attempt_result": {
        "type": "string",
        "required": true,
        "description": "Result of authentication attempt: success, failed, blocked"
      },
      "ip_address": {
        "type": "string",
        "required": true,
        "description": "Source IP address of the authentication attempt"
      },
      "user_agent": {
        "type": "string",
        "required": true,
        "description": "Browser or client user agent string"
      },
      "authentication_method": {
        "type": "string",
        "required": true,
        "description": "Method used: password, mfa, biometric, certificate, sso"
      },
      "failure_reason": {
        "type": "string",
        "required": false,
        "description": "Reason for failed attempts: invalid_password, account_locked, expired_account",
        "default": "None"
      },
      "geolocation": {
        "type": "string",
        "required": false,
        "description": "Geographic location of the attempt",
        "default": "None"
      },
      "session_id": {
        "type": "string",
        "required": false,
        "description": "Session identifier for successful logins",
        "default": "None"
      }
    },
    "error_messages": [
      "Invalid attempt result: Use one of [success, failed, blocked].",
      "Invalid authentication method: Use one of [password, mfa, biometric, certificate, sso].",
      "Missing IP address: ip_address parameter is required for security logging.",
      "Log storage error: Unable to write authentication log to storage system.",
      "Invalid user_id format: User identifier must be a non-empty string."
    ],
    "usage": "Log each authentication attempt with result, context information, and failure reasons to maintain comprehensive audit trails for security analysis.",
    "output_details": {
      "log_entry_id": {
        "type": "string",
        "description": "Unique identifier for the logged entry"
      },
      "timestamp": {
        "type": "string",
        "description": "Timestamp when the log entry was created"
      },
      "risk_score": {
        "type": "integer",
        "description": "Calculated risk score for this attempt (0-100)"
      },
      "alert_triggered": {
        "type": "boolean",
        "description": "Whether this attempt triggered a security alert"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Account Lockout Manager",
    "tool_description": "Manages account lockout policies based on failed authentication attempts, including automatic lockouts, manual controls, and unlock procedures.",
    "parameters": {
      "user_id": {
        "type": "string",
        "required": true,
        "description": "User identifier to check or modify lockout status"
      },
      "operation": {
        "type": "string",
        "required": true,
        "description": "Operation type: check_status, increment_failures, lock_account, unlock_account, reset_failures"
      },
      "max_failed_attempts": {
        "type": "integer",
        "required": false,
        "description": "Maximum failed attempts before lockout",
        "default": 5
      },
      "lockout_duration": {
        "type": "integer",
        "required": false,
        "description": "Lockout duration in minutes",
        "default": 30
      },
      "admin_override": {
        "type": "boolean",
        "required": false,
        "description": "Whether this is an administrative override",
        "default": false
      }
    },
    "error_messages": [
      "Invalid operation: Use one of [check_status, increment_failures, lock_account, unlock_account, reset_failures].",
      "User not found: The specified user_id does not exist in the system.",
      "Invalid lockout parameters: max_failed_attempts must be 1-20, lockout_duration must be 1-1440 minutes.",
      "Lockout policy violation: Cannot unlock account before lockout duration expires without admin override.",
      "Database error: Unable to update account lockout status in the database."
    ],
    "usage": "Manage account lockout status by checking current state, tracking failed attempts, applying lockouts, and handling unlock procedures according to security policies.",
    "output_details": {
      "current_status": {
        "type": "string",
        "description": "Current account status: active, locked, disabled"
      },
      "failed_attempts": {
        "type": "integer",
        "description": "Number of consecutive failed login attempts"
      },
      "locked_until": {
        "type": "string",
        "description": "Timestamp when account will be automatically unlocked"
      },
      "remaining_attempts": {
        "type": "integer",
        "description": "Number of attempts remaining before lockout"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Certificate Validator",
    "tool_description": "Validates digital certificates for client authentication, checking certificate chains, expiration, revocation status, and compliance with security policies.",
    "parameters": {
      "certificate_data": {
        "type": "string",
        "required": true,
        "description": "Base64 encoded certificate data (PEM or DER format)"
      },
      "certificate_chain": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Array of intermediate certificates in the chain",
        "default": "None"
      },
      "trusted_ca_list": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": true,
        "description": "List of trusted Certificate Authority identifiers"
      },
      "check_revocation": {
        "type": "boolean",
        "required": false,
        "description": "Whether to check certificate revocation status",
        "default": true
      },
      "allow_self_signed": {
        "type": "boolean",
        "required": false,
        "description": "Whether self-signed certificates are allowed",
        "default": false
      },
      "max_chain_length": {
        "type": "integer",
        "required": false,
        "description": "Maximum allowed certificate chain length",
        "default": 5
      },
      "required_key_usage": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "required": false,
        "description": "Required key usage extensions",
        "default": "None"
      },
      "hostname_verification": {
        "type": "string",
        "required": false,
        "description": "Hostname to verify against certificate subject",
        "default": "None"
      }
    },
    "error_messages": [
      "Invalid certificate format: Certificate data is not valid PEM or DER format.",
      "Certificate expired: The certificate has passed its expiration date.",
      "Untrusted certificate: Certificate is not signed by a trusted Certificate Authority.",
      "Certificate revoked: Certificate has been revoked and appears on CRL or OCSP.",
      "Chain validation failed: Certificate chain cannot be validated to a trusted root.",
      "Key usage violation: Certificate does not have required key usage extensions.",
      "Hostname mismatch: Certificate subject does not match the specified hostname.",
      "Self-signed not allowed: Self-signed certificates are not permitted by policy."
    ],
    "usage": "Provide certificate data and validation parameters to verify certificate authenticity, validity, and compliance with security policies for client authentication.",
    "output_details": {
      "is_valid": {
        "type": "boolean",
        "description": "Whether the certificate passed all validation checks"
      },
      "subject": {
        "type": "string",
        "description": "Certificate subject distinguished name"
      },
      "issuer": {
        "type": "string",
        "description": "Certificate issuer distinguished name"
      },
      "expires_at": {
        "type": "string",
        "description": "Certificate expiration timestamp"
      },
      "serial_number": {
        "type": "string",
        "description": "Certificate serial number"
      },
      "validation_errors": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "List of validation errors found"
      }
    }
  }
  ```

  ```json
  {
    "tool_name": "Single Sign On Handler",
    "tool_description": "Handles Single Sign-On authentication flows including SAML assertions, OAuth tokens, and OpenID Connect claims for seamless cross-application authentication.",
    "parameters": {
      "sso_protocol": {
        "type": "string",
        "required": true,
        "description": "SSO protocol type: saml2, oauth2, openid_connect, cas"
      },
      "token_data": {
        "type": "string",
        "required": true,
        "description": "SSO token, assertion, or authorization code"
      },
      "issuer_url": {
        "type": "string",
        "required": true,
        "description": "URL of the identity provider or authorization server"
      },
      "client_id": {
        "type": "string",
        "required": false,
        "description": "Client identifier for OAuth/OIDC flows",
        "default": "None"
      },
      "redirect_uri": {
        "type": "string",
        "required": false,
        "description": "Redirect URI for OAuth/OIDC validation",
        "default": "None"
      }
    },
    "error_messages": [
      "Unsupported SSO protocol: Use one of [saml2, oauth2, openid_connect, cas].",
      "Invalid token format: The provided token_data is not in the expected format for the protocol.",
      "Token validation failed: Unable to validate the SSO token signature or claims.",
      "Issuer not trusted: The token issuer is not in the list of trusted identity providers.",
      "Token expired: The SSO token has exceeded its validity period.",
      "Audience mismatch: Token audience does not match this application's identifier.",
      "Missing required claims: Token does not contain required user identity claims."
    ],
    "usage": "Process SSO tokens and assertions from trusted identity providers to authenticate users across multiple applications without repeated login prompts.",
    "output_details": {
      "authentication_status": {
        "type": "string",
        "description": "SSO authentication result: success, failed, invalid_token"
      },
      "user_identity": {
        "type": "string",
        "description": "Authenticated user identifier from SSO provider"
      },
      "user_attributes": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "User attributes and claims from SSO token"
      },
      "session_index": {
