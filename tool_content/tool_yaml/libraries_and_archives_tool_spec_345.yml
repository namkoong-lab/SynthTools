field_name: libraries_and_archives
subfield: Digital Collection Management
task: Digital asset ingestion and metadata extraction from various file formats
tool_description: "**STEP 1 — Rate task difficulty**\n\nThis task involves handling diverse file formats, extracting complex metadata schemas, ensuring data quality validation, and integrating with various systems. The scope includes technical file processing, metadata standardization, and workflow orchestration with significant risk of data loss or corruption. This is a **hard** difficulty task.\n\n**STEP 2 — Set a tool budget**\n\nGiven the hard difficulty rating, I'm targeting **17 tools** within the 15-20 range to handle the comprehensive workflows needed for digital asset ingestion and metadata extraction across various file formats.\n\n**STEP 3 — Tool names with dependencies and affordances**\n\n1. **File Format Detector** - Consumes: file paths → Produces: format identification\n2. **Batch File Scanner** - Consumes: directory paths → Produces: file inventories\n3. **Basic Metadata Extractor** - Consumes: file paths, formats → Produces: technical metadata\n4. **Advanced Metadata Extractor** - Consumes: file paths, extraction rules → Produces: specialized metadata\n5. **Text Content Extractor** - Consumes: document files → Produces: extracted text content\n6. **Media Properties Analyzer** - Consumes: media files → Produces: technical specifications\n7. **Metadata Schema Validator** - Consumes: metadata records, schema rules → Produces: validation results\n8. **Dublin Core Converter** - Consumes: raw metadata → Produces: Dublin Core standardized metadata\n9. **Custom Schema Mapper** - Consumes: metadata, mapping rules → Produces: transformed metadata\n10. **Duplicate Asset Detector** - Consumes: file lists, comparison criteria → Produces: duplicate reports\n11. **Asset Quality Checker** - Consumes: files, quality criteria → Produces: quality assessments\n12. **Ingestion Workflow Manager** - Consumes: workflow definitions, file lists → Produces: processing schedules\n13. **Metadata Batch Processor** - Consumes: file batches, processing rules → Produces: processed metadata sets\n14. **Collection Organizer** - Consumes: assets, organizational rules → Produces: structured collections\n15. **Ingestion Report Generator** - Consumes: processing logs, statistics → Produces: comprehensive reports\n16. **Error Recovery Handler** - Consumes: failed processing records → Produces: recovery recommendations\n17. **Export Formatter** - Consumes: metadata records, target formats → Produces: formatted exports\n\n**STEP 4 — Multi-tool plans**\n\n**Simple Plans:**\n1. Basic single-file ingestion: File Format Detector → Basic Metadata Extractor → Dublin Core Converter → Export Formatter\n2. Quality check workflow: File Format Detector → Asset Quality Checker → Ingestion Report Generator\n\n**Medium Plans:**\n1. Standard batch processing: Batch File Scanner → File Format Detector → Advanced Metadata Extractor → Metadata Schema Validator → Collection Organizer → Ingestion Report Generator\n2. Content analysis pipeline: File Format Detector → Text Content Extractor → Media Properties Analyzer → Custom Schema Mapper → Export Formatter\n\n**Complex Plans:**\n1. Full enterprise ingestion: Batch File Scanner → Duplicate Asset Detector → File Format Detector → Advanced Metadata Extractor → Text Content Extractor → Media Properties Analyzer → Metadata Schema Validator → Custom Schema Mapper → Asset Quality Checker → Ingestion Workflow Manager → Metadata Batch Processor → Collection Organizer → Ingestion Report Generator → Error Recovery Handler\n2. Multi-format migration project: Batch File Scanner → File Format Detector → Advanced Metadata Extractor → Dublin Core Converter → Custom Schema Mapper → Duplicate Asset Detector → Asset Quality Checker → Collection Organizer → Export Formatter → Ingestion Report Generator\n\n**STEP 5 — Tools**\n\n```json\n{\n  \"tool_name\": \"File Format Detector\",\n  \"tool_description\": \"Identifies file formats and MIME types from file paths using extension analysis and magic number detection.\",\n  \"parameters\": {\n    \"file_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\"\
  : \"Full path to the file to be analyzed\"\n    },\n    \"include_confidence\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Whether to include confidence scores in detection results\"\n    }\n  },\n  \"error_messages\": [\n    \"File not found: The specified file path does not exist or is inaccessible\",\n    \"Permission denied: Insufficient permissions to read the file\",\n    \"Corrupted file: File appears to be corrupted and cannot be analyzed\"\n  ],\n  \"usage\": \"Provide a valid file_path to identify the format. Set include_confidence to true for detection certainty scores.\",\n  \"output_details\": {\n    \"file_format\": {\n      \"type\": \"string\",\n      \"description\": \"Detected file format name\"\n    },\n    \"mime_type\": {\n      \"type\": \"string\", \n      \"description\": \"MIME type of the detected format\"\n    },\n    \"confidence_score\": {\n      \"type\": \"number\",\n      \"description\": \"Detection confidence between 0 and 1 (only if include_confidence is true)\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Batch File Scanner\",\n  \"tool_description\": \"Scans directories recursively to inventory files with filtering options and generates comprehensive file lists for batch processing.\",\n  \"parameters\": {\n    \"directory_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Root directory path to scan for files\"\n    },\n    \"file_extensions\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Array of file extensions to include (e.g., ['pdf', 'jpg', 'xml'])\"\n    },\n    \"max_depth\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"default\": -1,\n      \"description\": \"Maximum directory depth to scan (-1 for unlimited)\"\n    },\n    \"min_file_size\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"default\": 0,\n      \"description\": \"Minimum file size in bytes to include\"\n    },\n    \"max_file_size\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Maximum file size in bytes to include\"\n    },\n    \"include_hidden\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Whether to include hidden files and directories\"\n    },\n    \"exclude_patterns\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Array of regex patterns for files/directories to exclude\"\n    }\n  },\n  \"error_messages\": [\n    \"Directory not found: The specified directory path does not exist\",\n    \"Access denied: Insufficient permissions to read the directory\",\n    \"Invalid depth: max_depth must be -1 or a positive integer\",\n    \"Invalid size range: min_file_size cannot be greater than max_file_size\",\n    \"Invalid regex pattern: One or more exclude_patterns contains invalid regex syntax\"\n  ],\n  \"usage\": \"Specify directory_path and optionally filter by file_extensions, size limits, depth, and exclude patterns to generate a comprehensive file inventory.\",\n  \"output_details\": {\n    \"total_files\": {\n      \"type\": \"integer\",\n      \"description\": \"Total number of files found matching criteria\"\n    },\n    \"file_paths\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of full file paths found during scan\"\n    },\n    \"total_size\": {\n      \"type\": \"integer\",\n      \"description\": \"Combined size of all found files in bytes\"\n    },\n    \"scan_duration\": {\n      \"type\": \"number\",\n      \"description\": \"Time taken to complete scan in seconds\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Basic Metadata Extractor\",\n  \"tool_description\": \"Extracts fundamental metadata properties from files including\
  \ file system attributes, basic technical properties, and standard embedded metadata.\",\n  \"parameters\": {\n    \"file_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Path to the file for metadata extraction\"\n    },\n    \"extract_embedded\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": true,\n      \"description\": \"Whether to extract embedded metadata from file headers\"\n    },\n    \"include_checksums\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Whether to calculate file checksums (MD5, SHA256)\"\n    }\n  },\n  \"error_messages\": [\n    \"File not accessible: Cannot read the specified file due to permissions or file not found\",\n    \"Unsupported format: File format is not supported for metadata extraction\",\n    \"Corrupted metadata: File contains corrupted or unreadable metadata sections\"\n  ],\n  \"usage\": \"Provide file_path and optionally enable extract_embedded and include_checksums for comprehensive basic metadata extraction.\",\n  \"output_details\": {\n    \"filename\": {\n      \"type\": \"string\",\n      \"description\": \"Original filename without path\"\n    },\n    \"file_size\": {\n      \"type\": \"integer\",\n      \"description\": \"File size in bytes\"\n    },\n    \"creation_date\": {\n      \"type\": \"string\",\n      \"description\": \"File creation timestamp in ISO format\"\n    },\n    \"modification_date\": {\n      \"type\": \"string\", \n      \"description\": \"File last modification timestamp in ISO format\"\n    },\n    \"file_format\": {\n      \"type\": \"string\",\n      \"description\": \"Detected file format\"\n    },\n    \"embedded_metadata\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of key-value pairs from embedded metadata\"\n    },\n    \"md5_checksum\": {\n      \"type\": \"string\",\n      \"description\": \"MD5 hash of file contents (if include_checksums enabled)\"\n    },\n    \"sha256_checksum\": {\n      \"type\": \"string\",\n      \"description\": \"SHA256 hash of file contents (if include_checksums enabled)\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Advanced Metadata Extractor\",\n  \"tool_description\": \"Performs sophisticated metadata extraction using format-specific parsers, custom extraction rules, and deep content analysis for specialized digital assets.\",\n  \"parameters\": {\n    \"file_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Path to the file for advanced metadata extraction\"\n    },\n    \"extraction_profile\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Extraction profile: academic_papers, historical_documents, artwork, photographs, audio_visual, manuscripts, maps, datasets\"\n    },\n    \"custom_fields\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Array of custom metadata field names to extract\"\n    },\n    \"ocr_enabled\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Enable OCR for text extraction from images\"\n    },\n    \"language_detection\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Enable automatic language detection for text content\"\n    },\n    \"extract_entities\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Extract named entities (persons, places, organizations)\"\n    },\n    \"content_analysis_depth\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"default\": \"standard\",\n      \"description\": \"Analysis depth: minimal, standard, comprehensive\"\n    },\n    \"preserve_structure\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": true,\n      \"description\"\
  : \"Maintain hierarchical structure in extracted metadata\"\n    },\n    \"timeout_seconds\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"default\": 300,\n      \"description\": \"Maximum processing time in seconds\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid extraction profile: Use one of [academic_papers, historical_documents, artwork, photographs, audio_visual, manuscripts, maps, datasets]\",\n    \"Processing timeout: Extraction exceeded the specified timeout limit\",\n    \"OCR failure: OCR processing failed due to poor image quality or unsupported format\",\n    \"Entity extraction error: Named entity recognition failed due to unsupported language or content type\",\n    \"Invalid analysis depth: Use minimal, standard, or comprehensive\",\n    \"Custom field error: One or more custom field specifications are invalid\"\n  ],\n  \"usage\": \"Specify file_path and extraction_profile, then configure advanced options like OCR, language detection, and entity extraction based on your collection needs.\",\n  \"output_details\": {\n    \"profile_metadata\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Metadata fields specific to the chosen extraction profile\"\n    },\n    \"custom_metadata\": {\n      \"type\": \"array\", \n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Values for requested custom metadata fields\"\n    },\n    \"extracted_text\": {\n      \"type\": \"string\",\n      \"description\": \"Full text content extracted from the file\"\n    },\n    \"detected_language\": {\n      \"type\": \"string\",\n      \"description\": \"Primary language detected in content\"\n    },\n    \"named_entities\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of identified named entities\"\n    },\n    \"processing_time\": {\n      \"type\": \"number\",\n      \"description\": \"Time taken for extraction in seconds\"\n    },\n    \"confidence_scores\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Confidence scores for various extraction components\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Text Content Extractor\",\n  \"tool_description\": \"Specialized tool for extracting and preprocessing text content from various document formats with advanced text processing capabilities.\",\n  \"parameters\": {\n    \"file_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Path to the document file for text extraction\"\n    },\n    \"preserve_formatting\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Whether to preserve original formatting marks\"\n    },\n    \"extract_tables\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Whether to extract and structure table content\"\n    },\n    \"extract_footnotes\": {\n      \"type\": \"boolean\", \n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Whether to extract footnotes and references\"\n    },\n    \"clean_text\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": true,\n      \"description\": \"Apply text cleaning and normalization\"\n    }\n  },\n  \"error_messages\": [\n    \"Unsupported document format: The file format is not supported for text extraction\",\n    \"Encrypted document: Cannot extract text from password-protected or encrypted documents\",\n    \"Corrupted document: Document structure is corrupted and cannot be processed\",\n    \"Empty document: No extractable text content found in the document\"\n  ],\n  \"usage\": \"Provide file_path and configure text extraction options based on whether you need formatted content, tables, footnotes, or cleaned text output.\",\n  \"output_details\": {\n    \"raw_text\": {\n      \"type\": \"string\",\n      \"description\": \"Complete extracted text content\"\n    },\n    \"word_count\"\
  : {\n      \"type\": \"integer\",\n      \"description\": \"Total number of words in extracted text\"\n    },\n    \"character_count\": {\n      \"type\": \"integer\",\n      \"description\": \"Total character count including spaces\"\n    },\n    \"table_data\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Extracted table content in structured format\"\n    },\n    \"footnotes\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of extracted footnotes and references\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Media Properties Analyzer\",\n  \"tool_description\": \"Analyzes technical properties of multimedia files including dimensions, codecs, quality metrics, and media-specific metadata for audio, video, and image files.\",\n  \"parameters\": {\n    \"file_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Path to the media file to analyze\"\n    },\n    \"analyze_quality\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Perform quality assessment analysis\"\n    },\n    \"extract_thumbnails\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Generate and extract thumbnail images\"\n    },\n    \"deep_codec_analysis\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Perform detailed codec and compression analysis\"\n    }\n  },\n  \"error_messages\": [\n    \"Unsupported media format: The file format is not recognized as a valid media file\",\n    \"Corrupted media file: The media file appears to be corrupted or incomplete\",\n    \"Codec not supported: The media file uses codecs not supported for analysis\",\n    \"Insufficient data: Media file lacks sufficient data for comprehensive analysis\"\n  ],\n  \"usage\": \"Specify file_path for basic media analysis, enable analyze_quality for quality metrics, extract_thumbnails for preview generation, and deep_codec_analysis for detailed technical information.\",\n  \"output_details\": {\n    \"media_type\": {\n      \"type\": \"string\",\n      \"description\": \"Type of media: image, audio, video\"\n    },\n    \"dimensions\": {\n      \"type\": \"string\",\n      \"description\": \"Media dimensions in format 'widthxheight' for images/video\"\n    },\n    \"duration\": {\n      \"type\": \"number\",\n      \"description\": \"Duration in seconds for audio/video files\"\n    },\n    \"codec_info\": {\n      \"type\": \"string\",\n      \"description\": \"Primary codec information\"\n    },\n    \"bitrate\": {\n      \"type\": \"integer\",\n      \"description\": \"Bitrate in bits per second\"\n    },\n    \"quality_score\": {\n      \"type\": \"number\",\n      \"description\": \"Quality assessment score 0-10 (if analyze_quality enabled)\"\n    },\n    \"color_profile\": {\n      \"type\": \"string\",\n      \"description\": \"Color space/profile information\"\n    },\n    \"compression_ratio\": {\n      \"type\": \"number\",\n      \"description\": \"Compression ratio (if deep_codec_analysis enabled)\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Metadata Schema Validator\",\n  \"tool_description\": \"Validates metadata records against predefined or custom schemas, ensuring compliance with standards like Dublin Core, MODS, or institutional requirements.\",\n  \"parameters\": {\n    \"metadata_record\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"JSON string representation of the metadata record to validate\"\n    },\n    \"schema_type\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Schema standard: dublin_core, mods, ead, custom\"\n    },\n    \"custom_schema\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Custom schema definition (required if schema_type is 'custom')\"\n   \
  \ },\n    \"strict_mode\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Enable strict validation with no tolerance for minor deviations\"\n    },\n    \"required_fields\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Array of field names that must be present\"\n    },\n    \"field_constraints\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Array of field constraint rules in format 'field:constraint'\"\n    },\n    \"vocabulary_checking\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Validate controlled vocabulary terms\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid metadata format: The metadata_record is not valid JSON\",\n    \"Unknown schema type: Use dublin_core, mods, ead, or custom\",\n    \"Missing custom schema: custom_schema is required when schema_type is 'custom'\",\n    \"Invalid schema definition: The custom schema contains syntax errors\",\n    \"Constraint syntax error: One or more field_constraints has invalid syntax (use 'field:constraint' format)\"\n  ],\n  \"usage\": \"Provide metadata_record as JSON string and specify schema_type. For custom schemas, include custom_schema definition. Configure validation strictness and field requirements as needed.\",\n  \"output_details\": {\n    \"is_valid\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether the metadata record passes validation\"\n    },\n    \"validation_errors\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of validation error messages\"\n    },\n    \"validation_warnings\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of validation warnings for best practices\"\n    },\n    \"missing_required\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of missing required field names\"\n    },\n    \"compliance_score\": {\n      \"type\": \"number\",\n      \"description\": \"Compliance score from 0 to 1\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Dublin Core Converter\",\n  \"tool_description\": \"Converts metadata from various formats to Dublin Core standard with mapping rules and element refinement options.\",\n  \"parameters\": {\n    \"source_metadata\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"JSON string of source metadata to convert\"\n    },\n    \"source_format\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Source metadata format: mods, marc, ead, custom\"\n    },\n    \"use_qualified_dc\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Use qualified Dublin Core with element refinements\"\n    },\n    \"mapping_profile\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"default\": \"standard\",\n      \"description\": \"Mapping profile: standard, library, museum, archive\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid source metadata: The source_metadata is not valid JSON\",\n    \"Unsupported source format: Use mods, marc, ead, or custom\",\n    \"Invalid mapping profile: Use standard, library, museum, or archive\",\n    \"Conversion failed: Unable to map required fields from source to Dublin Core\"\n  ],\n  \"usage\": \"Provide source_metadata as JSON and specify source_format. Choose mapping_profile based on your institution type and enable use_qualified_dc for refined elements.\",\n  \"output_details\": {\n    \"dublin_core_record\": {\n      \"type\": \"string\",\n      \"description\": \"JSON string of converted Dublin Core metadata\"\n    },\n    \"mapped_fields\": {\n      \"type\": \"array\",\n      \"items\": {\"type\"\
  : \"string\"},\n      \"description\": \"Array of successfully mapped field names\"\n    },\n    \"unmapped_fields\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of source fields that could not be mapped\"\n    },\n    \"conversion_quality\": {\n      \"type\": \"number\",\n      \"description\": \"Quality score of conversion from 0 to 1\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Custom Schema Mapper\",\n  \"tool_description\": \"Maps metadata between different schema formats using configurable transformation rules and field mapping definitions.\",\n  \"parameters\": {\n    \"source_metadata\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"JSON string of source metadata to transform\"\n    },\n    \"target_schema\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Target schema name or identifier\"\n    },\n    \"mapping_rules\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": true,\n      \"description\": \"Array of mapping rules in format 'source_field->target_field'\"\n    },\n    \"transformation_functions\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Array of transformation functions to apply: uppercase, lowercase, date_format, split, merge\"\n    },\n    \"default_values\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Default values for target fields in format 'field:value'\"\n    },\n    \"conditional_mapping\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Conditional mapping rules in format 'if:condition:then:mapping'\"\n    },\n    \"preserve_unmapped\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Include unmapped source fields in output\"\n    },\n    \"validate_output\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": true,\n      \"description\": \"Validate the mapped output against target schema\"\n    },\n    \"error_handling\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"default\": \"skip\",\n      \"description\": \"Error handling strategy: skip, default, fail\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid source metadata: The source_metadata is not valid JSON\",\n    \"Invalid mapping rule: One or more mapping_rules has incorrect format (use 'source->target')\",\n    \"Unknown transformation function: Use uppercase, lowercase, date_format, split, or merge\",\n    \"Invalid default value format: Use 'field:value' format for default_values\",\n    \"Invalid conditional rule: Conditional mapping rules must follow 'if:condition:then:mapping' format\",\n    \"Invalid error handling strategy: Use skip, default, or fail\"\n  ],\n  \"usage\": \"Provide source_metadata, target_schema, and mapping_rules. Optionally specify transformation_functions, default_values, and conditional_mapping for complex transformations.\",\n  \"output_details\": {\n    \"mapped_metadata\": {\n      \"type\": \"string\",\n      \"description\": \"JSON string of transformed metadata in target schema\"\n    },\n    \"mapping_success\": {\n      \"type\": \"boolean\",\n      \"description\": \"Whether the mapping completed successfully\"\n    },\n    \"applied_rules\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of mapping rules that were successfully applied\"\n    },\n    \"failed_mappings\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Array of mapping rules that failed\"\n    },\n    \"transformation_log\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\"\
  : \"Log of transformations applied during mapping\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Duplicate Asset Detector\",\n  \"tool_description\": \"Identifies duplicate and near-duplicate digital assets using various comparison methods including file hashing, content similarity, and metadata matching.\",\n  \"parameters\": {\n    \"file_paths\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": true,\n      \"description\": \"Array of file paths to check for duplicates\"\n    },\n    \"comparison_method\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Comparison method: hash, content_similarity, metadata, filename, hybrid\"\n    },\n    \"similarity_threshold\": {\n      \"type\": \"number\",\n      \"required\": false,\n      \"default\": 0.95,\n      \"description\": \"Similarity threshold for near-duplicate detection (0.0-1.0)\"\n    },\n    \"hash_algorithm\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"default\": \"md5\",\n      \"description\": \"Hash algorithm for exact duplicates: md5, sha1, sha256\"\n    },\n    \"metadata_fields\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Specific metadata fields to compare for metadata-based detection\"\n    },\n    \"ignore_extensions\": {\n      \"type\": \"boolean\",\n      \"required\": false,\n      \"default\": false,\n      \"description\": \"Ignore file extensions when comparing filenames\"\n    }\n  },\n  \"error_messages\": [\n    \"Invalid comparison method: Use hash, content_similarity, metadata, filename, or hybrid\",\n    \"Invalid similarity threshold: Must be between 0.0 and 1.0\",\n    \"Invalid hash algorithm: Use md5, sha1, or sha256\", \n    \"Insufficient files: At least 2 files required for duplicate detection\",\n    \"File access error: One or more files in the array cannot be accessed\"\n  ],\n  \"usage\": \"Provide array of file_paths and choose comparison_method. Adjust similarity_threshold for near-duplicate sensitivity and specify metadata_fields for metadata-based comparison.\",\n  \"output_details\": {\n    \"duplicate_groups\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Groups of duplicate files, each group as comma-separated file paths\"\n    },\n    \"total_duplicates\": {\n      \"type\": \"integer\",\n      \"description\": \"Total number of duplicate files found\"\n    },\n    \"space_savings\": {\n      \"type\": \"integer\",\n      \"description\": \"Potential storage space savings in bytes\"\n    },\n    \"similarity_scores\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"number\"},\n      \"description\": \"Similarity scores for detected near-duplicates\"\n    }\n  }\n}\n```\n\n```json\n{\n  \"tool_name\": \"Asset Quality Checker\",\n  \"tool_description\": \"Evaluates digital asset quality using multiple criteria including file integrity, resolution standards, format compliance, and content assessment.\",\n  \"parameters\": {\n    \"file_path\": {\n      \"type\": \"string\",\n      \"required\": true,\n      \"description\": \"Path to the file to assess for quality\"\n    },\n    \"quality_standards\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"required\": true,\n      \"description\": \"Quality standards to apply: preservation, access, web, print\"\n    },\n    \"minimum_resolution\": {\n      \"type\": \"string\",\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Minimum resolution requirement in format 'widthxheight'\"\n    },\n    \"color_depth_requirement\": {\n      \"type\": \"integer\",\n      \"required\": false,\n      \"default\": null,\n      \"description\": \"Required color depth in bits per channel\""
