schema:
  type: object
  properties:
    field_name:
      type: string
    subfield_name:
      type: string
    task_name:
      type: string
template: |
  You design composable tools for LLM agents.
  
  You will be given: 
  (1) a Field name that represents a broad area of study or industry,

  (2) a subfield within that field, 

  (3) a specific task within that subfield.
  
  Your job is to propose a set of tools that could be used to accomplish this task. Note that these tools will be simulated by another LLM; therefore, their inputs, outputs, and internal functioning should be designed to be compatible with the LLM tool simulator.


  This step is part of a hierarchical domain evolution pipeline, which proceeds as follows:
  
  (1) From field → sub-domains
  (2) From sub-domains → tasks (within that sub-domain)
  (3) From task → tools (needed to accomplish those tasks)
  
  You are only responsible only for Step 3: suggesting a collection of tools that can be used to accomplish the given task. 


  Hint for generating tools:
  
  (1) Think about different workflows that exist in the task, divide it into sub-tasks to be accomplished by executable tools. 

  (2) Tools should be realistic and non overlapping.


  Guidelines:

  (1) Follow the following procedure:
  
      - STEP 1 — Rate task difficulty
        - Briefly (1–2 sentences) assess the task's difficulty as easy / medium / hard using: scope/breadth of subproblems, ambiguity or unknowns, coordination & dependencies, risk or impact of errors, data or infra requirements.
        
      - STEP 2 — Set a tool budget (more complex implies more tools)
        - Map the difficulty to a target range: easy implies 5–10 tools, medium implies 10–15 tools, hard implies 15–20 tools. Pick a concrete target within the range and aim ±2 tools if needed for coherence.

      - STEP 3 — List all the tool names and advertise upstream dependencies (what it consumes) and downstream affordances (what it produces) 
      
      - STEP 4 — List some multi-tool plans involving all or subset of tools. Include multiple tool-plans of simple, medium and complex difficulty (atleast two of each category), and describe the corresponding tasks they accomplish.
        
      - STEP 5 — Produce tools (small, focused, diverse).
  
  (2) For each tool include: 
      - Tool name: make sure it is specific to its function to avoid confusion with similar tools but that is not longer than 4 words.
      
      - Description: what the tool does.
      
      - Parameters Schema: all required parameters, their types, and constraints.
      
      - Error messages: complete list of possible errors, each with guidance on how to avoid it.
      
      - Usage: how to use the tool. 
      
      - Output format: schema of keys and value types for successful execution.
    
  (3) Rules:
      - Favor multiple small, orthogonal tools over mega-tools.
      
      - Tools must be composable with no overlapping functionality.
      
      - Parameter counts should vary:
        - At least two tools with 2 to 5 parameters
        - At least two tools with 5 to 10 parameters
        - At least two tools with more than 10 parameters
        - No tool may have zero parameters.
      
      - All required information (when the tool is called) must come from parameters only (no external state or environment variables).
      
      - Include all the error messages that could specify the complete functioning of the tool. Make sure error messages also provide information on how to avoid the error.
      
      - Tool description will also contain format of the output: this format would be a schema with key-names (that indicates what is being returned) and their corresponding value types. 
      
      - Constraints for parameters:
          1. If a parameter is optional, provide its default value. If no default value applies, explicitly specify None.
          2. Allowed types: string, number, integer, boolean, array. (Objects are not allowed.)
          3. Arrays must contain items of a single type (string, number, integer, boolean). Arrays of objects or array of arrays are not allowed. Optionally you can specify minimum and maximum number of items in the array. 
          4. When input required is Dates/times: represent them as strings with format `date-time`.
      
      - Constraints for the details of the output:
          1. For each key in the output format - its value type should be one of string, number, integer, boolean, array. (Objects are not allowed.)
          2. Arrays must contain items of a single type (string, number, integer, boolean). Arrays of objects or array of arrays are not allowed. 
          3. When value is Dates/times: represent as strings with format `date-time`.
          4. Outputs must be concise, avoiding very long values since tools are simulated by LLMs.


  Output format requirement: 
   - Write STEP 1, STEP 2, STEP 3, STEP 4 as plain text. 
   
   - For STEP 5, output each tool as a standalone fenced code block containing a JSON object (one object per tool).
   
   - Do not wrap the tools in an array.
   
   - Do not add extra prose or headings between or after the tool JSON objects.
   
   - For example:

  ```json
  {{
    "tool_name": "Example Tool",
    "tool_description": "This tool does X, Y, and Z to help with the task.",
    "parameters": {{
      "parameter1": {{
        "type": "string",
        "required": true,
        "description": "A brief description of parameter1"
      }},
      "parameter2": {{
        "type": "integer",
        "required": false,
        "description": "A brief description of parameter2"
        "default": "default value of the parameter"
      }}
    }},
    "error_messages": [
      "Error message 1: Description of when this error occurs.",
      "Error message 2: Description of when this error occurs.",
      "Error message 3: Description of when this error occurs."
    ],
    "usage": "Instructions on how to use the tool effectively.",
    "output_details": {{
      "key1": {{
        "type": "string",
        "description": "A brief description of key1"
      }},
      "key2": {{
        "type": "integer",
        "description": "A brief description of key2"
      }},
      "key3": {{
        "type": "array",
        "items": {{
        "type": "string"
        }},
        "description": "A brief description of key3"
      }} 
    }}
  }}
  ```

  Field Name: Financial Trading
  Subfield Name: Algorithmic Trading
  Task Name: Develop trading algorithms based on historical data
  ```json
  {{
    "tool_name": "Algorithmic Strategy Generator",
    "tool_description": "Generates and evaluates trading signals from historical market data using a chosen strategy family, with optional risk controls and sizing.",
    "parameters": {{
      "ticker_symbol": {{
        "type": "string",
        "required": true,
        "description": "Provide the ticker symbol of the stock to be analyzed."
      }},
      "start_time": {{
        "type": "string",
        "required": true,
        "description": "Start of the time range (UTC, ISO 8601).",
        "format": "date-time"
      }},
      "end_time": {{
        "type": "string",
        "required": true,
        "description": "End of the time range (UTC, ISO 8601).",
        "format": "date-time"
      }},
      "bar_freq": {{
        "type": "string",
        "required": false,
        "description": "Bar frequency, e.g., 1m, 5m, 1h, 1d."
      }},
      "strategy": {{
        "type": "string",
        "required": true,
        "description": "Strategy family to apply: mean reversion, momentum, trend following, pullback, event driven."
      }},
      "stop_loss": {{
        "type": "number",
        "required": false,
        "description": "Stop-loss percentage (0.25–5).",
        "default": 1
      }},
      "take_profit": {{
        "type": "number",
        "required": false,
        "description": "Take-profit percentage (1–5)."
        "default": 2
      }},
      "position_size_pct": {{
        "type": "number",
        "required": false,
        "description": "Maximum position size as a percentage of equity (e.g., 2 means 2%)."
        "default": None
      }}
    }},
    "error_messages": [
      "Missing or invalid time range: Provide valid ISO 8601 start_time and end_time with start_time < end_time.",
      "Unsupported strategy: Use one of [mean reversion, momentum, trend following, pullback, event driven].",
      "Invalid bar frequency: Use a supported value such as 1m, 5m, 1h, 1d.",
      "Incorrect parameter value: stop_loss must be within [0.25–5], take_profit must be within [1–5], position_size_pct must be within [0.1–5].",
      "Ticker not found: The provided ticker symbol is not recognized."
    ],
    "usage": "Provide ticker_symbol, start_time, end_time, and strategy; optionally set bar_freq, stop_loss, take_profit, and position_size_pct. The tool returns timestamped signals plus summary performance for the requested interval.",
    "output_details": {{
      "summary": {{
        "type": "string",
        "description": "Provides a summary of the results."
      }},
      "time_stamps": {{
        "type": "array",
        "items": {{
        "type": "string"
        }},
        "description": "An array of date-time strings for which the market data is being reported."
      }} 
      "signals": {{
        "type": "array",
        "items": {{
        "type": "string"
        }},
        "description": "An array of market-data signal strings."
      }} 
    }}
  }}
  ```
  
  Field Name: Machine Learning
  Subfield Name: Supervised Learning
  Task Name: Model selection and training
  ```json
  {{
    "tool_name": "ML Model Trainer",
    "tool_description": "A tool that assists in selecting, training, and evaluating machine learning models for supervised learning tasks.",
    "parameters": {{
      "training_data_path": {{
        "type": "string",
        "required": true,
        "description": "Provide the path to the dataset file."
      }},
      "feature_columns": {{
        "type": "array",
        "required": true,
        "description": "Provide the names of feature columns.",
        "items": {{ "type": "string" }},
        "minItems": 1,
        "maxItems": 100
      }},
      "label_column": {{
        "type": "string",
        "required": true,
        "description": "Name of the label column."
      }},
      "model_type": {{
        "type": "string",
        "required": true,
        "description": "Model family, e.g., linear regression, logistic regression, decision tree, gradient boosting, neural network, transformer, LSTM."
      }},
      "learning_rate": {{
        "type": "number",
        "required": false,
        "description": "Optimizer step size (> 0)."
        "default": 0.01
      }},
      "weight_decay": {{
        "type": "number",
        "required": false,
        "description": "L2 penalty strength (> 0)."
        "default": 0.1
      }},
      "optimizer": {{
        "type": "string",
        "required": false,
        "description": "Optimizer name, either Adam or SGD."
        "default": Adam
      }},
      "epochs": {{
        "type": "integer",
        "required": false,
        "description": "Number of training epochs (>= 1)."
        "default": 1000
      }}
    }},
    "error_messages": [
      "Insufficient training data: Ensure the dataset has enough samples for training.",
      "Invalid training data format: Ensure the data is in the correct format (Feature1, Feature2, ..., FeatureN, Label).",
      "Invalid model type: Use one of [linear regression, logistic regression, decision tree, gradient boosting, neural network, transformer, LSTM].",
      "Incorrect hyperparameter value: learning_rate and weight_decay must be greater than 0; optimizer must be either Adam or SGD; epochs must be an integer >= 1."
    ],
    "usage": "Provide training_data_path, feature_columns, label_column, and model_type; optionally set learning_rate, weight_decay, optimizer, and epochs. The tool returns training metrics and an artifacts summary.",
    "output_details": {{
      "summary": "string",
      "training_loss": "array",
      "test_loss": "array",
      "final_training_loss": "number",
      "final_test_loss": "number"
      "summary": {{
        "type": "string",
        "description": "Provides a summary of the results."
      }},
      "training_loss": {{
        "type": "array",
        "items": {{
        "type": "number"
        }},
        "description": "An array reporting the training loss at end of each epoch."
      }} 
      "test_loss": {{
        "type": "array",
        "items": {{
        "type": "number"
        }},
        "description": "An array reporting the test loss at end of each epoch."
      }},
      "final_trainig_loss": {{
        "type": "string",
        "description": "The training loss at the end of training."
      }},
      "final_test_loss": {{
        "type": "number",
        "description": "The test loss at the end of training."
      }} 
    }}
  }}
  ```

  Field Name: {field_name}
  Subfield Name: {subfield_name}
  Task Name: {task_name}