schema:
  type: object
  properties:
    tool_set_yml:
      type: string
template: |
  
  I will provide you data containing:
  (1) A field, subfield and task within subfield
  (2) Task difficulty, tool budget (number of tools)
  (3) list of all tool names and their dependencies
  (4) some multi tool plans
      - simple workflows (2 or more)
      - medium workflows (2 or more)
      - complex workflows (2 or more)
  (5) tool details

  These details are used to construct tool-use task environments:

  - Agent needs to solve the task by calling some tools

  - Tool simulator needs to respond to the tool calls made and meta-data provided to it. Basically tool-simulator when given with a tool-call looks into the meta-data, search and return relevant information. 


  Your job is to:

  1. **Generate meta-data** in JSON format that can support all levels of multi-tool plans (simple, medium, complex) that have been provided: 
      
      - The meta-data should be structured so that a tool-simulator can look into it and validate tool-calls:
        - For example, multiple (products or records or user etc.), depedending on what the requirement of tools plans are.
        - It is possible to execute same tool plan but with different specific data.
        - Aim that tool-simulator when given with a tool-call needs to look into the meta-data, search and return relevant information.
      - Generate **complex**  meta-data 
        - Add substantially more number of products or records or users etc. (depending on the above details given) than needed in tasks. This isto ensure that tool-simulator when called needs to look into the meta-data, search and return relevant information
        - Strictly ensure that all necessary inputs for every listed tool are embedded in the meta-data itself.
        - Strictly ensure that all the necessary information is there in the meta data and no external data (CSV files, Excel sheets, images, tables etc.) is needed for the tasks you will construct in the next step. 
        - You can structure the meta data, whatever way you want - just ensure that all the data needed in the inputs and outputs for the tools (while solving the task) is given in the meta data. 
      - Include:
        - `field_name`, `subfield`, and `task`.
        - `tool_budget` (max number of tools that can be called).
        - `tool_sequences` for different workflow types (`easy`, `medium`, `complex`).
  
  2. **Split the information into two categories**:
    - `hidden_meta_data`: the full product/record database that only the tool-simulator can use to validate tool calls.
    - `user_data`: information that is **not in meta-data** and must be asked interactively from the user interacting with agent.
       - Ensure that the agent has to interact with users multiple times to get necessary information and also maybe after each tool call.
       - You can also assume multiple users and then specify for each task which user is doing that task.
       - You can also keep different information with different users.
    - Ensure that the information in the meta-data and user_supplied both are needed to execute the tasks successfully.
    - Strictly ensure that all necessary inputs for every listed tool are embedded in the meta-data and user-data itself.
    - Strictly ensure that all the necessary information is there in the (meta data or user data) and no external data (CSV files, Excel sheets, images, tables etc.) is needed for the tasks you will construct in the next step. 
    - You can structure the meta data and user data, whatever way you want - just ensure that all the data needed in the inputs and outputs for the tools (while solving the task) is given in the meta data or is with user.

      
  3. **Generate multiple specific tasks** for an agent to execute using this tools and associated meta-data (note that meta-data will only be available to the tool simulator and not the agent)
    
    - For each multi-tool plan within (simple, medium, complex) workflows generate:
      - Two tasks that are **valid** (can be completed with the given tools).
      - Two tasks that are **invalid** (require missing tools or break rules).\
    - For each task - specify which user is doing it. 
    - For each task mention the number of tools required.
    - Write tasks in natural language, as instructions for an agent.
    - Mark whether the task can be solved or not.
    - **Valid** tasks must be fully executable by an Agent and Tool simulator without requiring any extra files apart from the meta data.
    - Write each task as:
      {{Task: "tasks in natural language, as instructions for an agent", User: "user-entity", Task-difficulty: "difficulty of the task", Number-tools-required: "number of tools required", Tools-required:"array of tools required to solve this task", Task-vaidity: "whether the taks is valid or not"}}

  
  4. For each task - write an ideal (tool-call, user interaction sequence) that an agent should make to successfully execute the task - (what information comes from where and how to use it) 

  5. Output format:
    - **Meta-data JSON**.
    - **hidden-meta-data JSON** - to be used by tool simulator.
    - **user_supplied JSON** - information with user. 
    - **Task List** (natural language tasks with difficulty labels) for the agent.
    - **Task ideal execution**


  Now, generate the output:
  
  Data:
  {Data}

