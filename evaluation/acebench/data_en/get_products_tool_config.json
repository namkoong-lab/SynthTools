{
    "tool_name": "get_products",
    "tool_description": "Get a list of products from a specific merchant.",
    "parameters": {
        "merchant_name": {
            "type": "string",
            "description": "The name of the merchant whose product list is being retrieved.",
            "required": true
        }
    },
    "error_messages": [],
    "usage": "Get a list of products from a specific merchant.",
    "meta_data": "```yaml\nsystem_state:\n  wifi: false  # Global system state - affects all users\n  logged_in: true  # Global system flag - scope unclear from implementation\n  logged_in_users: []  # Global list - tracks all currently logged in users across platform\n\nentities:\n  users:\n    Eve:\n      user_id: \"U100\"\n      password: \"password123\"\n      balance: 500.0\n    Frank:\n      user_id: \"U101\"\n      password: \"password456\"\n      balance: 300.0\n    Grace:\n      user_id: \"U102\"\n      password: \"password789\"\n      balance: 150.0\n    Helen:\n      user_id: \"U103\"\n      password: \"password321\"\n      balance: 800.0\n    Isaac:\n      user_id: \"U104\"\n      password: \"password654\"\n      balance: 400.0\n    Jack:\n      user_id: \"U105\"\n      password: \"password654\"\n      balance: 120.0\n\n  merchants:\n    \"Domino's\":\n      merchant_id: \"M100\"\n      service_type: \"Pizza\"\n      menu:\n        - product: \"Margherita Pizza\"\n          price: 68.0\n        - product: \"Super Supreme Pizza\"\n          price: 88.0\n    \"Rice Village Bibimbap\":\n      merchant_id: \"M101\"\n      service_type: \"Bibimbap\"\n      menu:\n        - product: \"Stone Pot Bibimbap\"\n          price: 35.0\n        - product: \"Korean Beef Bibimbap\"\n          price: 45.0\n    \"Haidilao\":\n      merchant_id: \"M102\"\n      service_type: \"Hotpot\"\n      menu:\n        - product: \"Beef Rolls\"\n          price: 68.0\n        - product: \"Seafood Platter\"\n          price: 88.0\n    \"Heytea\":\n      merchant_id: \"M103\"\n      service_type: \"Milk Tea\"\n      menu:\n        - product: \"Cheese Milk Tea\"\n          price: 25.0\n        - product: \"Four Seasons Spring Milk Tea\"\n          price: 22.0\n    \"Hema Fresh\":\n      merchant_id: \"M104\"\n      service_type: \"Fresh Grocery\"\n      menu:\n        - product: \"Organic Vegetable Pack\"\n          price: 15.0\n        - product: \"Fresh Gift Pack\"\n          price: 99.0\n    \"Jiutian BBQ\":\n      merchant_id: \"M105\"\n      service_type: \"BBQ\"\n      menu:\n        - product: \"Korean Grilled Beef\"\n          price: 128.0\n        - product: \"Grilled Pork Belly\"\n          price: 78.0\n\ninitial_data:\n  orders: []  # Initially empty, populated as orders are placed\n\ntool_mapping:\n  # Note: No tool configurations provided, but mapping structure prepared for any tools\n  login_tool:\n    api_method: \"login_food_platform\"\n    parameter_mapping:\n      username: \"username\"\n      password: \"password\"\n    validation_chain:\n      - \"Step 1: Check wifi connectivity\"\n      - \"Step 2: Validate user exists\"\n      - \"Step 3: Validate password\"\n      - \"Step 4: Check if already logged in\"\n      - \"Step 5: Add to logged_in_users\"\n    supported_parameter_ranges:\n      username:\n        valid_values: [\"Eve\", \"Frank\", \"Grace\", \"Helen\", \"Isaac\", \"Jack\"]\n        constraints: \"Must be exact case-sensitive match\"\n        edge_cases: \"Empty, null, or non-existent usernames return user not found\"\n      password:\n        valid_values: [\"password123\", \"password456\", \"password789\", \"password321\", \"password654\"]\n        constraints: \"Must match exactly with user's stored password\"\n        edge_cases: \"Empty, null, or incorrect passwords return authentication failure\"\n\nfunction_behaviors:\n  login_food_platform:\n    prerequisites:\n      - \"System wifi must be enabled (wifi == True)\"\n    validation_rules:\n      - \"Username must exist in users dictionary\"\n      - \"Password must match user's stored password\"\n      - \"User must not already be in logged_in_users list\"\n    success_conditions:\n      - \"Wifi is enabled AND user exists AND password correct AND not already logged in\"\n    error_conditions:\n      - condition: \"Wifi disabled\"\n        message: \"Wi-Fi is not enabled, unable to login\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Username not in users\"\n        message: \"User does not exist\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Incorrect password\"\n        message: \"Incorrect password\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"User already logged in\"\n        message: \"{username} is already logged in\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes:\n      - \"Adds username to logged_in_users list\"\n    parameter_handling:\n      - \"Missing username: No default, will cause user not found error\"\n      - \"Missing password: No default, will cause incorrect password error\"\n      - \"Case sensitivity: Exact match required for both username and password\"\n\n  view_logged_in_users:\n    prerequisites: []\n    validation_rules: []\n    success_conditions:\n      - \"Always succeeds, returns current state\"\n    error_conditions:\n      - condition: \"No users logged in\"\n        message: \"No users are currently logged in to the food platform\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"No parameters required\"\n\n  check_balance:\n    prerequisites: []\n    validation_rules:\n      - \"Username should exist in users dictionary\"\n    success_conditions:\n      - \"User exists in users dictionary\"\n    error_conditions:\n      - condition: \"User does not exist\"\n        message: \"Prints 'User {user_name} does not exist!' to console\"\n        tool_impact: \"Returns 0.0 balance\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing user_name: Will trigger user not found condition\"\n      - \"Invalid user_name: Returns 0.0\"\n\n  add_food_delivery_order:\n    prerequisites:\n      - \"User must be in logged_in_users list\"\n      - \"Merchant must exist in merchant_list\"\n      - \"All products must exist in merchant's menu\"\n      - \"User must have sufficient balance\"\n    validation_rules:\n      - \"Username in logged_in_users\"\n      - \"Merchant name exists in merchant_list\"\n      - \"Each item quantity is positive integer\"\n      - \"Each product exists in merchant menu\"\n      - \"Total price <= user balance\"\n    success_conditions:\n      - \"All validations pass\"\n    error_conditions:\n      - condition: \"User not logged in\"\n        message: \"User {username} is not logged in to the food platform\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Merchant does not exist\"\n        message: \"Merchant does not exist\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Invalid quantity\"\n        message: \"Invalid quantity {quantity} for product {product_name}\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Product not found\"\n        message: \"Product {product_name} does not exist in {merchant_name}'s menu\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Insufficient balance\"\n        message: \"Insufficient balance to place the order\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes:\n      - \"Deducts total_price from user balance\"\n      - \"Adds order to orders list\"\n    parameter_handling:\n      - \"Missing username: Will trigger not logged in error\"\n      - \"Missing merchant_name: Will trigger merchant not exist error\"\n      - \"Missing items: Will result in empty order with 0 total\"\n      - \"Missing quantity in item: Defaults to 1\"\n\n  get_products:\n    prerequisites: []\n    validation_rules:\n      - \"Merchant name must exist in merchant_list\"\n    success_conditions:\n      - \"Merchant exists\"\n    error_conditions:\n      - condition: \"Merchant not found\"\n        message: \"Merchant '{merchant_name}' does not exist\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing merchant_name: Will trigger merchant not found error\"\n      - \"Case sensitivity: Exact match required\"\n\n  view_orders:\n    prerequisites: []\n    validation_rules: []\n    success_conditions:\n      - \"User has orders in orders list\"\n    error_conditions:\n      - condition: \"No orders found\"\n        message: \"User has no order records\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing user_name: Will result in no matching orders\"\n      - \"Non-existent user_name: Will result in no matching orders\"\n\n  search_orders:\n    prerequisites: []\n    validation_rules: []\n    success_conditions:\n      - \"At least one order matches keyword\"\n    error_conditions:\n      - condition: \"No matching orders\"\n        message: \"No matching orders found\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing keyword: Will match orders with empty string (likely all)\"\n      - \"Case insensitive matching on merchant names and product names\"\n\nconstraints:\n  data_formats:\n    - \"Usernames: String, case-sensitive, exact match required\"\n    - \"Passwords: String, case-sensitive, exact match required\"\n    - \"Merchant names: String, case-sensitive, exact match required\"\n    - \"Product names: String, case-sensitive, exact match required\"\n    - \"Quantities: Positive integers only\"\n    - \"Prices: Float values, non-negative\"\n    - \"Balances: Float values, can be zero or positive\"\n  \n  capacity_limits:\n    - \"Maximum users: 6 predefined users\"\n    - \"Maximum merchants: 6 predefined merchants\"\n    - \"Products per merchant: 2 items each\"\n    - \"No limit on orders per user\"\n    - \"No limit on items per order\"\n  \n  business_rules:\n    - \"Users must login before placing orders\"\n    - \"Users cannot login twice simultaneously\"\n    - \"Order total cannot exceed user balance\"\n    - \"All products in order must exist in merchant menu\"\n    - \"Quantities must be positive integers\"\n  \n  validation_patterns:\n    - \"Username validation: Must exist in predefined users dictionary\"\n    - \"Password validation: Must match stored password exactly\"\n    - \"Merchant validation: Must exist in merchant_list keys\"\n    - \"Product validation: Must exist in merchant's menu\"\n    - \"Quantity validation: Must be integer > 0\"\n  \n  state_scope_clarifications:\n    - \"wifi: Global system state affecting all operations\"\n    - \"logged_in: Global flag (purpose unclear from implementation)\"\n    - \"logged_in_users: Global list tracking all logged-in users\"\n    - \"User balances: Per-user, persistent across sessions\"\n    - \"Orders: Global list, persistent, searchable by all\"\n    - \"Authentication: No session tokens, based on logged_in_users list\"\n  \n  tool_parameter_constraints:\n    - \"All string parameters are case-sensitive\"\n    - \"Username must be one of 6 predefined users\"\n    - \"Merchant names must match exactly (including special characters)\"\n    - \"Product names must match menu items exactly\"\n    - \"Quantities default to 1 if not specified\"\n\ncomprehensive_coverage:\n  edge_cases:\n    - scenario: \"Tool called with non-existent username\"\n      api_response: \"{status: false, message: 'User does not exist'}\"\n    - scenario: \"Tool called with wifi disabled\"\n      api_response: \"{status: false, message: 'Wi-Fi is not enabled, unable to login'}\"\n    - scenario: \"Tool called with user not logged in\"\n      api_response: \"{status: false, message: 'User {username} is not logged in to the food platform'}\"\n    - scenario: \"Tool called with non-existent merchant\"\n      api_response: \"{status: false, message: 'Merchant does not exist'}\"\n    - scenario: \"Tool called with non-existent product\"\n      api_response: \"{status: false, message: 'Product {product_name} does not exist in {merchant_name}s menu'}\"\n    - scenario: \"Tool called with insufficient balance\"\n      api_response: \"{status: false, message: 'Insufficient balance to place the order'}\"\n    - scenario: \"Tool called with invalid quantity (zero or negative)\"\n      api_response: \"{status: false, message: 'Invalid quantity {quantity} for product {product_name}'}\"\n    - scenario: \"Tool called with user already logged in\"\n      api_response: \"{status: false, message: '{username} is already logged in'}\"\n\n  parameter_exhaustiveness:\n    entity_reference_coverage:\n      - \"Valid usernames: Eve, Frank, Grace, Helen, Isaac, Jack\"\n      - \"Invalid usernames: Any string not in above list\"\n      - \"Valid merchant names: Domino's, Rice Village Bibimbap, Haidilao, Heytea, Hema Fresh, Jiutian BBQ\"\n      - \"Invalid merchant names: Any string not matching exactly\"\n      - \"Case sensitivity: All entity references are case-sensitive\"\n      - \"Special characters: Merchant names contain apostrophes and spaces\"\n    \n    parameter_interactions:\n      - \"Login requires wifi=True AND valid username AND correct password AND user not already logged in\"\n      - \"Order placement requires user logged in AND merchant exists AND all products exist AND sufficient balance\"\n      - \"Balance check works regardless of login status\"\n      - \"Search works on both merchant names and product names with case-insensitive matching\"\n\n  state_dependencies:\n    - \"wifi=False: Blocks all login attempts\"\n    - \"wifi=True: Allows login attempts if other conditions met\"\n    - \"logged_in_users empty: view_logged_in_users returns no users message\"\n    - \"logged_in_users populated: view_logged_in_users returns list\"\n    - \"User in logged_in_users: Can place orders\"\n    - \"User not in logged_in_users: Cannot place orders\"\n    - \"User balance >= order total: Order succeeds\"\n    - \"User balance < order total: Order fails with insufficient balance\"\n    - \"Orders list empty: view_orders and search_orders return no records\"\n    - \"Orders list populated: view_orders and search_orders can find matches\"\n```\n```yaml\nsystem_state:\n  wifi: false  # Global system state - affects all tool operations\n  logged_in: true  # Global authentication state - affects all tool operations\n  # Scope: Global per-session - maintains state across all tool calls within a session\n\nentities:\n  # No explicit entities defined in this API - operates on global system state only\n\ninitial_data:\n  # No persistent data collections - API operates purely on system state\n\ntool_mapping:\n  turn_on_wifi:\n    api_method: \"turn_on_wifi\"\n    parameter_mapping:\n      # This tool takes no parameters - direct method call\n    validation_chain:\n      - \"Step 1: Validate method exists and is callable\"\n      - \"Step 2: Execute wifi state change operation\"\n      - \"Step 3: Return success response with status and message\"\n    supported_parameter_ranges:\n      # No parameters accepted - any parameters passed will be ignored\n\n  login_device:\n    api_method: \"login_device\"\n    parameter_mapping:\n      # This tool takes no parameters - direct method call\n    validation_chain:\n      - \"Step 1: Validate method exists and is callable\"\n      - \"Step 2: Execute login state change operation\"\n      - \"Step 3: Return success response with status and message\"\n    supported_parameter_ranges:\n      # No parameters accepted - any parameters passed will be ignored\n\nfunction_behaviors:\n  turn_on_wifi:\n    prerequisites:\n      - \"No prerequisites - can be called in any system state\"\n      - \"Method exists and is accessible\"\n    validation_rules:\n      - \"No parameter validation - method accepts no parameters\"\n      - \"No authentication checks - operates regardless of logged_in state\"\n    success_conditions:\n      - \"Method executes without exception\"\n      - \"Returns dictionary with 'status': True and 'message' fields\"\n    error_conditions:\n      - condition: \"Method called on invalid API instance\"\n        message: \"AttributeError or similar Python exception\"\n        tool_impact: \"Tool call fails with system error\"\n      - condition: \"Unexpected system exception during execution\"\n        message: \"Python exception details\"\n        tool_impact: \"Tool call fails with system error\"\n    state_changes:\n      - \"Sets self.wifi = True regardless of previous state\"\n      - \"No other system state modifications\"\n    parameter_handling:\n      - \"Ignores all parameters - method signature accepts none\"\n      - \"No validation required for parameters\"\n      - \"Excess parameters are silently ignored\"\n\n  login_device:\n    prerequisites:\n      - \"No prerequisites - can be called in any system state\"\n      - \"Method exists and is accessible\"\n    validation_rules:\n      - \"No parameter validation - method accepts no parameters\"\n      - \"No authentication checks - can be called regardless of current login state\"\n    success_conditions:\n      - \"Method executes without exception\"\n      - \"Returns dictionary with 'status': True and 'message' fields\"\n    error_conditions:\n      - condition: \"Method called on invalid API instance\"\n        message: \"AttributeError or similar Python exception\"\n        tool_impact: \"Tool call fails with system error\"\n      - condition: \"Unexpected system exception during execution\"\n        message: \"Python exception details\"\n        tool_impact: \"Tool call fails with system error\"\n    state_changes:\n      - \"Sets self.logged_in = True regardless of previous state\"\n      - \"No other system state modifications\"\n    parameter_handling:\n      - \"Ignores all parameters - method signature accepts none\"\n      - \"No validation required for parameters\"\n      - \"Excess parameters are silently ignored\"\n\nconstraints:\n  data_formats:\n    - \"Response format: {'status': boolean, 'message': string}\"\n    - \"No input format constraints - no parameters accepted\"\n  capacity_limits:\n    - \"No capacity limits defined\"\n    - \"No rate limiting implemented\"\n  business_rules:\n    - \"WiFi can be turned on regardless of current state (idempotent)\"\n    - \"Login can be performed regardless of current login state (idempotent)\"\n    - \"No interdependencies between wifi and login states\"\n  validation_patterns:\n    - \"No input validation - methods accept no parameters\"\n    - \"All validation occurs at method existence level only\"\n  state_scope_clarifications:\n    - \"All state is global per API instance\"\n    - \"No user-specific or session-specific state beyond instance level\"\n    - \"State persists until instance is destroyed or _load_scenario is called\"\n    - \"No authentication scope - logged_in is binary global state\"\n  tool_parameter_constraints:\n    - \"No parameters accepted by any tool\"\n    - \"Any parameters passed to tools will be ignored\"\n    - \"No cross-parameter dependencies exist\"\n\ncomprehensive_coverage:\n  edge_cases:\n    - scenario: \"Tool called with unexpected parameters\"\n      api_response: \"Parameters ignored, normal execution proceeds\"\n    - scenario: \"Tool called multiple times consecutively\"\n      api_response: \"Idempotent behavior - same success response each time\"\n    - scenario: \"Tool called when already in target state (wifi=True for turn_on_wifi)\"\n      api_response: \"Success response - sets state to True regardless of current value\"\n    - scenario: \"Tool called when already in target state (logged_in=True for login_device)\"\n      api_response: \"Success response - sets state to True regardless of current value\"\n    - scenario: \"API instance not properly initialized\"\n      api_response: \"AttributeError or similar Python exception\"\n\n  parameter_exhaustiveness:\n    entity_reference_coverage:\n      - \"No entity references supported\"\n      - \"No identifiers to validate\"\n    parameter_interactions:\n      - \"No parameter interactions - no parameters accepted\"\n      - \"No validation order dependencies\"\n\n  state_dependencies:\n    turn_on_wifi:\n      - \"Independent of current wifi state (True or False)\"\n      - \"Independent of logged_in state\"\n      - \"Always succeeds and sets wifi=True\"\n    login_device:\n      - \"Independent of current logged_in state (True or False)\"\n      - \"Independent of wifi state\"\n      - \"Always succeeds and sets logged_in=True\"\n\n  response_format_specification:\n    turn_on_wifi:\n      success_response:\n        status: true\n        message: \"Wi-Fi has been turned on\"\n      response_type: \"Dictionary with boolean 'status' and string 'message'\"\n    login_device:\n      success_response:\n        status: true\n        message: \"Device has been logged in\"\n      response_type: \"Dictionary with boolean 'status' and string 'message'\"\n\n  method_idempotency:\n    - \"turn_on_wifi: Idempotent - multiple calls produce same result\"\n    - \"login_device: Idempotent - multiple calls produce same result\"\n    - \"Both methods always return success and set target state to True\"\n\n  scenario_loading_behavior:\n    - \"_load_scenario can override default states\"\n    - \"wifi defaults to scenario.get('wifi', False)\"\n    - \"logged_in defaults to scenario.get('logged_in', True)\"\n    - \"Scenario loading affects initial state but not tool behavior patterns\"\n```\nSYSTEM STATE\n{\n  \"wifi\": false,          // bool; default False\n  \"logged_in\": true       // bool; default True\n}\n\nUSERS/ENTITIES\n{\n  \"environment\": {\n    \"type\": \"BaseApi\",\n    \"attributes\": [\"wifi\", \"logged_in\"]\n  }\n}\n\nINITIAL DATA\n{\n  \"on_init\": {\n    \"wifi\": false,\n    \"logged_in\": true\n  }\n}\n\nCONSTRAINTS\n- Scenario loading:\n  _load_scenario(scenario: dict, long_context: bool=false)\n    \u2192 effects:\n      wifi := scenario.get(\"wifi\", false)\n      logged_in := scenario.get(\"logged_in\", true)\n    \u2192 returns: None\n    \u2192 notes:\n      - long_context is ignored (no side effects)\n      - Values from scenario are assigned as-is (no type validation)\n\n- Operations:\n  turn_on_wifi()\n    \u2192 effects: wifi := true\n    \u2192 returns: {\"status\": true, \"message\": \"Wi-Fi has been turned on\"}\n    \u2192 idempotent: calling when wifi==true returns same payload and wifi remains true\n\n  login_device()\n    \u2192 effects: logged_in := true\n    \u2192 returns: {\"status\": true, \"message\": \"Device has been logged in\"}\n    \u2192 idempotent: calling when logged_in==true returns same payload and logged_in remains true\n\n- Business rules and limitations:\n  - Only two mutable flags: wifi, logged_in\n  - No API to turn Wi-Fi off or to log out\n  - Defaults on init: wifi=false, logged_in=true\n  - Return payloads and messages are fixed strings; status always true\n  - State is per-instance, in-memory; no persistence across instances\n  - No error handling or access control implemented\n  - Expected types: bool for wifi and logged_in; however, loader does not enforce types\nSYSTEM STATE:\n{\n  \"max_capacity\": 6,\n  \"message_id_counter\": 6,\n  \"wifi\": false,            // set by _load_scenario(scenario.get(\"wifi\", false))\n  \"logged_in\": true,        // set by _load_scenario(scenario.get(\"logged_in\", true))\n  \"user_list\": {\n    \"Eve\":   {\"user_id\": \"USR100\", \"phone_number\": \"123-456-7890\", \"occupation\": \"Software Engineer\"},\n    \"Frank\": {\"user_id\": \"USR101\", \"phone_number\": \"234-567-8901\", \"occupation\": \"Data Scientist\"},\n    \"Grace\": {\"user_id\": \"USR102\", \"phone_number\": \"345-678-9012\", \"occupation\": \"Product Manager\"},\n    \"Helen\": {\"user_id\": \"USR103\", \"phone_number\": \"456-789-0123\", \"occupation\": \"UX Designer\"},\n    \"Isaac\": {\"user_id\": \"USR104\", \"phone_number\": \"567-890-1234\", \"occupation\": \"DevOps Engineer\"},\n    \"Jack\":  {\"user_id\": \"USR105\", \"phone_number\": \"678-901-2345\", \"occupation\": \"Marketing Specialist\"}\n  },\n  \"inbox\": {\n    \"1\": {\n      \"sender_id\": \"USR100\",\n      \"receiver_id\": \"USR101\",\n      \"message\": \"Hey Frank, don't forget about our meeting on 2024-06-11 at 4 PM in Conference Room 1.\",\n      \"time\": \"2024-06-09\"\n    },\n    \"2\": {\n      \"sender_id\": \"USR101\",\n      \"receiver_id\": \"USR102\",\n      \"message\": \"Can you help me order a \\\"Margherita Pizza\\\" delivery? The merchant is Domino's.\",\n      \"time\": \"2024-03-09\"\n    },\n    \"3\": {\n      \"sender_id\": \"USR102\",\n      \"receiver_id\": \"USR103\",\n      \"message\": \"Please check the milk tea delivery options available from Heytea and purchase a cheaper milk tea for me. After making the purchase, remember to reply to me with \\\"Already bought.\\\"\",\n      \"time\": \"2023-12-05\"\n    },\n    \"4\": {\n      \"sender_id\": \"USR103\",\n      \"receiver_id\": \"USR102\",\n      \"message\": \"No problem Helen, I can assist you.\",\n      \"time\": \"2024-09-09\"\n    },\n    \"5\": {\n      \"sender_id\": \"USR104\",\n      \"receiver_id\": \"USR105\",\n      \"message\": \"Isaac, are you available for a call?\",\n      \"time\": \"2024-06-06\"\n    },\n    \"6\": {\n      \"sender_id\": \"USR105\",\n      \"receiver_id\": \"USR104\",\n      \"message\": \"Yes Jack, let's do it in 30 minutes.\",\n      \"time\": \"2024-01-15\"\n    }\n  }\n}\n\nUSERS/ENTITIES:\n- Users:\n{\n  \"Eve\":   {\"user_id\": \"USR100\", \"phone_number\": \"123-456-7890\", \"occupation\": \"Software Engineer\"},\n  \"Frank\": {\"user_id\": \"USR101\", \"phone_number\": \"234-567-8901\", \"occupation\": \"Data Scientist\"},\n  \"Grace\": {\"user_id\": \"USR102\", \"phone_number\": \"345-678-9012\", \"occupation\": \"Product Manager\"},\n  \"Helen\": {\"user_id\": \"USR103\", \"phone_number\": \"456-789-0123\", \"occupation\": \"UX Designer\"},\n  \"Isaac\": {\"user_id\": \"USR104\", \"phone_number\": \"567-890-1234\", \"occupation\": \"DevOps Engineer\"},\n  \"Jack\":  {\"user_id\": \"USR105\", \"phone_number\": \"678-901-2345\", \"occupation\": \"Marketing Specialist\"}\n}\n- MessageSchema:\n{\n  \"id\": int,                            // key in inbox\n  \"sender_id\": \"USR###\",\n  \"receiver_id\": \"USR###\",\n  \"message\": str,\n  \"time\": \"YYYY-MM-DD\"                  // required by time-based APIs; new sends omit this field\n}\n\nINITIAL DATA:\n{\n  \"inbox_count\": 6,\n  \"is_inbox_full\": true,                // inbox_count == max_capacity\n  \"next_message_id_on_send\": 7,         // message_id_counter + 1\n  \"existing_times\": [\"2024-06-09\",\"2024-03-09\",\"2023-12-05\",\"2024-09-09\",\"2024-06-06\",\"2024-01-15\"]\n}\n\nCONSTRAINTS:\n- Scenario loader:\n  _load_scenario(scenario: dict, long_context: bool=False)\n  \u2192 sets: wifi = scenario.get(\"wifi\", false); logged_in = scenario.get(\"logged_in\", true)\n  \u2192 returns: None\n\n- Global:\n  - User existence check is by name key in user_list.\n  - Name\u2192ID mapping: user_list[name][\"user_id\"] used in message records.\n  - Time format required by time-based APIs: \"%Y-%m-%d\" (date only).\n  - Inbox capacity limit: len(inbox) < max_capacity required to add new message.\n  - Initial state has no free capacity; deletion required before send_message can succeed.\n  - New messages added via send_message do not store \"time\" (may break time-dependent APIs).\n\n- API: send_message(sender_name: str, receiver_name: str, message: str)\n  \u2192 requires: logged_in == true; wifi == true; len(inbox) < max_capacity; sender_name \u2208 user_list; receiver_name \u2208 user_list\n  \u2192 side-effects: message_id_counter += 1; inbox[message_id_counter] = {\"sender_id\": <sender_id>, \"receiver_id\": <receiver_id>, \"message\": <message>}\n  \u2192 returns on success: {\"status\": true, \"message\": \"Message successfully sent to <receiver_name>.\"}\n  \u2192 returns on errors:\n    - not logged in: {\"status\": false, \"message\": \"Device not logged in, unable to send message\"}\n    - wifi off: {\"status\": false, \"message\": \"Wi-Fi is turned off, cannot send messages at this time\"}\n    - capacity full: {\"status\": false, \"message\": \"Inbox capacity is full. You need to ask the user which message to delete.\"}\n    - unknown user: {\"status\": false, \"message\": \"Sender or receiver does not exist\"}\n\n- API: delete_message(message_id: int)\n  \u2192 requires: logged_in == true; message_id \u2208 inbox\n  \u2192 side-effects: del inbox[message_id]\n  \u2192 returns on success: {\"status\": true, \"message\": \"Message ID <message_id> has been successfully deleted.\"}\n  \u2192 returns on errors:\n    - not logged in: {\"status\": false, \"message\": \"Device not logged in, unable to delete message\"}\n    - id missing: {\"status\": false, \"message\": \"Message ID does not exist\"}\n\n- API: view_messages_between_users(sender_name: str, receiver_name: str)\n  \u2192 requires: logged_in == true; sender_name \u2208 user_list; receiver_name \u2208 user_list\n  \u2192 behavior: directional filter (sender_id == A.id AND receiver_id == B.id)\n  \u2192 returns on success: {\"status\": true, \"messages\": [{\"id\": <int>, \"sender\": <sender_name>, \"receiver\": <receiver_name>, \"message\": <str>}, ...]}\n  \u2192 returns when none: {\"status\": false, \"message\": \"No related message records found\"}\n  \u2192 returns on errors:\n    - not logged in: {\"status\": false, \"message\": \"Device not logged in, unable to view message information\"}\n    - unknown sender: {\"status\": false, \"message\": \"Sender does not exist\"}\n    - unknown receiver: {\"status\": false, \"message\": \"Receiver does not exist\"}\n\n- API: search_messages(user_name: str, keyword: str)\n  \u2192 requires: user_name \u2208 user_list\n  \u2192 behavior: case-insensitive substring match on message; includes sent or received by user_id\n  \u2192 returns on success: {\"status\": true, \"messages\": [{\"id\": <int>, \"sender_id\": \"USR###\", \"receiver_id\": \"USR###\", \"message\": <str>}, ...]}\n  \u2192 returns when none: {\"status\": false, \"message\": \"No messages found containing the keyword\"}\n  \u2192 note: no login or wifi required\n\n- API: get_all_message_times_with_ids()\n  \u2192 requires: logged_in == true\n  \u2192 returns on success: {<message_id>: \"<YYYY-MM-DD>\", ...}            // plain dict, no status wrapper\n  \u2192 returns on error: {\"status\": false, \"message\": \"Device not logged in, unable to retrieve all message times and their corresponding message IDs.\"}\n  \u2192 constraint: all inbox entries must contain \"time\" to avoid runtime error\n\n- API: get_latest_message_id()\n  \u2192 requires: logged_in == true; inbox not empty; all entries have \"time\" in \"%Y-%m-%d\"\n  \u2192 behavior: latest by max(datetime.strptime(time, \"%Y-%m-%d\"))\n  \u2192 returns on success: {\"status\": true, \"message\": \"The latest message ID is <id>\", \"message_id\": <id>}\n  \u2192 returns on errors:\n    - not logged in: {\"status\": false, \"message\": \"Device not logged in, unable to retrieve the latest sent message ID.\"}\n    - empty inbox: {\"status\": false, \"message\": \"No message records found\"}\n\n- API: get_earliest_message_id()\n  \u2192 requires: logged_in == true; inbox not empty; all entries have \"time\" in \"%Y-%m-%d\"\n  \u2192 behavior: earliest by min(datetime.strptime(time, \"%Y-%m-%d\"))\n  \u2192 returns on success: {\"status\": true, \"message\": \"The earliest message ID is <id>\", \"message_id\": <id>}\n  \u2192 returns on errors:\n    - not logged in: {\"status\": false, \"message\": \"Device not logged in, unable to retrieve the earliest sent message ID.\"}\n    - empty inbox: {\"status\": false, \"message\": \"No message records found\"}",
    "initial_config": {
        "BaseApi": {
            "wifi": true,
            "logged_in": true
        }
    },
    "involved_classes": [
        "BaseApi",
        "FoodPlatform"
    ]
}