{
    "tool_name": "add_food_delivery_order",
    "tool_description": "Place a food delivery order.",
    "parameters": {
        "username": {
            "type": "string",
            "description": "The name of the user placing the order.",
            "required": true
        },
        "merchant_name": {
            "type": "string",
            "description": "The name of the merchant the order is placed with.",
            "required": true
        },
        "items": {
            "type": "list",
            "description": "A list of items in the order, with each item containing name and quantity.",
            "items": {
                "type": "dict",
                "required": [
                    "product",
                    "quantity"
                ],
                "properties": {
                    "product": {
                        "type": "string",
                        "description": "The name of the product."
                    },
                    "quantity": {
                        "type": "integer",
                        "description": "The quantity of the product."
                    }
                }
            },
            "required": true
        }
    },
    "error_messages": [],
    "usage": "Place a food delivery order.",
    "meta_data": "```yaml\nsystem_state:\n  wifi: false  # Global system state - affects all users\n  logged_in: true  # Global system flag - scope unclear from implementation\n  logged_in_users: []  # Global list - tracks all currently logged in users across platform\n\nentities:\n  users:\n    Eve:\n      user_id: \"U100\"\n      password: \"password123\"\n      balance: 500.0\n    Frank:\n      user_id: \"U101\"\n      password: \"password456\"\n      balance: 300.0\n    Grace:\n      user_id: \"U102\"\n      password: \"password789\"\n      balance: 150.0\n    Helen:\n      user_id: \"U103\"\n      password: \"password321\"\n      balance: 800.0\n    Isaac:\n      user_id: \"U104\"\n      password: \"password654\"\n      balance: 400.0\n    Jack:\n      user_id: \"U105\"\n      password: \"password654\"\n      balance: 120.0\n\n  merchants:\n    \"Domino's\":\n      merchant_id: \"M100\"\n      service_type: \"Pizza\"\n      menu:\n        - product: \"Margherita Pizza\"\n          price: 68.0\n        - product: \"Super Supreme Pizza\"\n          price: 88.0\n    \"Rice Village Bibimbap\":\n      merchant_id: \"M101\"\n      service_type: \"Bibimbap\"\n      menu:\n        - product: \"Stone Pot Bibimbap\"\n          price: 35.0\n        - product: \"Korean Beef Bibimbap\"\n          price: 45.0\n    \"Haidilao\":\n      merchant_id: \"M102\"\n      service_type: \"Hotpot\"\n      menu:\n        - product: \"Beef Rolls\"\n          price: 68.0\n        - product: \"Seafood Platter\"\n          price: 88.0\n    \"Heytea\":\n      merchant_id: \"M103\"\n      service_type: \"Milk Tea\"\n      menu:\n        - product: \"Cheese Milk Tea\"\n          price: 25.0\n        - product: \"Four Seasons Spring Milk Tea\"\n          price: 22.0\n    \"Hema Fresh\":\n      merchant_id: \"M104\"\n      service_type: \"Fresh Grocery\"\n      menu:\n        - product: \"Organic Vegetable Pack\"\n          price: 15.0\n        - product: \"Fresh Gift Pack\"\n          price: 99.0\n    \"Jiutian BBQ\":\n      merchant_id: \"M105\"\n      service_type: \"BBQ\"\n      menu:\n        - product: \"Korean Grilled Beef\"\n          price: 128.0\n        - product: \"Grilled Pork Belly\"\n          price: 78.0\n\ninitial_data:\n  orders: []  # Initially empty, populated as orders are placed\n\ntool_mapping:\n  # Note: No tool configurations provided, but mapping structure prepared for any tools\n  login_tool:\n    api_method: \"login_food_platform\"\n    parameter_mapping:\n      username: \"username\"\n      password: \"password\"\n    validation_chain:\n      - \"Step 1: Check wifi connectivity\"\n      - \"Step 2: Validate user exists\"\n      - \"Step 3: Validate password\"\n      - \"Step 4: Check if already logged in\"\n      - \"Step 5: Add to logged_in_users\"\n    supported_parameter_ranges:\n      username:\n        valid_values: [\"Eve\", \"Frank\", \"Grace\", \"Helen\", \"Isaac\", \"Jack\"]\n        constraints: \"Must be exact case-sensitive match\"\n        edge_cases: \"Empty, null, or non-existent usernames return user not found\"\n      password:\n        valid_values: [\"password123\", \"password456\", \"password789\", \"password321\", \"password654\"]\n        constraints: \"Must match exactly with user's stored password\"\n        edge_cases: \"Empty, null, or incorrect passwords return authentication failure\"\n\nfunction_behaviors:\n  login_food_platform:\n    prerequisites:\n      - \"System wifi must be enabled (wifi == True)\"\n    validation_rules:\n      - \"Username must exist in users dictionary\"\n      - \"Password must match user's stored password\"\n      - \"User must not already be in logged_in_users list\"\n    success_conditions:\n      - \"Wifi is enabled AND user exists AND password correct AND not already logged in\"\n    error_conditions:\n      - condition: \"Wifi disabled\"\n        message: \"Wi-Fi is not enabled, unable to login\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Username not in users\"\n        message: \"User does not exist\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Incorrect password\"\n        message: \"Incorrect password\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"User already logged in\"\n        message: \"{username} is already logged in\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes:\n      - \"Adds username to logged_in_users list\"\n    parameter_handling:\n      - \"Missing username: No default, will cause user not found error\"\n      - \"Missing password: No default, will cause incorrect password error\"\n      - \"Case sensitivity: Exact match required for both username and password\"\n\n  view_logged_in_users:\n    prerequisites: []\n    validation_rules: []\n    success_conditions:\n      - \"Always succeeds, returns current state\"\n    error_conditions:\n      - condition: \"No users logged in\"\n        message: \"No users are currently logged in to the food platform\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"No parameters required\"\n\n  check_balance:\n    prerequisites: []\n    validation_rules:\n      - \"Username should exist in users dictionary\"\n    success_conditions:\n      - \"User exists in users dictionary\"\n    error_conditions:\n      - condition: \"User does not exist\"\n        message: \"Prints 'User {user_name} does not exist!' to console\"\n        tool_impact: \"Returns 0.0 balance\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing user_name: Will trigger user not found condition\"\n      - \"Invalid user_name: Returns 0.0\"\n\n  add_food_delivery_order:\n    prerequisites:\n      - \"User must be in logged_in_users list\"\n      - \"Merchant must exist in merchant_list\"\n      - \"All products must exist in merchant's menu\"\n      - \"User must have sufficient balance\"\n    validation_rules:\n      - \"Username in logged_in_users\"\n      - \"Merchant name exists in merchant_list\"\n      - \"Each item quantity is positive integer\"\n      - \"Each product exists in merchant menu\"\n      - \"Total price <= user balance\"\n    success_conditions:\n      - \"All validations pass\"\n    error_conditions:\n      - condition: \"User not logged in\"\n        message: \"User {username} is not logged in to the food platform\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Merchant does not exist\"\n        message: \"Merchant does not exist\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Invalid quantity\"\n        message: \"Invalid quantity {quantity} for product {product_name}\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Product not found\"\n        message: \"Product {product_name} does not exist in {merchant_name}'s menu\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n      - condition: \"Insufficient balance\"\n        message: \"Insufficient balance to place the order\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes:\n      - \"Deducts total_price from user balance\"\n      - \"Adds order to orders list\"\n    parameter_handling:\n      - \"Missing username: Will trigger not logged in error\"\n      - \"Missing merchant_name: Will trigger merchant not exist error\"\n      - \"Missing items: Will result in empty order with 0 total\"\n      - \"Missing quantity in item: Defaults to 1\"\n\n  get_products:\n    prerequisites: []\n    validation_rules:\n      - \"Merchant name must exist in merchant_list\"\n    success_conditions:\n      - \"Merchant exists\"\n    error_conditions:\n      - condition: \"Merchant not found\"\n        message: \"Merchant '{merchant_name}' does not exist\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing merchant_name: Will trigger merchant not found error\"\n      - \"Case sensitivity: Exact match required\"\n\n  view_orders:\n    prerequisites: []\n    validation_rules: []\n    success_conditions:\n      - \"User has orders in orders list\"\n    error_conditions:\n      - condition: \"No orders found\"\n        message: \"User has no order records\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing user_name: Will result in no matching orders\"\n      - \"Non-existent user_name: Will result in no matching orders\"\n\n  search_orders:\n    prerequisites: []\n    validation_rules: []\n    success_conditions:\n      - \"At least one order matches keyword\"\n    error_conditions:\n      - condition: \"No matching orders\"\n        message: \"No matching orders found\"\n        tool_impact: \"Returns {status: false, message: ...}\"\n    state_changes: []\n    parameter_handling:\n      - \"Missing keyword: Will match orders with empty string (likely all)\"\n      - \"Case insensitive matching on merchant names and product names\"\n\nconstraints:\n  data_formats:\n    - \"Usernames: String, case-sensitive, exact match required\"\n    - \"Passwords: String, case-sensitive, exact match required\"\n    - \"Merchant names: String, case-sensitive, exact match required\"\n    - \"Product names: String, case-sensitive, exact match required\"\n    - \"Quantities: Positive integers only\"\n    - \"Prices: Float values, non-negative\"\n    - \"Balances: Float values, can be zero or positive\"\n  \n  capacity_limits:\n    - \"Maximum users: 6 predefined users\"\n    - \"Maximum merchants: 6 predefined merchants\"\n    - \"Products per merchant: 2 items each\"\n    - \"No limit on orders per user\"\n    - \"No limit on items per order\"\n  \n  business_rules:\n    - \"Users must login before placing orders\"\n    - \"Users cannot login twice simultaneously\"\n    - \"Order total cannot exceed user balance\"\n    - \"All products in order must exist in merchant menu\"\n    - \"Quantities must be positive integers\"\n  \n  validation_patterns:\n    - \"Username validation: Must exist in predefined users dictionary\"\n    - \"Password validation: Must match stored password exactly\"\n    - \"Merchant validation: Must exist in merchant_list keys\"\n    - \"Product validation: Must exist in merchant's menu\"\n    - \"Quantity validation: Must be integer > 0\"\n  \n  state_scope_clarifications:\n    - \"wifi: Global system state affecting all operations\"\n    - \"logged_in: Global flag (purpose unclear from implementation)\"\n    - \"logged_in_users: Global list tracking all logged-in users\"\n    - \"User balances: Per-user, persistent across sessions\"\n    - \"Orders: Global list, persistent, searchable by all\"\n    - \"Authentication: No session tokens, based on logged_in_users list\"\n  \n  tool_parameter_constraints:\n    - \"All string parameters are case-sensitive\"\n    - \"Username must be one of 6 predefined users\"\n    - \"Merchant names must match exactly (including special characters)\"\n    - \"Product names must match menu items exactly\"\n    - \"Quantities default to 1 if not specified\"\n\ncomprehensive_coverage:\n  edge_cases:\n    - scenario: \"Tool called with non-existent username\"\n      api_response: \"{status: false, message: 'User does not exist'}\"\n    - scenario: \"Tool called with wifi disabled\"\n      api_response: \"{status: false, message: 'Wi-Fi is not enabled, unable to login'}\"\n    - scenario: \"Tool called with user not logged in\"\n      api_response: \"{status: false, message: 'User {username} is not logged in to the food platform'}\"\n    - scenario: \"Tool called with non-existent merchant\"\n      api_response: \"{status: false, message: 'Merchant does not exist'}\"\n    - scenario: \"Tool called with non-existent product\"\n      api_response: \"{status: false, message: 'Product {product_name} does not exist in {merchant_name}s menu'}\"\n    - scenario: \"Tool called with insufficient balance\"\n      api_response: \"{status: false, message: 'Insufficient balance to place the order'}\"\n    - scenario: \"Tool called with invalid quantity (zero or negative)\"\n      api_response: \"{status: false, message: 'Invalid quantity {quantity} for product {product_name}'}\"\n    - scenario: \"Tool called with user already logged in\"\n      api_response: \"{status: false, message: '{username} is already logged in'}\"\n\n  parameter_exhaustiveness:\n    entity_reference_coverage:\n      - \"Valid usernames: Eve, Frank, Grace, Helen, Isaac, Jack\"\n      - \"Invalid usernames: Any string not in above list\"\n      - \"Valid merchant names: Domino's, Rice Village Bibimbap, Haidilao, Heytea, Hema Fresh, Jiutian BBQ\"\n      - \"Invalid merchant names: Any string not matching exactly\"\n      - \"Case sensitivity: All entity references are case-sensitive\"\n      - \"Special characters: Merchant names contain apostrophes and spaces\"\n    \n    parameter_interactions:\n      - \"Login requires wifi=True AND valid username AND correct password AND user not already logged in\"\n      - \"Order placement requires user logged in AND merchant exists AND all products exist AND sufficient balance\"\n      - \"Balance check works regardless of login status\"\n      - \"Search works on both merchant names and product names with case-insensitive matching\"\n\n  state_dependencies:\n    - \"wifi=False: Blocks all login attempts\"\n    - \"wifi=True: Allows login attempts if other conditions met\"\n    - \"logged_in_users empty: view_logged_in_users returns no users message\"\n    - \"logged_in_users populated: view_logged_in_users returns list\"\n    - \"User in logged_in_users: Can place orders\"\n    - \"User not in logged_in_users: Cannot place orders\"\n    - \"User balance >= order total: Order succeeds\"\n    - \"User balance < order total: Order fails with insufficient balance\"\n    - \"Orders list empty: view_orders and search_orders return no records\"\n    - \"Orders list populated: view_orders and search_orders can find matches\"\n```\n```yaml\nsystem_state:\n  wifi: false  # Global system state - affects all tool operations\n  logged_in: true  # Global authentication state - affects all tool operations\n  # Scope: Global per-session - maintains state across all tool calls within a session\n\nentities:\n  # No explicit entities defined in this API - operates on global system state only\n\ninitial_data:\n  # No persistent data collections - API operates purely on system state\n\ntool_mapping:\n  turn_on_wifi:\n    api_method: \"turn_on_wifi\"\n    parameter_mapping:\n      # This tool takes no parameters - direct method call\n    validation_chain:\n      - \"Step 1: Validate method exists and is callable\"\n      - \"Step 2: Execute wifi state change operation\"\n      - \"Step 3: Return success response with status and message\"\n    supported_parameter_ranges:\n      # No parameters accepted - any parameters passed will be ignored\n\n  login_device:\n    api_method: \"login_device\"\n    parameter_mapping:\n      # This tool takes no parameters - direct method call\n    validation_chain:\n      - \"Step 1: Validate method exists and is callable\"\n      - \"Step 2: Execute login state change operation\"\n      - \"Step 3: Return success response with status and message\"\n    supported_parameter_ranges:\n      # No parameters accepted - any parameters passed will be ignored\n\nfunction_behaviors:\n  turn_on_wifi:\n    prerequisites:\n      - \"No prerequisites - can be called in any system state\"\n      - \"Method exists and is accessible\"\n    validation_rules:\n      - \"No parameter validation - method accepts no parameters\"\n      - \"No authentication checks - operates regardless of logged_in state\"\n    success_conditions:\n      - \"Method executes without exception\"\n      - \"Returns dictionary with 'status': True and 'message' fields\"\n    error_conditions:\n      - condition: \"Method called on invalid API instance\"\n        message: \"AttributeError or similar Python exception\"\n        tool_impact: \"Tool call fails with system error\"\n      - condition: \"Unexpected system exception during execution\"\n        message: \"Python exception details\"\n        tool_impact: \"Tool call fails with system error\"\n    state_changes:\n      - \"Sets self.wifi = True regardless of previous state\"\n      - \"No other system state modifications\"\n    parameter_handling:\n      - \"Ignores all parameters - method signature accepts none\"\n      - \"No validation required for parameters\"\n      - \"Excess parameters are silently ignored\"\n\n  login_device:\n    prerequisites:\n      - \"No prerequisites - can be called in any system state\"\n      - \"Method exists and is accessible\"\n    validation_rules:\n      - \"No parameter validation - method accepts no parameters\"\n      - \"No authentication checks - can be called regardless of current login state\"\n    success_conditions:\n      - \"Method executes without exception\"\n      - \"Returns dictionary with 'status': True and 'message' fields\"\n    error_conditions:\n      - condition: \"Method called on invalid API instance\"\n        message: \"AttributeError or similar Python exception\"\n        tool_impact: \"Tool call fails with system error\"\n      - condition: \"Unexpected system exception during execution\"\n        message: \"Python exception details\"\n        tool_impact: \"Tool call fails with system error\"\n    state_changes:\n      - \"Sets self.logged_in = True regardless of previous state\"\n      - \"No other system state modifications\"\n    parameter_handling:\n      - \"Ignores all parameters - method signature accepts none\"\n      - \"No validation required for parameters\"\n      - \"Excess parameters are silently ignored\"\n\nconstraints:\n  data_formats:\n    - \"Response format: {'status': boolean, 'message': string}\"\n    - \"No input format constraints - no parameters accepted\"\n  capacity_limits:\n    - \"No capacity limits defined\"\n    - \"No rate limiting implemented\"\n  business_rules:\n    - \"WiFi can be turned on regardless of current state (idempotent)\"\n    - \"Login can be performed regardless of current login state (idempotent)\"\n    - \"No interdependencies between wifi and login states\"\n  validation_patterns:\n    - \"No input validation - methods accept no parameters\"\n    - \"All validation occurs at method existence level only\"\n  state_scope_clarifications:\n    - \"All state is global per API instance\"\n    - \"No user-specific or session-specific state beyond instance level\"\n    - \"State persists until instance is destroyed or _load_scenario is called\"\n    - \"No authentication scope - logged_in is binary global state\"\n  tool_parameter_constraints:\n    - \"No parameters accepted by any tool\"\n    - \"Any parameters passed to tools will be ignored\"\n    - \"No cross-parameter dependencies exist\"\n\ncomprehensive_coverage:\n  edge_cases:\n    - scenario: \"Tool called with unexpected parameters\"\n      api_response: \"Parameters ignored, normal execution proceeds\"\n    - scenario: \"Tool called multiple times consecutively\"\n      api_response: \"Idempotent behavior - same success response each time\"\n    - scenario: \"Tool called when already in target state (wifi=True for turn_on_wifi)\"\n      api_response: \"Success response - sets state to True regardless of current value\"\n    - scenario: \"Tool called when already in target state (logged_in=True for login_device)\"\n      api_response: \"Success response - sets state to True regardless of current value\"\n    - scenario: \"API instance not properly initialized\"\n      api_response: \"AttributeError or similar Python exception\"\n\n  parameter_exhaustiveness:\n    entity_reference_coverage:\n      - \"No entity references supported\"\n      - \"No identifiers to validate\"\n    parameter_interactions:\n      - \"No parameter interactions - no parameters accepted\"\n      - \"No validation order dependencies\"\n\n  state_dependencies:\n    turn_on_wifi:\n      - \"Independent of current wifi state (True or False)\"\n      - \"Independent of logged_in state\"\n      - \"Always succeeds and sets wifi=True\"\n    login_device:\n      - \"Independent of current logged_in state (True or False)\"\n      - \"Independent of wifi state\"\n      - \"Always succeeds and sets logged_in=True\"\n\n  response_format_specification:\n    turn_on_wifi:\n      success_response:\n        status: true\n        message: \"Wi-Fi has been turned on\"\n      response_type: \"Dictionary with boolean 'status' and string 'message'\"\n    login_device:\n      success_response:\n        status: true\n        message: \"Device has been logged in\"\n      response_type: \"Dictionary with boolean 'status' and string 'message'\"\n\n  method_idempotency:\n    - \"turn_on_wifi: Idempotent - multiple calls produce same result\"\n    - \"login_device: Idempotent - multiple calls produce same result\"\n    - \"Both methods always return success and set target state to True\"\n\n  scenario_loading_behavior:\n    - \"_load_scenario can override default states\"\n    - \"wifi defaults to scenario.get('wifi', False)\"\n    - \"logged_in defaults to scenario.get('logged_in', True)\"\n    - \"Scenario loading affects initial state but not tool behavior patterns\"\n```\nSYSTEM STATE\n{\n  \"wifi\": {\n    \"type\": \"bool\",\n    \"default\": false\n  },\n  \"logged_in\": {\n    \"type\": \"bool\",\n    \"default\": true\n  }\n}\n\nUSERS/ENTITIES\n{\n  \"DeviceContext\": {\n    \"singleton\": true,\n    \"attributes\": {\n      \"wifi\": \"bool\",\n      \"logged_in\": \"bool\"\n    }\n  }\n}\n\nINITIAL DATA\n{\n  \"on_init\": {\n    \"wifi\": false,\n    \"logged_in\": true\n  }\n}\n\nCONSTRAINTS\n{\n  \"scenario_loading\": {\n    \"method\": \"_load_scenario(scenario: dict, long_context: bool=False) -> None\",\n    \"inputs\": {\n      \"scenario\": {\n        \"wifi?\": \"bool\",\n        \"logged_in?\": \"bool\",\n        \"...\": \"ignored\"\n      },\n      \"long_context\": \"bool (unused)\"\n    },\n    \"effects\": {\n      \"wifi\": \"scenario.wifi if present else false\",\n      \"logged_in\": \"scenario.logged_in if present else true\"\n    },\n    \"returns\": \"None\"\n  },\n  \"operations\": [\n    {\n      \"method\": \"turn_on_wifi()\",\n      \"requires\": [],\n      \"effects\": { \"wifi\": true },\n      \"returns\": { \"status\": true, \"message\": \"Wi-Fi has been turned on\" }\n    },\n    {\n      \"method\": \"login_device()\",\n      \"requires\": [],\n      \"effects\": { \"logged_in\": true },\n      \"returns\": { \"status\": true, \"message\": \"Device has been logged in\" }\n    }\n  ],\n  \"state_rules\": [\n    \"wifi \u2208 {false,true}; no API to set wifi=false\",\n    \"logged_in \u2208 {false,true}; no API to set logged_in=false\",\n    \"turn_on_wifi() and login_device() are idempotent (repeated calls keep state true and return the same payload)\",\n    \"_load_scenario overrides current state using specified defaults (wifi\u2192false, logged_in\u2192true) when keys missing\"\n  ],\n  \"return_contracts\": [\n    \"All public mutators return dict with keys: status: bool, message: str\",\n    \"Current implementation returns status=true only; no failure paths defined\"\n  ],\n  \"persistence\": \"In-memory only; no external I/O; no storage\",\n  \"errors\": \"No exceptions or validations defined for input types; non-bool values may set state as-is if provided\"\n}\nSYSTEM STATE\n{\n  wifi: false,\n  logged_in: true,\n  max_capacity: 6,\n  message_id_counter: 6\n}\n\nUSERS/ENTITIES\nuser_list: {\n  \"Eve\":   { \"user_id\": \"USR100\", \"phone_number\": \"123-456-7890\", \"occupation\": \"Software Engineer\" },\n  \"Frank\": { \"user_id\": \"USR101\", \"phone_number\": \"234-567-8901\", \"occupation\": \"Data Scientist\" },\n  \"Grace\": { \"user_id\": \"USR102\", \"phone_number\": \"345-678-9012\", \"occupation\": \"Product Manager\" },\n  \"Helen\": { \"user_id\": \"USR103\", \"phone_number\": \"456-789-0123\", \"occupation\": \"UX Designer\" },\n  \"Isaac\": { \"user_id\": \"USR104\", \"phone_number\": \"567-890-1234\", \"occupation\": \"DevOps Engineer\" },\n  \"Jack\":  { \"user_id\": \"USR105\", \"phone_number\": \"678-901-2345\", \"occupation\": \"Marketing Specialist\" }\n}\n\nINITIAL DATA\ninbox: {\n  1: {\n    \"sender_id\": \"USR100\",\n    \"receiver_id\": \"USR101\",\n    \"message\": \"Hey Frank, don't forget about our meeting on 2024-06-11 at 4 PM in Conference Room 1.\",\n    \"time\": \"2024-06-09\"\n  },\n  2: {\n    \"sender_id\": \"USR101\",\n    \"receiver_id\": \"USR102\",\n    \"message\": \"Can you help me order a \\\"Margherita Pizza\\\" delivery? The merchant is Domino's.\",\n    \"time\": \"2024-03-09\"\n  },\n  3: {\n    \"sender_id\": \"USR102\",\n    \"receiver_id\": \"USR103\",\n    \"message\": \"Please check the milk tea delivery options available from Heytea and purchase a cheaper milk tea for me. After making the purchase, remember to reply to me with \\\"Already bought.\\\"\",\n    \"time\": \"2023-12-05\"\n  },\n  4: {\n    \"sender_id\": \"USR103\",\n    \"receiver_id\": \"USR102\",\n    \"message\": \"No problem Helen, I can assist you.\",\n    \"time\": \"2024-09-09\"\n  },\n  5: {\n    \"sender_id\": \"USR104\",\n    \"receiver_id\": \"USR105\",\n    \"message\": \"Isaac, are you available for a call?\",\n    \"time\": \"2024-06-06\"\n  },\n  6: {\n    \"sender_id\": \"USR105\",\n    \"receiver_id\": \"USR104\",\n    \"message\": \"Yes Jack, let's do it in 30 minutes.\",\n    \"time\": \"2024-01-15\"\n  }\n}\n\nCONSTRAINTS\n- scenario loader\n  _load_scenario(scenario: dict, long_context: bool=false) \u2192 sets:\n    wifi = scenario.get(\"wifi\", false)\n    logged_in = scenario.get(\"logged_in\", true)\n  note: long_context is accepted but unused\n\n- send_message\n  send_message(sender_name: str, receiver_name: str, message: str) \u2192 {status: bool, message: str}\n  requires:\n    logged_in == true\n    wifi == true\n    len(inbox) < max_capacity\n    sender_name in user_list\n    receiver_name in user_list\n  effects:\n    message_id_counter += 1\n    inbox[message_id_counter] = { \"sender_id\": user_list[sender_name].user_id, \"receiver_id\": user_list[receiver_name].user_id, \"message\": message }\n    // \"time\" field not set for new messages\n  errors:\n    {status: false, message: \"Device not logged in, unable to send message\"}\n    {status: false, message: \"Wi-Fi is turned off, cannot send messages at this time\"}\n    {status: false, message: \"Inbox capacity is full. You need to ask the user which message to delete.\"}\n    {status: false, message: \"Sender or receiver does not exist\"}\n\n- delete_message\n  delete_message(message_id: int) \u2192 {status: bool, message: str}\n  requires:\n    logged_in == true\n    message_id in inbox\n  effects:\n    delete inbox[message_id]\n  errors:\n    {status: false, message: \"Device not logged in, unable to delete message\"}\n    {status: false, message: \"Message ID does not exist\"}\n\n- view_messages_between_users\n  view_messages_between_users(sender_name: str, receiver_name: str) \u2192 {status: bool, message?: str, messages?: [ {id: int, sender: str, receiver: str, message: str} ]}\n  requires:\n    logged_in == true\n    sender_name in user_list\n    receiver_name in user_list\n  behavior:\n    returns only messages where inbox[*].sender_id == user_list[sender_name].user_id and inbox[*].receiver_id == user_list[receiver_name].user_id\n  errors:\n    {status: false, message: \"Device not logged in, unable to view message information\"}\n    {status: false, message: \"Sender does not exist\"}\n    {status: false, message: \"Receiver does not exist\"}\n    {status: false, message: \"No related message records found\"}\n\n- search_messages\n  search_messages(user_name: str, keyword: str) \u2192 {status: bool, message?: str, messages?: [ {id: int, sender_id: str, receiver_id: str, message: str} ]}\n  requires:\n    user_name in user_list\n  behavior:\n    case-insensitive substring match on \"message\"\n    includes both sent and received messages for user_list[user_name].user_id\n  notes:\n    does not require logged_in\n  errors:\n    {status: false, message: \"User does not exist\"}\n    {status: false, message: \"No messages found containing the keyword\"}\n\n- get_all_message_times_with_ids\n  get_all_message_times_with_ids() \u2192 { [message_id: int]: \"YYYY-MM-DD\" } | {status: false, message: str}\n  requires:\n    logged_in == true\n    each inbox[message_id][\"time\"] exists\n  errors:\n    {status: false, message: \"Device not logged in, unable to retrieve all message times and their corresponding message IDs.\"}\n\n- get_latest_message_id\n  get_latest_message_id() \u2192 {status: bool, message: str, message_id?: int}\n  requires:\n    logged_in == true\n    inbox not empty\n    each inbox[message_id][\"time\"] parseable by \"%Y-%m-%d\"\n  behavior:\n    selects message with max(time)\n  errors:\n    {status: false, message: \"Device not logged in, unable to retrieve the latest sent message ID.\"}\n    {status: false, message: \"No message records found\"}\n\n- get_earliest_message_id\n  get_earliest_message_id() \u2192 {status: bool, message: str, message_id?: int}\n  requires:\n    logged_in == true\n    inbox not empty\n    each inbox[message_id][\"time\"] parseable by \"%Y-%m-%d\"\n  behavior:\n    selects message with min(time)\n  errors:\n    {status: false, message: \"Device not logged in, unable to retrieve the earliest sent message ID.\"}\n    {status: false, message: \"No message records found\"}\n\n- formats and limits\n  phone_number: \"NNN-NNN-NNNN\" (string)\n  user_id: \"USR\" + 3-digit number (string)\n  time: \"YYYY-MM-DD\" (string), used for comparisons/parsing\n  inbox capacity: max 6 messages (len(inbox) < 6 required to send)\n  name keys: exactly one of [\"Eve\",\"Frank\",\"Grace\",\"Helen\",\"Isaac\",\"Jack\"]\n  content validation: none (message text not validated for coherence)\n  wifi used only for send_message; logged_in required for send_message, delete_message, view_messages_between_users, time-based queries; search_messages allowed when logged_out",
    "initial_config": {
        "BaseApi": {
            "wifi": true,
            "logged_in": true
        }
    },
    "involved_classes": [
        "BaseApi",
        "FoodPlatform"
    ]
}